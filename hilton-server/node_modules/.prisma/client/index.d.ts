
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ResetToken
 * 
 */
export type ResetToken = $Result.DefaultSelection<Prisma.$ResetTokenPayload>
/**
 * Model ConfirmToken
 * 
 */
export type ConfirmToken = $Result.DefaultSelection<Prisma.$ConfirmTokenPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model RoomReservation
 * 
 */
export type RoomReservation = $Result.DefaultSelection<Prisma.$RoomReservationPayload>
/**
 * Model ExtraServices
 * 
 */
export type ExtraServices = $Result.DefaultSelection<Prisma.$ExtraServicesPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Restaurant
 * 
 */
export type Restaurant = $Result.DefaultSelection<Prisma.$RestaurantPayload>
/**
 * Model Menu
 * 
 */
export type Menu = $Result.DefaultSelection<Prisma.$MenuPayload>
/**
 * Model ClubHouse
 * 
 */
export type ClubHouse = $Result.DefaultSelection<Prisma.$ClubHousePayload>
/**
 * Model FAQS
 * 
 */
export type FAQS = $Result.DefaultSelection<Prisma.$FAQSPayload>
/**
 * Model News
 * 
 */
export type News = $Result.DefaultSelection<Prisma.$NewsPayload>
/**
 * Model Reply
 * 
 */
export type Reply = $Result.DefaultSelection<Prisma.$ReplyPayload>
/**
 * Model ContactUs
 * 
 */
export type ContactUs = $Result.DefaultSelection<Prisma.$ContactUsPayload>
/**
 * Model AppSettings
 * 
 */
export type AppSettings = $Result.DefaultSelection<Prisma.$AppSettingsPayload>
/**
 * Model HomeSliders
 * 
 */
export type HomeSliders = $Result.DefaultSelection<Prisma.$HomeSlidersPayload>
/**
 * Model PromotionVid
 * 
 */
export type PromotionVid = $Result.DefaultSelection<Prisma.$PromotionVidPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ROLE: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type ROLE = (typeof ROLE)[keyof typeof ROLE]


export const RoomTypes: {
  JUNIOR_SUITE: 'JUNIOR_SUITE',
  FAMILY_ROOM: 'FAMILY_ROOM',
  DOUBLE_ROOM: 'DOUBLE_ROOM',
  DELAUX_ROOM: 'DELAUX_ROOM',
  SUPERIOR_ROOM: 'SUPERIOR_ROOM'
};

export type RoomTypes = (typeof RoomTypes)[keyof typeof RoomTypes]


export const MenuTypes: {
  STARTERS: 'STARTERS',
  MAINS: 'MAINS',
  SALADS: 'SALADS',
  WINE: 'WINE'
};

export type MenuTypes = (typeof MenuTypes)[keyof typeof MenuTypes]


export const clubhouseTypes: {
  SPA: 'SPA',
  GYM: 'GYM',
  HEALTHCLUB: 'HEALTHCLUB'
};

export type clubhouseTypes = (typeof clubhouseTypes)[keyof typeof clubhouseTypes]

}

export type ROLE = $Enums.ROLE

export const ROLE: typeof $Enums.ROLE

export type RoomTypes = $Enums.RoomTypes

export const RoomTypes: typeof $Enums.RoomTypes

export type MenuTypes = $Enums.MenuTypes

export const MenuTypes: typeof $Enums.MenuTypes

export type clubhouseTypes = $Enums.clubhouseTypes

export const clubhouseTypes: typeof $Enums.clubhouseTypes

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.resetToken`: Exposes CRUD operations for the **ResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResetTokens
    * const resetTokens = await prisma.resetToken.findMany()
    * ```
    */
  get resetToken(): Prisma.ResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.confirmToken`: Exposes CRUD operations for the **ConfirmToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfirmTokens
    * const confirmTokens = await prisma.confirmToken.findMany()
    * ```
    */
  get confirmToken(): Prisma.ConfirmTokenDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.roomReservation`: Exposes CRUD operations for the **RoomReservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomReservations
    * const roomReservations = await prisma.roomReservation.findMany()
    * ```
    */
  get roomReservation(): Prisma.RoomReservationDelegate<ExtArgs>;

  /**
   * `prisma.extraServices`: Exposes CRUD operations for the **ExtraServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExtraServices
    * const extraServices = await prisma.extraServices.findMany()
    * ```
    */
  get extraServices(): Prisma.ExtraServicesDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.restaurant`: Exposes CRUD operations for the **Restaurant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurants
    * const restaurants = await prisma.restaurant.findMany()
    * ```
    */
  get restaurant(): Prisma.RestaurantDelegate<ExtArgs>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<ExtArgs>;

  /**
   * `prisma.clubHouse`: Exposes CRUD operations for the **ClubHouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClubHouses
    * const clubHouses = await prisma.clubHouse.findMany()
    * ```
    */
  get clubHouse(): Prisma.ClubHouseDelegate<ExtArgs>;

  /**
   * `prisma.fAQS`: Exposes CRUD operations for the **FAQS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQS
    * const fAQS = await prisma.fAQS.findMany()
    * ```
    */
  get fAQS(): Prisma.FAQSDelegate<ExtArgs>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<ExtArgs>;

  /**
   * `prisma.reply`: Exposes CRUD operations for the **Reply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Replies
    * const replies = await prisma.reply.findMany()
    * ```
    */
  get reply(): Prisma.ReplyDelegate<ExtArgs>;

  /**
   * `prisma.contactUs`: Exposes CRUD operations for the **ContactUs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactuses
    * const contactuses = await prisma.contactUs.findMany()
    * ```
    */
  get contactUs(): Prisma.ContactUsDelegate<ExtArgs>;

  /**
   * `prisma.appSettings`: Exposes CRUD operations for the **AppSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppSettings
    * const appSettings = await prisma.appSettings.findMany()
    * ```
    */
  get appSettings(): Prisma.AppSettingsDelegate<ExtArgs>;

  /**
   * `prisma.homeSliders`: Exposes CRUD operations for the **HomeSliders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomeSliders
    * const homeSliders = await prisma.homeSliders.findMany()
    * ```
    */
  get homeSliders(): Prisma.HomeSlidersDelegate<ExtArgs>;

  /**
   * `prisma.promotionVid`: Exposes CRUD operations for the **PromotionVid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionVids
    * const promotionVids = await prisma.promotionVid.findMany()
    * ```
    */
  get promotionVid(): Prisma.PromotionVidDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    User: 'User',
    ResetToken: 'ResetToken',
    ConfirmToken: 'ConfirmToken',
    RefreshToken: 'RefreshToken',
    Room: 'Room',
    RoomReservation: 'RoomReservation',
    ExtraServices: 'ExtraServices',
    Review: 'Review',
    Restaurant: 'Restaurant',
    Menu: 'Menu',
    ClubHouse: 'ClubHouse',
    FAQS: 'FAQS',
    News: 'News',
    Reply: 'Reply',
    ContactUs: 'ContactUs',
    AppSettings: 'AppSettings',
    HomeSliders: 'HomeSliders',
    PromotionVid: 'PromotionVid'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'admin' | 'user' | 'resetToken' | 'confirmToken' | 'refreshToken' | 'room' | 'roomReservation' | 'extraServices' | 'review' | 'restaurant' | 'menu' | 'clubHouse' | 'fAQS' | 'news' | 'reply' | 'contactUs' | 'appSettings' | 'homeSliders' | 'promotionVid'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ResetToken: {
        payload: Prisma.$ResetTokenPayload<ExtArgs>
        fields: Prisma.ResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResetTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResetTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResetTokenPayload>
          }
          findFirst: {
            args: Prisma.ResetTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResetTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResetTokenPayload>
          }
          findMany: {
            args: Prisma.ResetTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResetTokenPayload>[]
          }
          create: {
            args: Prisma.ResetTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResetTokenPayload>
          }
          createMany: {
            args: Prisma.ResetTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResetTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResetTokenPayload>
          }
          update: {
            args: Prisma.ResetTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.ResetTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResetTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResetTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResetTokenPayload>
          }
          aggregate: {
            args: Prisma.ResetTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResetToken>
          }
          groupBy: {
            args: Prisma.ResetTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResetTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<ResetTokenCountAggregateOutputType> | number
          }
        }
      }
      ConfirmToken: {
        payload: Prisma.$ConfirmTokenPayload<ExtArgs>
        fields: Prisma.ConfirmTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfirmTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfirmTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfirmTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfirmTokenPayload>
          }
          findFirst: {
            args: Prisma.ConfirmTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfirmTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfirmTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfirmTokenPayload>
          }
          findMany: {
            args: Prisma.ConfirmTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfirmTokenPayload>[]
          }
          create: {
            args: Prisma.ConfirmTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfirmTokenPayload>
          }
          createMany: {
            args: Prisma.ConfirmTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConfirmTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfirmTokenPayload>
          }
          update: {
            args: Prisma.ConfirmTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfirmTokenPayload>
          }
          deleteMany: {
            args: Prisma.ConfirmTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConfirmTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConfirmTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfirmTokenPayload>
          }
          aggregate: {
            args: Prisma.ConfirmTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConfirmToken>
          }
          groupBy: {
            args: Prisma.ConfirmTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConfirmTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfirmTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<ConfirmTokenCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      RoomReservation: {
        payload: Prisma.$RoomReservationPayload<ExtArgs>
        fields: Prisma.RoomReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomReservationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomReservationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomReservationPayload>
          }
          findFirst: {
            args: Prisma.RoomReservationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomReservationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomReservationPayload>
          }
          findMany: {
            args: Prisma.RoomReservationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomReservationPayload>[]
          }
          create: {
            args: Prisma.RoomReservationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomReservationPayload>
          }
          createMany: {
            args: Prisma.RoomReservationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomReservationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomReservationPayload>
          }
          update: {
            args: Prisma.RoomReservationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomReservationPayload>
          }
          deleteMany: {
            args: Prisma.RoomReservationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomReservationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomReservationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomReservationPayload>
          }
          aggregate: {
            args: Prisma.RoomReservationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomReservation>
          }
          groupBy: {
            args: Prisma.RoomReservationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomReservationCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomReservationCountAggregateOutputType> | number
          }
        }
      }
      ExtraServices: {
        payload: Prisma.$ExtraServicesPayload<ExtArgs>
        fields: Prisma.ExtraServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExtraServicesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExtraServicesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraServicesPayload>
          }
          findFirst: {
            args: Prisma.ExtraServicesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExtraServicesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraServicesPayload>
          }
          findMany: {
            args: Prisma.ExtraServicesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraServicesPayload>[]
          }
          create: {
            args: Prisma.ExtraServicesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraServicesPayload>
          }
          createMany: {
            args: Prisma.ExtraServicesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ExtraServicesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraServicesPayload>
          }
          update: {
            args: Prisma.ExtraServicesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraServicesPayload>
          }
          deleteMany: {
            args: Prisma.ExtraServicesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExtraServicesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExtraServicesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraServicesPayload>
          }
          aggregate: {
            args: Prisma.ExtraServicesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExtraServices>
          }
          groupBy: {
            args: Prisma.ExtraServicesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExtraServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExtraServicesCountArgs<ExtArgs>,
            result: $Utils.Optional<ExtraServicesCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>,
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Restaurant: {
        payload: Prisma.$RestaurantPayload<ExtArgs>
        fields: Prisma.RestaurantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findFirst: {
            args: Prisma.RestaurantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findMany: {
            args: Prisma.RestaurantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          create: {
            args: Prisma.RestaurantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          createMany: {
            args: Prisma.RestaurantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RestaurantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          update: {
            args: Prisma.RestaurantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RestaurantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          aggregate: {
            args: Prisma.RestaurantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRestaurant>
          }
          groupBy: {
            args: Prisma.RestaurantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RestaurantGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantCountArgs<ExtArgs>,
            result: $Utils.Optional<RestaurantCountAggregateOutputType> | number
          }
        }
      }
      Menu: {
        payload: Prisma.$MenuPayload<ExtArgs>
        fields: Prisma.MenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findFirst: {
            args: Prisma.MenuFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findMany: {
            args: Prisma.MenuFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          create: {
            args: Prisma.MenuCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          createMany: {
            args: Prisma.MenuCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MenuDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          update: {
            args: Prisma.MenuUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          deleteMany: {
            args: Prisma.MenuDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MenuUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MenuUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.MenuGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuCountArgs<ExtArgs>,
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      ClubHouse: {
        payload: Prisma.$ClubHousePayload<ExtArgs>
        fields: Prisma.ClubHouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubHouseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClubHousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubHouseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClubHousePayload>
          }
          findFirst: {
            args: Prisma.ClubHouseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClubHousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubHouseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClubHousePayload>
          }
          findMany: {
            args: Prisma.ClubHouseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClubHousePayload>[]
          }
          create: {
            args: Prisma.ClubHouseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClubHousePayload>
          }
          createMany: {
            args: Prisma.ClubHouseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClubHouseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClubHousePayload>
          }
          update: {
            args: Prisma.ClubHouseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClubHousePayload>
          }
          deleteMany: {
            args: Prisma.ClubHouseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClubHouseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClubHouseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClubHousePayload>
          }
          aggregate: {
            args: Prisma.ClubHouseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClubHouse>
          }
          groupBy: {
            args: Prisma.ClubHouseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClubHouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubHouseCountArgs<ExtArgs>,
            result: $Utils.Optional<ClubHouseCountAggregateOutputType> | number
          }
        }
      }
      FAQS: {
        payload: Prisma.$FAQSPayload<ExtArgs>
        fields: Prisma.FAQSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQSFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQSFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQSPayload>
          }
          findFirst: {
            args: Prisma.FAQSFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQSFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQSPayload>
          }
          findMany: {
            args: Prisma.FAQSFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQSPayload>[]
          }
          create: {
            args: Prisma.FAQSCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQSPayload>
          }
          createMany: {
            args: Prisma.FAQSCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FAQSDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQSPayload>
          }
          update: {
            args: Prisma.FAQSUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQSPayload>
          }
          deleteMany: {
            args: Prisma.FAQSDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FAQSUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FAQSUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQSPayload>
          }
          aggregate: {
            args: Prisma.FAQSAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFAQS>
          }
          groupBy: {
            args: Prisma.FAQSGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FAQSGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQSCountArgs<ExtArgs>,
            result: $Utils.Optional<FAQSCountAggregateOutputType> | number
          }
        }
      }
      News: {
        payload: Prisma.$NewsPayload<ExtArgs>
        fields: Prisma.NewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findFirst: {
            args: Prisma.NewsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findMany: {
            args: Prisma.NewsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          create: {
            args: Prisma.NewsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          createMany: {
            args: Prisma.NewsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NewsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          update: {
            args: Prisma.NewsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          deleteMany: {
            args: Prisma.NewsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NewsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NewsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.NewsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsCountArgs<ExtArgs>,
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      Reply: {
        payload: Prisma.$ReplyPayload<ExtArgs>
        fields: Prisma.ReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReplyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReplyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          findFirst: {
            args: Prisma.ReplyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReplyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          findMany: {
            args: Prisma.ReplyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>[]
          }
          create: {
            args: Prisma.ReplyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          createMany: {
            args: Prisma.ReplyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReplyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          update: {
            args: Prisma.ReplyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          deleteMany: {
            args: Prisma.ReplyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReplyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReplyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          aggregate: {
            args: Prisma.ReplyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReply>
          }
          groupBy: {
            args: Prisma.ReplyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReplyCountArgs<ExtArgs>,
            result: $Utils.Optional<ReplyCountAggregateOutputType> | number
          }
        }
      }
      ContactUs: {
        payload: Prisma.$ContactUsPayload<ExtArgs>
        fields: Prisma.ContactUsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactUsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactUsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findFirst: {
            args: Prisma.ContactUsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactUsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findMany: {
            args: Prisma.ContactUsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>[]
          }
          create: {
            args: Prisma.ContactUsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          createMany: {
            args: Prisma.ContactUsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContactUsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          update: {
            args: Prisma.ContactUsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          deleteMany: {
            args: Prisma.ContactUsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactUsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          aggregate: {
            args: Prisma.ContactUsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContactUs>
          }
          groupBy: {
            args: Prisma.ContactUsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactUsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactUsCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactUsCountAggregateOutputType> | number
          }
        }
      }
      AppSettings: {
        payload: Prisma.$AppSettingsPayload<ExtArgs>
        fields: Prisma.AppSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppSettingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppSettingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppSettingsPayload>
          }
          findFirst: {
            args: Prisma.AppSettingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppSettingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppSettingsPayload>
          }
          findMany: {
            args: Prisma.AppSettingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppSettingsPayload>[]
          }
          create: {
            args: Prisma.AppSettingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppSettingsPayload>
          }
          createMany: {
            args: Prisma.AppSettingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AppSettingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppSettingsPayload>
          }
          update: {
            args: Prisma.AppSettingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppSettingsPayload>
          }
          deleteMany: {
            args: Prisma.AppSettingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AppSettingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AppSettingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppSettingsPayload>
          }
          aggregate: {
            args: Prisma.AppSettingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAppSettings>
          }
          groupBy: {
            args: Prisma.AppSettingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AppSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppSettingsCountArgs<ExtArgs>,
            result: $Utils.Optional<AppSettingsCountAggregateOutputType> | number
          }
        }
      }
      HomeSliders: {
        payload: Prisma.$HomeSlidersPayload<ExtArgs>
        fields: Prisma.HomeSlidersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomeSlidersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HomeSlidersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomeSlidersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HomeSlidersPayload>
          }
          findFirst: {
            args: Prisma.HomeSlidersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HomeSlidersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomeSlidersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HomeSlidersPayload>
          }
          findMany: {
            args: Prisma.HomeSlidersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HomeSlidersPayload>[]
          }
          create: {
            args: Prisma.HomeSlidersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HomeSlidersPayload>
          }
          createMany: {
            args: Prisma.HomeSlidersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HomeSlidersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HomeSlidersPayload>
          }
          update: {
            args: Prisma.HomeSlidersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HomeSlidersPayload>
          }
          deleteMany: {
            args: Prisma.HomeSlidersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HomeSlidersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HomeSlidersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HomeSlidersPayload>
          }
          aggregate: {
            args: Prisma.HomeSlidersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHomeSliders>
          }
          groupBy: {
            args: Prisma.HomeSlidersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HomeSlidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomeSlidersCountArgs<ExtArgs>,
            result: $Utils.Optional<HomeSlidersCountAggregateOutputType> | number
          }
        }
      }
      PromotionVid: {
        payload: Prisma.$PromotionVidPayload<ExtArgs>
        fields: Prisma.PromotionVidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionVidFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionVidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionVidFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionVidPayload>
          }
          findFirst: {
            args: Prisma.PromotionVidFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionVidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionVidFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionVidPayload>
          }
          findMany: {
            args: Prisma.PromotionVidFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionVidPayload>[]
          }
          create: {
            args: Prisma.PromotionVidCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionVidPayload>
          }
          createMany: {
            args: Prisma.PromotionVidCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PromotionVidDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionVidPayload>
          }
          update: {
            args: Prisma.PromotionVidUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionVidPayload>
          }
          deleteMany: {
            args: Prisma.PromotionVidDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionVidUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PromotionVidUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionVidPayload>
          }
          aggregate: {
            args: Prisma.PromotionVidAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePromotionVid>
          }
          groupBy: {
            args: Prisma.PromotionVidGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PromotionVidGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionVidCountArgs<ExtArgs>,
            result: $Utils.Optional<PromotionVidCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    news: number
    contact: number
    restaurant: number
    AppSettings: number
    HomeSliders: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news?: boolean | AdminCountOutputTypeCountNewsArgs
    contact?: boolean | AdminCountOutputTypeCountContactArgs
    restaurant?: boolean | AdminCountOutputTypeCountRestaurantArgs
    AppSettings?: boolean | AdminCountOutputTypeCountAppSettingsArgs
    HomeSliders?: boolean | AdminCountOutputTypeCountHomeSlidersArgs
  }

  // Custom InputTypes

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountNewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
  }


  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactUsWhereInput
  }


  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountRestaurantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWhereInput
  }


  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAppSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppSettingsWhereInput
  }


  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountHomeSlidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeSlidersWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    room: number
    menu: number
    clubHouse: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | UserCountOutputTypeCountRoomArgs
    menu?: boolean | UserCountOutputTypeCountMenuArgs
    clubHouse?: boolean | UserCountOutputTypeCountClubHouseArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomReservationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClubHouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubHouseWhereInput
  }



  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    extraServices: number
    user: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extraServices?: boolean | RoomCountOutputTypeCountExtraServicesArgs
    user?: boolean | RoomCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountExtraServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtraServicesWhereInput
  }


  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomReservationWhereInput
  }



  /**
   * Count Type RestaurantCountOutputType
   */

  export type RestaurantCountOutputType = {
    menu: number
  }

  export type RestaurantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | RestaurantCountOutputTypeCountMenuArgs
  }

  // Custom InputTypes

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCountOutputType
     */
    select?: RestaurantCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountMenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
  }



  /**
   * Count Type NewsCountOutputType
   */

  export type NewsCountOutputType = {
    replies: number
  }

  export type NewsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | NewsCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes

  /**
   * NewsCountOutputType without action
   */
  export type NewsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsCountOutputType
     */
    select?: NewsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * NewsCountOutputType without action
   */
  export type NewsCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fullName: string | null
    email: string | null
    password: string | null
    username: string | null
    profilePic: string | null
    birthDate: Date | null
    phoneNum: string | null
    isDeleted: boolean | null
    emailConfirmed: boolean | null
    role: $Enums.ROLE | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fullName: string | null
    email: string | null
    password: string | null
    username: string | null
    profilePic: string | null
    birthDate: Date | null
    phoneNum: string | null
    isDeleted: boolean | null
    emailConfirmed: boolean | null
    role: $Enums.ROLE | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    fullName: number
    email: number
    password: number
    username: number
    profilePic: number
    birthDate: number
    phoneNum: number
    isDeleted: number
    emailConfirmed: number
    role: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fullName?: true
    email?: true
    password?: true
    username?: true
    profilePic?: true
    birthDate?: true
    phoneNum?: true
    isDeleted?: true
    emailConfirmed?: true
    role?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fullName?: true
    email?: true
    password?: true
    username?: true
    profilePic?: true
    birthDate?: true
    phoneNum?: true
    isDeleted?: true
    emailConfirmed?: true
    role?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fullName?: true
    email?: true
    password?: true
    username?: true
    profilePic?: true
    birthDate?: true
    phoneNum?: true
    isDeleted?: true
    emailConfirmed?: true
    role?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    fullName: string
    email: string
    password: string
    username: string
    profilePic: string | null
    birthDate: Date
    phoneNum: string
    isDeleted: boolean
    emailConfirmed: boolean
    role: $Enums.ROLE
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fullName?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    profilePic?: boolean
    birthDate?: boolean
    phoneNum?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: boolean
    news?: boolean | Admin$newsArgs<ExtArgs>
    contact?: boolean | Admin$contactArgs<ExtArgs>
    restaurant?: boolean | Admin$restaurantArgs<ExtArgs>
    AppSettings?: boolean | Admin$AppSettingsArgs<ExtArgs>
    ResetToken?: boolean | Admin$ResetTokenArgs<ExtArgs>
    ConfirmToken?: boolean | Admin$ConfirmTokenArgs<ExtArgs>
    RefreshToken?: boolean | Admin$RefreshTokenArgs<ExtArgs>
    HomeSliders?: boolean | Admin$HomeSlidersArgs<ExtArgs>
    PromotionVid?: boolean | Admin$PromotionVidArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fullName?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    profilePic?: boolean
    birthDate?: boolean
    phoneNum?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news?: boolean | Admin$newsArgs<ExtArgs>
    contact?: boolean | Admin$contactArgs<ExtArgs>
    restaurant?: boolean | Admin$restaurantArgs<ExtArgs>
    AppSettings?: boolean | Admin$AppSettingsArgs<ExtArgs>
    ResetToken?: boolean | Admin$ResetTokenArgs<ExtArgs>
    ConfirmToken?: boolean | Admin$ConfirmTokenArgs<ExtArgs>
    RefreshToken?: boolean | Admin$RefreshTokenArgs<ExtArgs>
    HomeSliders?: boolean | Admin$HomeSlidersArgs<ExtArgs>
    PromotionVid?: boolean | Admin$PromotionVidArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      news: Prisma.$NewsPayload<ExtArgs>[]
      contact: Prisma.$ContactUsPayload<ExtArgs>[]
      restaurant: Prisma.$RestaurantPayload<ExtArgs>[]
      AppSettings: Prisma.$AppSettingsPayload<ExtArgs>[]
      ResetToken: Prisma.$ResetTokenPayload<ExtArgs> | null
      ConfirmToken: Prisma.$ConfirmTokenPayload<ExtArgs> | null
      RefreshToken: Prisma.$RefreshTokenPayload<ExtArgs> | null
      HomeSliders: Prisma.$HomeSlidersPayload<ExtArgs>[]
      PromotionVid: Prisma.$PromotionVidPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      fullName: string
      email: string
      password: string
      username: string
      profilePic: string | null
      birthDate: Date
      phoneNum: string
      isDeleted: boolean
      emailConfirmed: boolean
      role: $Enums.ROLE
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }


  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    news<T extends Admin$newsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$newsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'findMany'> | Null>;

    contact<T extends Admin$contactArgs<ExtArgs> = {}>(args?: Subset<T, Admin$contactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'findMany'> | Null>;

    restaurant<T extends Admin$restaurantArgs<ExtArgs> = {}>(args?: Subset<T, Admin$restaurantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'findMany'> | Null>;

    AppSettings<T extends Admin$AppSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$AppSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'findMany'> | Null>;

    ResetToken<T extends Admin$ResetTokenArgs<ExtArgs> = {}>(args?: Subset<T, Admin$ResetTokenArgs<ExtArgs>>): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ConfirmToken<T extends Admin$ConfirmTokenArgs<ExtArgs> = {}>(args?: Subset<T, Admin$ConfirmTokenArgs<ExtArgs>>): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    RefreshToken<T extends Admin$RefreshTokenArgs<ExtArgs> = {}>(args?: Subset<T, Admin$RefreshTokenArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    HomeSliders<T extends Admin$HomeSlidersArgs<ExtArgs> = {}>(args?: Subset<T, Admin$HomeSlidersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'findMany'> | Null>;

    PromotionVid<T extends Admin$PromotionVidArgs<ExtArgs> = {}>(args?: Subset<T, Admin$PromotionVidArgs<ExtArgs>>): Prisma__PromotionVidClient<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
    readonly fullName: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly username: FieldRef<"Admin", 'String'>
    readonly profilePic: FieldRef<"Admin", 'String'>
    readonly birthDate: FieldRef<"Admin", 'DateTime'>
    readonly phoneNum: FieldRef<"Admin", 'String'>
    readonly isDeleted: FieldRef<"Admin", 'Boolean'>
    readonly emailConfirmed: FieldRef<"Admin", 'Boolean'>
    readonly role: FieldRef<"Admin", 'ROLE'>
  }
    

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin.news
   */
  export type Admin$newsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    cursor?: NewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }


  /**
   * Admin.contact
   */
  export type Admin$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    where?: ContactUsWhereInput
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    cursor?: ContactUsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }


  /**
   * Admin.restaurant
   */
  export type Admin$restaurantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    where?: RestaurantWhereInput
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    cursor?: RestaurantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }


  /**
   * Admin.AppSettings
   */
  export type Admin$AppSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    where?: AppSettingsWhereInput
    orderBy?: AppSettingsOrderByWithRelationInput | AppSettingsOrderByWithRelationInput[]
    cursor?: AppSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppSettingsScalarFieldEnum | AppSettingsScalarFieldEnum[]
  }


  /**
   * Admin.ResetToken
   */
  export type Admin$ResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    where?: ResetTokenWhereInput
  }


  /**
   * Admin.ConfirmToken
   */
  export type Admin$ConfirmTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    where?: ConfirmTokenWhereInput
  }


  /**
   * Admin.RefreshToken
   */
  export type Admin$RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
  }


  /**
   * Admin.HomeSliders
   */
  export type Admin$HomeSlidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    where?: HomeSlidersWhereInput
    orderBy?: HomeSlidersOrderByWithRelationInput | HomeSlidersOrderByWithRelationInput[]
    cursor?: HomeSlidersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeSlidersScalarFieldEnum | HomeSlidersScalarFieldEnum[]
  }


  /**
   * Admin.PromotionVid
   */
  export type Admin$PromotionVidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    where?: PromotionVidWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fName: string | null
    lName: string | null
    username: string | null
    email: string | null
    password: string | null
    profilePic: string | null
    birthDate: Date | null
    country: string | null
    nationalID: string | null
    isBlocked: boolean | null
    isDeleted: boolean | null
    emailConfirmed: boolean | null
    role: $Enums.ROLE | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fName: string | null
    lName: string | null
    username: string | null
    email: string | null
    password: string | null
    profilePic: string | null
    birthDate: Date | null
    country: string | null
    nationalID: string | null
    isBlocked: boolean | null
    isDeleted: boolean | null
    emailConfirmed: boolean | null
    role: $Enums.ROLE | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    fName: number
    lName: number
    username: number
    email: number
    password: number
    profilePic: number
    birthDate: number
    country: number
    nationalID: number
    isBlocked: number
    isDeleted: number
    emailConfirmed: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fName?: true
    lName?: true
    username?: true
    email?: true
    password?: true
    profilePic?: true
    birthDate?: true
    country?: true
    nationalID?: true
    isBlocked?: true
    isDeleted?: true
    emailConfirmed?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fName?: true
    lName?: true
    username?: true
    email?: true
    password?: true
    profilePic?: true
    birthDate?: true
    country?: true
    nationalID?: true
    isBlocked?: true
    isDeleted?: true
    emailConfirmed?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fName?: true
    lName?: true
    username?: true
    email?: true
    password?: true
    profilePic?: true
    birthDate?: true
    country?: true
    nationalID?: true
    isBlocked?: true
    isDeleted?: true
    emailConfirmed?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic: string | null
    birthDate: Date
    country: string
    nationalID: string
    isBlocked: boolean
    isDeleted: boolean
    emailConfirmed: boolean
    role: $Enums.ROLE
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fName?: boolean
    lName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    profilePic?: boolean
    birthDate?: boolean
    country?: boolean
    nationalID?: boolean
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: boolean
    room?: boolean | User$roomArgs<ExtArgs>
    review?: boolean | User$reviewArgs<ExtArgs>
    menu?: boolean | User$menuArgs<ExtArgs>
    clubHouse?: boolean | User$clubHouseArgs<ExtArgs>
    ResetToken?: boolean | User$ResetTokenArgs<ExtArgs>
    ConfirmToken?: boolean | User$ConfirmTokenArgs<ExtArgs>
    RefreshToken?: boolean | User$RefreshTokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fName?: boolean
    lName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    profilePic?: boolean
    birthDate?: boolean
    country?: boolean
    nationalID?: boolean
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | User$roomArgs<ExtArgs>
    review?: boolean | User$reviewArgs<ExtArgs>
    menu?: boolean | User$menuArgs<ExtArgs>
    clubHouse?: boolean | User$clubHouseArgs<ExtArgs>
    ResetToken?: boolean | User$ResetTokenArgs<ExtArgs>
    ConfirmToken?: boolean | User$ConfirmTokenArgs<ExtArgs>
    RefreshToken?: boolean | User$RefreshTokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      room: Prisma.$RoomReservationPayload<ExtArgs>[]
      review: Prisma.$ReviewPayload<ExtArgs> | null
      menu: Prisma.$MenuPayload<ExtArgs>[]
      clubHouse: Prisma.$ClubHousePayload<ExtArgs>[]
      ResetToken: Prisma.$ResetTokenPayload<ExtArgs> | null
      ConfirmToken: Prisma.$ConfirmTokenPayload<ExtArgs> | null
      RefreshToken: Prisma.$RefreshTokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      fName: string
      lName: string
      username: string
      email: string
      password: string
      profilePic: string | null
      birthDate: Date
      country: string
      nationalID: string
      isBlocked: boolean
      isDeleted: boolean
      emailConfirmed: boolean
      role: $Enums.ROLE
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    room<T extends User$roomArgs<ExtArgs> = {}>(args?: Subset<T, User$roomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'findMany'> | Null>;

    review<T extends User$reviewArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    menu<T extends User$menuArgs<ExtArgs> = {}>(args?: Subset<T, User$menuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findMany'> | Null>;

    clubHouse<T extends User$clubHouseArgs<ExtArgs> = {}>(args?: Subset<T, User$clubHouseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'findMany'> | Null>;

    ResetToken<T extends User$ResetTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$ResetTokenArgs<ExtArgs>>): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ConfirmToken<T extends User$ConfirmTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$ConfirmTokenArgs<ExtArgs>>): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    RefreshToken<T extends User$RefreshTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$RefreshTokenArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly fName: FieldRef<"User", 'String'>
    readonly lName: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly profilePic: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly country: FieldRef<"User", 'String'>
    readonly nationalID: FieldRef<"User", 'String'>
    readonly isBlocked: FieldRef<"User", 'Boolean'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly emailConfirmed: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'ROLE'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.room
   */
  export type User$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    where?: RoomReservationWhereInput
    orderBy?: RoomReservationOrderByWithRelationInput | RoomReservationOrderByWithRelationInput[]
    cursor?: RoomReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomReservationScalarFieldEnum | RoomReservationScalarFieldEnum[]
  }


  /**
   * User.review
   */
  export type User$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
  }


  /**
   * User.menu
   */
  export type User$menuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }


  /**
   * User.clubHouse
   */
  export type User$clubHouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    where?: ClubHouseWhereInput
    orderBy?: ClubHouseOrderByWithRelationInput | ClubHouseOrderByWithRelationInput[]
    cursor?: ClubHouseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubHouseScalarFieldEnum | ClubHouseScalarFieldEnum[]
  }


  /**
   * User.ResetToken
   */
  export type User$ResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    where?: ResetTokenWhereInput
  }


  /**
   * User.ConfirmToken
   */
  export type User$ConfirmTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    where?: ConfirmTokenWhereInput
  }


  /**
   * User.RefreshToken
   */
  export type User$RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model ResetToken
   */

  export type AggregateResetToken = {
    _count: ResetTokenCountAggregateOutputType | null
    _min: ResetTokenMinAggregateOutputType | null
    _max: ResetTokenMaxAggregateOutputType | null
  }

  export type ResetTokenMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    token: string | null
    userId: string | null
    adminId: string | null
    expireAt: Date | null
  }

  export type ResetTokenMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    token: string | null
    userId: string | null
    adminId: string | null
    expireAt: Date | null
  }

  export type ResetTokenCountAggregateOutputType = {
    id: number
    createdAt: number
    token: number
    userId: number
    adminId: number
    expireAt: number
    _all: number
  }


  export type ResetTokenMinAggregateInputType = {
    id?: true
    createdAt?: true
    token?: true
    userId?: true
    adminId?: true
    expireAt?: true
  }

  export type ResetTokenMaxAggregateInputType = {
    id?: true
    createdAt?: true
    token?: true
    userId?: true
    adminId?: true
    expireAt?: true
  }

  export type ResetTokenCountAggregateInputType = {
    id?: true
    createdAt?: true
    token?: true
    userId?: true
    adminId?: true
    expireAt?: true
    _all?: true
  }

  export type ResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResetToken to aggregate.
     */
    where?: ResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResetTokens to fetch.
     */
    orderBy?: ResetTokenOrderByWithRelationInput | ResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResetTokens
    **/
    _count?: true | ResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResetTokenMaxAggregateInputType
  }

  export type GetResetTokenAggregateType<T extends ResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResetToken[P]>
      : GetScalarType<T[P], AggregateResetToken[P]>
  }




  export type ResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResetTokenWhereInput
    orderBy?: ResetTokenOrderByWithAggregationInput | ResetTokenOrderByWithAggregationInput[]
    by: ResetTokenScalarFieldEnum[] | ResetTokenScalarFieldEnum
    having?: ResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResetTokenCountAggregateInputType | true
    _min?: ResetTokenMinAggregateInputType
    _max?: ResetTokenMaxAggregateInputType
  }

  export type ResetTokenGroupByOutputType = {
    id: string
    createdAt: Date
    token: string
    userId: string | null
    adminId: string | null
    expireAt: Date
    _count: ResetTokenCountAggregateOutputType | null
    _min: ResetTokenMinAggregateOutputType | null
    _max: ResetTokenMaxAggregateOutputType | null
  }

  type GetResetTokenGroupByPayload<T extends ResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], ResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type ResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    token?: boolean
    userId?: boolean
    adminId?: boolean
    expireAt?: boolean
    user?: boolean | ResetToken$userArgs<ExtArgs>
    admin?: boolean | ResetToken$adminArgs<ExtArgs>
  }, ExtArgs["result"]["resetToken"]>

  export type ResetTokenSelectScalar = {
    id?: boolean
    createdAt?: boolean
    token?: boolean
    userId?: boolean
    adminId?: boolean
    expireAt?: boolean
  }

  export type ResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ResetToken$userArgs<ExtArgs>
    admin?: boolean | ResetToken$adminArgs<ExtArgs>
  }


  export type $ResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      token: string
      userId: string | null
      adminId: string | null
      expireAt: Date
    }, ExtArgs["result"]["resetToken"]>
    composites: {}
  }


  type ResetTokenGetPayload<S extends boolean | null | undefined | ResetTokenDefaultArgs> = $Result.GetResult<Prisma.$ResetTokenPayload, S>

  type ResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResetTokenCountAggregateInputType | true
    }

  export interface ResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResetToken'], meta: { name: 'ResetToken' } }
    /**
     * Find zero or one ResetToken that matches the filter.
     * @param {ResetTokenFindUniqueArgs} args - Arguments to find a ResetToken
     * @example
     * // Get one ResetToken
     * const resetToken = await prisma.resetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResetTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResetTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ResetToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResetTokenFindUniqueOrThrowArgs} args - Arguments to find a ResetToken
     * @example
     * // Get one ResetToken
     * const resetToken = await prisma.resetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResetTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResetTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResetTokenFindFirstArgs} args - Arguments to find a ResetToken
     * @example
     * // Get one ResetToken
     * const resetToken = await prisma.resetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResetTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResetTokenFindFirstArgs<ExtArgs>>
    ): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResetTokenFindFirstOrThrowArgs} args - Arguments to find a ResetToken
     * @example
     * // Get one ResetToken
     * const resetToken = await prisma.resetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResetTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResetTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResetTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResetTokens
     * const resetTokens = await prisma.resetToken.findMany()
     * 
     * // Get first 10 ResetTokens
     * const resetTokens = await prisma.resetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resetTokenWithIdOnly = await prisma.resetToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResetTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResetTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ResetToken.
     * @param {ResetTokenCreateArgs} args - Arguments to create a ResetToken.
     * @example
     * // Create one ResetToken
     * const ResetToken = await prisma.resetToken.create({
     *   data: {
     *     // ... data to create a ResetToken
     *   }
     * })
     * 
    **/
    create<T extends ResetTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResetTokenCreateArgs<ExtArgs>>
    ): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ResetTokens.
     *     @param {ResetTokenCreateManyArgs} args - Arguments to create many ResetTokens.
     *     @example
     *     // Create many ResetTokens
     *     const resetToken = await prisma.resetToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResetTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResetTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResetToken.
     * @param {ResetTokenDeleteArgs} args - Arguments to delete one ResetToken.
     * @example
     * // Delete one ResetToken
     * const ResetToken = await prisma.resetToken.delete({
     *   where: {
     *     // ... filter to delete one ResetToken
     *   }
     * })
     * 
    **/
    delete<T extends ResetTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResetTokenDeleteArgs<ExtArgs>>
    ): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ResetToken.
     * @param {ResetTokenUpdateArgs} args - Arguments to update one ResetToken.
     * @example
     * // Update one ResetToken
     * const resetToken = await prisma.resetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResetTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResetTokenUpdateArgs<ExtArgs>>
    ): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ResetTokens.
     * @param {ResetTokenDeleteManyArgs} args - Arguments to filter ResetTokens to delete.
     * @example
     * // Delete a few ResetTokens
     * const { count } = await prisma.resetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResetTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResetTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResetTokens
     * const resetToken = await prisma.resetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResetTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResetTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResetToken.
     * @param {ResetTokenUpsertArgs} args - Arguments to update or create a ResetToken.
     * @example
     * // Update or create a ResetToken
     * const resetToken = await prisma.resetToken.upsert({
     *   create: {
     *     // ... data to create a ResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResetToken we want to update
     *   }
     * })
    **/
    upsert<T extends ResetTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResetTokenUpsertArgs<ExtArgs>>
    ): Prisma__ResetTokenClient<$Result.GetResult<Prisma.$ResetTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResetTokenCountArgs} args - Arguments to filter ResetTokens to count.
     * @example
     * // Count the number of ResetTokens
     * const count = await prisma.resetToken.count({
     *   where: {
     *     // ... the filter for the ResetTokens we want to count
     *   }
     * })
    **/
    count<T extends ResetTokenCountArgs>(
      args?: Subset<T, ResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResetTokenAggregateArgs>(args: Subset<T, ResetTokenAggregateArgs>): Prisma.PrismaPromise<GetResetTokenAggregateType<T>>

    /**
     * Group by ResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: ResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResetToken model
   */
  readonly fields: ResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends ResetToken$userArgs<ExtArgs> = {}>(args?: Subset<T, ResetToken$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    admin<T extends ResetToken$adminArgs<ExtArgs> = {}>(args?: Subset<T, ResetToken$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ResetToken model
   */ 
  interface ResetTokenFieldRefs {
    readonly id: FieldRef<"ResetToken", 'String'>
    readonly createdAt: FieldRef<"ResetToken", 'DateTime'>
    readonly token: FieldRef<"ResetToken", 'String'>
    readonly userId: FieldRef<"ResetToken", 'String'>
    readonly adminId: FieldRef<"ResetToken", 'String'>
    readonly expireAt: FieldRef<"ResetToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ResetToken findUnique
   */
  export type ResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which ResetToken to fetch.
     */
    where: ResetTokenWhereUniqueInput
  }


  /**
   * ResetToken findUniqueOrThrow
   */
  export type ResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which ResetToken to fetch.
     */
    where: ResetTokenWhereUniqueInput
  }


  /**
   * ResetToken findFirst
   */
  export type ResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which ResetToken to fetch.
     */
    where?: ResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResetTokens to fetch.
     */
    orderBy?: ResetTokenOrderByWithRelationInput | ResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResetTokens.
     */
    cursor?: ResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResetTokens.
     */
    distinct?: ResetTokenScalarFieldEnum | ResetTokenScalarFieldEnum[]
  }


  /**
   * ResetToken findFirstOrThrow
   */
  export type ResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which ResetToken to fetch.
     */
    where?: ResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResetTokens to fetch.
     */
    orderBy?: ResetTokenOrderByWithRelationInput | ResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResetTokens.
     */
    cursor?: ResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResetTokens.
     */
    distinct?: ResetTokenScalarFieldEnum | ResetTokenScalarFieldEnum[]
  }


  /**
   * ResetToken findMany
   */
  export type ResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which ResetTokens to fetch.
     */
    where?: ResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResetTokens to fetch.
     */
    orderBy?: ResetTokenOrderByWithRelationInput | ResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResetTokens.
     */
    cursor?: ResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResetTokens.
     */
    skip?: number
    distinct?: ResetTokenScalarFieldEnum | ResetTokenScalarFieldEnum[]
  }


  /**
   * ResetToken create
   */
  export type ResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a ResetToken.
     */
    data: XOR<ResetTokenCreateInput, ResetTokenUncheckedCreateInput>
  }


  /**
   * ResetToken createMany
   */
  export type ResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResetTokens.
     */
    data: ResetTokenCreateManyInput | ResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ResetToken update
   */
  export type ResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a ResetToken.
     */
    data: XOR<ResetTokenUpdateInput, ResetTokenUncheckedUpdateInput>
    /**
     * Choose, which ResetToken to update.
     */
    where: ResetTokenWhereUniqueInput
  }


  /**
   * ResetToken updateMany
   */
  export type ResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResetTokens.
     */
    data: XOR<ResetTokenUpdateManyMutationInput, ResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which ResetTokens to update
     */
    where?: ResetTokenWhereInput
  }


  /**
   * ResetToken upsert
   */
  export type ResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the ResetToken to update in case it exists.
     */
    where: ResetTokenWhereUniqueInput
    /**
     * In case the ResetToken found by the `where` argument doesn't exist, create a new ResetToken with this data.
     */
    create: XOR<ResetTokenCreateInput, ResetTokenUncheckedCreateInput>
    /**
     * In case the ResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResetTokenUpdateInput, ResetTokenUncheckedUpdateInput>
  }


  /**
   * ResetToken delete
   */
  export type ResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
    /**
     * Filter which ResetToken to delete.
     */
    where: ResetTokenWhereUniqueInput
  }


  /**
   * ResetToken deleteMany
   */
  export type ResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResetTokens to delete
     */
    where?: ResetTokenWhereInput
  }


  /**
   * ResetToken.user
   */
  export type ResetToken$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * ResetToken.admin
   */
  export type ResetToken$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }


  /**
   * ResetToken without action
   */
  export type ResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResetToken
     */
    select?: ResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResetTokenInclude<ExtArgs> | null
  }



  /**
   * Model ConfirmToken
   */

  export type AggregateConfirmToken = {
    _count: ConfirmTokenCountAggregateOutputType | null
    _min: ConfirmTokenMinAggregateOutputType | null
    _max: ConfirmTokenMaxAggregateOutputType | null
  }

  export type ConfirmTokenMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    token: string | null
    userId: string | null
    adminId: string | null
    expireAt: Date | null
  }

  export type ConfirmTokenMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    token: string | null
    userId: string | null
    adminId: string | null
    expireAt: Date | null
  }

  export type ConfirmTokenCountAggregateOutputType = {
    id: number
    createdAt: number
    token: number
    userId: number
    adminId: number
    expireAt: number
    _all: number
  }


  export type ConfirmTokenMinAggregateInputType = {
    id?: true
    createdAt?: true
    token?: true
    userId?: true
    adminId?: true
    expireAt?: true
  }

  export type ConfirmTokenMaxAggregateInputType = {
    id?: true
    createdAt?: true
    token?: true
    userId?: true
    adminId?: true
    expireAt?: true
  }

  export type ConfirmTokenCountAggregateInputType = {
    id?: true
    createdAt?: true
    token?: true
    userId?: true
    adminId?: true
    expireAt?: true
    _all?: true
  }

  export type ConfirmTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfirmToken to aggregate.
     */
    where?: ConfirmTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfirmTokens to fetch.
     */
    orderBy?: ConfirmTokenOrderByWithRelationInput | ConfirmTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfirmTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfirmTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfirmTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfirmTokens
    **/
    _count?: true | ConfirmTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfirmTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfirmTokenMaxAggregateInputType
  }

  export type GetConfirmTokenAggregateType<T extends ConfirmTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateConfirmToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfirmToken[P]>
      : GetScalarType<T[P], AggregateConfirmToken[P]>
  }




  export type ConfirmTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfirmTokenWhereInput
    orderBy?: ConfirmTokenOrderByWithAggregationInput | ConfirmTokenOrderByWithAggregationInput[]
    by: ConfirmTokenScalarFieldEnum[] | ConfirmTokenScalarFieldEnum
    having?: ConfirmTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfirmTokenCountAggregateInputType | true
    _min?: ConfirmTokenMinAggregateInputType
    _max?: ConfirmTokenMaxAggregateInputType
  }

  export type ConfirmTokenGroupByOutputType = {
    id: string
    createdAt: Date
    token: string
    userId: string | null
    adminId: string | null
    expireAt: Date
    _count: ConfirmTokenCountAggregateOutputType | null
    _min: ConfirmTokenMinAggregateOutputType | null
    _max: ConfirmTokenMaxAggregateOutputType | null
  }

  type GetConfirmTokenGroupByPayload<T extends ConfirmTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfirmTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfirmTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfirmTokenGroupByOutputType[P]>
            : GetScalarType<T[P], ConfirmTokenGroupByOutputType[P]>
        }
      >
    >


  export type ConfirmTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    token?: boolean
    userId?: boolean
    adminId?: boolean
    expireAt?: boolean
    user?: boolean | ConfirmToken$userArgs<ExtArgs>
    admin?: boolean | ConfirmToken$adminArgs<ExtArgs>
  }, ExtArgs["result"]["confirmToken"]>

  export type ConfirmTokenSelectScalar = {
    id?: boolean
    createdAt?: boolean
    token?: boolean
    userId?: boolean
    adminId?: boolean
    expireAt?: boolean
  }

  export type ConfirmTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ConfirmToken$userArgs<ExtArgs>
    admin?: boolean | ConfirmToken$adminArgs<ExtArgs>
  }


  export type $ConfirmTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfirmToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      token: string
      userId: string | null
      adminId: string | null
      expireAt: Date
    }, ExtArgs["result"]["confirmToken"]>
    composites: {}
  }


  type ConfirmTokenGetPayload<S extends boolean | null | undefined | ConfirmTokenDefaultArgs> = $Result.GetResult<Prisma.$ConfirmTokenPayload, S>

  type ConfirmTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfirmTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfirmTokenCountAggregateInputType | true
    }

  export interface ConfirmTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfirmToken'], meta: { name: 'ConfirmToken' } }
    /**
     * Find zero or one ConfirmToken that matches the filter.
     * @param {ConfirmTokenFindUniqueArgs} args - Arguments to find a ConfirmToken
     * @example
     * // Get one ConfirmToken
     * const confirmToken = await prisma.confirmToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConfirmTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConfirmTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConfirmToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConfirmTokenFindUniqueOrThrowArgs} args - Arguments to find a ConfirmToken
     * @example
     * // Get one ConfirmToken
     * const confirmToken = await prisma.confirmToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConfirmTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfirmTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConfirmToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmTokenFindFirstArgs} args - Arguments to find a ConfirmToken
     * @example
     * // Get one ConfirmToken
     * const confirmToken = await prisma.confirmToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConfirmTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfirmTokenFindFirstArgs<ExtArgs>>
    ): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConfirmToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmTokenFindFirstOrThrowArgs} args - Arguments to find a ConfirmToken
     * @example
     * // Get one ConfirmToken
     * const confirmToken = await prisma.confirmToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConfirmTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfirmTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConfirmTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfirmTokens
     * const confirmTokens = await prisma.confirmToken.findMany()
     * 
     * // Get first 10 ConfirmTokens
     * const confirmTokens = await prisma.confirmToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const confirmTokenWithIdOnly = await prisma.confirmToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConfirmTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfirmTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConfirmToken.
     * @param {ConfirmTokenCreateArgs} args - Arguments to create a ConfirmToken.
     * @example
     * // Create one ConfirmToken
     * const ConfirmToken = await prisma.confirmToken.create({
     *   data: {
     *     // ... data to create a ConfirmToken
     *   }
     * })
     * 
    **/
    create<T extends ConfirmTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConfirmTokenCreateArgs<ExtArgs>>
    ): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConfirmTokens.
     *     @param {ConfirmTokenCreateManyArgs} args - Arguments to create many ConfirmTokens.
     *     @example
     *     // Create many ConfirmTokens
     *     const confirmToken = await prisma.confirmToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConfirmTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfirmTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConfirmToken.
     * @param {ConfirmTokenDeleteArgs} args - Arguments to delete one ConfirmToken.
     * @example
     * // Delete one ConfirmToken
     * const ConfirmToken = await prisma.confirmToken.delete({
     *   where: {
     *     // ... filter to delete one ConfirmToken
     *   }
     * })
     * 
    **/
    delete<T extends ConfirmTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConfirmTokenDeleteArgs<ExtArgs>>
    ): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConfirmToken.
     * @param {ConfirmTokenUpdateArgs} args - Arguments to update one ConfirmToken.
     * @example
     * // Update one ConfirmToken
     * const confirmToken = await prisma.confirmToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConfirmTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConfirmTokenUpdateArgs<ExtArgs>>
    ): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConfirmTokens.
     * @param {ConfirmTokenDeleteManyArgs} args - Arguments to filter ConfirmTokens to delete.
     * @example
     * // Delete a few ConfirmTokens
     * const { count } = await prisma.confirmToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConfirmTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfirmTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfirmTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfirmTokens
     * const confirmToken = await prisma.confirmToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConfirmTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConfirmTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfirmToken.
     * @param {ConfirmTokenUpsertArgs} args - Arguments to update or create a ConfirmToken.
     * @example
     * // Update or create a ConfirmToken
     * const confirmToken = await prisma.confirmToken.upsert({
     *   create: {
     *     // ... data to create a ConfirmToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfirmToken we want to update
     *   }
     * })
    **/
    upsert<T extends ConfirmTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConfirmTokenUpsertArgs<ExtArgs>>
    ): Prisma__ConfirmTokenClient<$Result.GetResult<Prisma.$ConfirmTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConfirmTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmTokenCountArgs} args - Arguments to filter ConfirmTokens to count.
     * @example
     * // Count the number of ConfirmTokens
     * const count = await prisma.confirmToken.count({
     *   where: {
     *     // ... the filter for the ConfirmTokens we want to count
     *   }
     * })
    **/
    count<T extends ConfirmTokenCountArgs>(
      args?: Subset<T, ConfirmTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfirmTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfirmToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfirmTokenAggregateArgs>(args: Subset<T, ConfirmTokenAggregateArgs>): Prisma.PrismaPromise<GetConfirmTokenAggregateType<T>>

    /**
     * Group by ConfirmToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfirmTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfirmTokenGroupByArgs['orderBy'] }
        : { orderBy?: ConfirmTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfirmTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfirmTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfirmToken model
   */
  readonly fields: ConfirmTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfirmToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfirmTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends ConfirmToken$userArgs<ExtArgs> = {}>(args?: Subset<T, ConfirmToken$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    admin<T extends ConfirmToken$adminArgs<ExtArgs> = {}>(args?: Subset<T, ConfirmToken$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConfirmToken model
   */ 
  interface ConfirmTokenFieldRefs {
    readonly id: FieldRef<"ConfirmToken", 'String'>
    readonly createdAt: FieldRef<"ConfirmToken", 'DateTime'>
    readonly token: FieldRef<"ConfirmToken", 'String'>
    readonly userId: FieldRef<"ConfirmToken", 'String'>
    readonly adminId: FieldRef<"ConfirmToken", 'String'>
    readonly expireAt: FieldRef<"ConfirmToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ConfirmToken findUnique
   */
  export type ConfirmTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmToken to fetch.
     */
    where: ConfirmTokenWhereUniqueInput
  }


  /**
   * ConfirmToken findUniqueOrThrow
   */
  export type ConfirmTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmToken to fetch.
     */
    where: ConfirmTokenWhereUniqueInput
  }


  /**
   * ConfirmToken findFirst
   */
  export type ConfirmTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmToken to fetch.
     */
    where?: ConfirmTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfirmTokens to fetch.
     */
    orderBy?: ConfirmTokenOrderByWithRelationInput | ConfirmTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfirmTokens.
     */
    cursor?: ConfirmTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfirmTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfirmTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfirmTokens.
     */
    distinct?: ConfirmTokenScalarFieldEnum | ConfirmTokenScalarFieldEnum[]
  }


  /**
   * ConfirmToken findFirstOrThrow
   */
  export type ConfirmTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmToken to fetch.
     */
    where?: ConfirmTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfirmTokens to fetch.
     */
    orderBy?: ConfirmTokenOrderByWithRelationInput | ConfirmTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfirmTokens.
     */
    cursor?: ConfirmTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfirmTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfirmTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfirmTokens.
     */
    distinct?: ConfirmTokenScalarFieldEnum | ConfirmTokenScalarFieldEnum[]
  }


  /**
   * ConfirmToken findMany
   */
  export type ConfirmTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmTokens to fetch.
     */
    where?: ConfirmTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfirmTokens to fetch.
     */
    orderBy?: ConfirmTokenOrderByWithRelationInput | ConfirmTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfirmTokens.
     */
    cursor?: ConfirmTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfirmTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfirmTokens.
     */
    skip?: number
    distinct?: ConfirmTokenScalarFieldEnum | ConfirmTokenScalarFieldEnum[]
  }


  /**
   * ConfirmToken create
   */
  export type ConfirmTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfirmToken.
     */
    data: XOR<ConfirmTokenCreateInput, ConfirmTokenUncheckedCreateInput>
  }


  /**
   * ConfirmToken createMany
   */
  export type ConfirmTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfirmTokens.
     */
    data: ConfirmTokenCreateManyInput | ConfirmTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ConfirmToken update
   */
  export type ConfirmTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfirmToken.
     */
    data: XOR<ConfirmTokenUpdateInput, ConfirmTokenUncheckedUpdateInput>
    /**
     * Choose, which ConfirmToken to update.
     */
    where: ConfirmTokenWhereUniqueInput
  }


  /**
   * ConfirmToken updateMany
   */
  export type ConfirmTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfirmTokens.
     */
    data: XOR<ConfirmTokenUpdateManyMutationInput, ConfirmTokenUncheckedUpdateManyInput>
    /**
     * Filter which ConfirmTokens to update
     */
    where?: ConfirmTokenWhereInput
  }


  /**
   * ConfirmToken upsert
   */
  export type ConfirmTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfirmToken to update in case it exists.
     */
    where: ConfirmTokenWhereUniqueInput
    /**
     * In case the ConfirmToken found by the `where` argument doesn't exist, create a new ConfirmToken with this data.
     */
    create: XOR<ConfirmTokenCreateInput, ConfirmTokenUncheckedCreateInput>
    /**
     * In case the ConfirmToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfirmTokenUpdateInput, ConfirmTokenUncheckedUpdateInput>
  }


  /**
   * ConfirmToken delete
   */
  export type ConfirmTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
    /**
     * Filter which ConfirmToken to delete.
     */
    where: ConfirmTokenWhereUniqueInput
  }


  /**
   * ConfirmToken deleteMany
   */
  export type ConfirmTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfirmTokens to delete
     */
    where?: ConfirmTokenWhereInput
  }


  /**
   * ConfirmToken.user
   */
  export type ConfirmToken$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * ConfirmToken.admin
   */
  export type ConfirmToken$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }


  /**
   * ConfirmToken without action
   */
  export type ConfirmTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmToken
     */
    select?: ConfirmTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfirmTokenInclude<ExtArgs> | null
  }



  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    token: string | null
    userId: string | null
    adminId: string | null
    expireAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    token: string | null
    userId: string | null
    adminId: string | null
    expireAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    createdAt: number
    token: number
    userId: number
    adminId: number
    expireAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    createdAt?: true
    token?: true
    userId?: true
    adminId?: true
    expireAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    createdAt?: true
    token?: true
    userId?: true
    adminId?: true
    expireAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    createdAt?: true
    token?: true
    userId?: true
    adminId?: true
    expireAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    createdAt: Date
    token: string
    userId: string | null
    adminId: string | null
    expireAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    token?: boolean
    userId?: boolean
    adminId?: boolean
    expireAt?: boolean
    user?: boolean | RefreshToken$userArgs<ExtArgs>
    admin?: boolean | RefreshToken$adminArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    createdAt?: boolean
    token?: boolean
    userId?: boolean
    adminId?: boolean
    expireAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | RefreshToken$userArgs<ExtArgs>
    admin?: boolean | RefreshToken$adminArgs<ExtArgs>
  }


  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      token: string
      userId: string | null
      adminId: string | null
      expireAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }


  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RefreshTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RefreshTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RefreshTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
    **/
    create<T extends RefreshTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     *     @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     *     @example
     *     // Create many RefreshTokens
     *     const refreshToken = await prisma.refreshToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RefreshTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
    **/
    delete<T extends RefreshTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RefreshTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RefreshTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RefreshTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
    **/
    upsert<T extends RefreshTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends RefreshToken$userArgs<ExtArgs> = {}>(args?: Subset<T, RefreshToken$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    admin<T extends RefreshToken$adminArgs<ExtArgs> = {}>(args?: Subset<T, RefreshToken$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly adminId: FieldRef<"RefreshToken", 'String'>
    readonly expireAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }


  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }


  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }


  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }


  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }


  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }


  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }


  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }


  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }


  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }


  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }


  /**
   * RefreshToken.user
   */
  export type RefreshToken$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * RefreshToken.admin
   */
  export type RefreshToken$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }


  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }



  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roomNum: string | null
    types: $Enums.RoomTypes | null
    price: string | null
    description: string | null
    view: string | null
    isDeleted: boolean | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roomNum: string | null
    types: $Enums.RoomTypes | null
    price: string | null
    description: string | null
    view: string | null
    isDeleted: boolean | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    roomNum: number
    types: number
    price: number
    description: number
    aminities: number
    images: number
    view: number
    isDeleted: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    roomNum?: true
    types?: true
    price?: true
    description?: true
    view?: true
    isDeleted?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    roomNum?: true
    types?: true
    price?: true
    description?: true
    view?: true
    isDeleted?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    roomNum?: true
    types?: true
    price?: true
    description?: true
    aminities?: true
    images?: true
    view?: true
    isDeleted?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    roomNum: string
    types: $Enums.RoomTypes
    price: string
    description: string
    aminities: string[]
    images: string[]
    view: string
    isDeleted: boolean
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roomNum?: boolean
    types?: boolean
    price?: boolean
    description?: boolean
    aminities?: boolean
    images?: boolean
    view?: boolean
    isDeleted?: boolean
    extraServices?: boolean | Room$extraServicesArgs<ExtArgs>
    user?: boolean | Room$userArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roomNum?: boolean
    types?: boolean
    price?: boolean
    description?: boolean
    aminities?: boolean
    images?: boolean
    view?: boolean
    isDeleted?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extraServices?: boolean | Room$extraServicesArgs<ExtArgs>
    user?: boolean | Room$userArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      extraServices: Prisma.$ExtraServicesPayload<ExtArgs>[]
      user: Prisma.$RoomReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      roomNum: string
      types: $Enums.RoomTypes
      price: string
      description: string
      aminities: string[]
      images: string[]
      view: string
      isDeleted: boolean
    }, ExtArgs["result"]["room"]>
    composites: {}
  }


  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
    **/
    create<T extends RoomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomCreateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rooms.
     *     @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     *     @example
     *     // Create many Rooms
     *     const room = await prisma.room.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
    **/
    delete<T extends RoomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
    **/
    upsert<T extends RoomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    extraServices<T extends Room$extraServicesArgs<ExtArgs> = {}>(args?: Subset<T, Room$extraServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'findMany'> | Null>;

    user<T extends Room$userArgs<ExtArgs> = {}>(args?: Subset<T, Room$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
    readonly roomNum: FieldRef<"Room", 'String'>
    readonly types: FieldRef<"Room", 'RoomTypes'>
    readonly price: FieldRef<"Room", 'String'>
    readonly description: FieldRef<"Room", 'String'>
    readonly aminities: FieldRef<"Room", 'String[]'>
    readonly images: FieldRef<"Room", 'String[]'>
    readonly view: FieldRef<"Room", 'String'>
    readonly isDeleted: FieldRef<"Room", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }


  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }


  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }


  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }


  /**
   * Room.extraServices
   */
  export type Room$extraServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    where?: ExtraServicesWhereInput
    orderBy?: ExtraServicesOrderByWithRelationInput | ExtraServicesOrderByWithRelationInput[]
    cursor?: ExtraServicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExtraServicesScalarFieldEnum | ExtraServicesScalarFieldEnum[]
  }


  /**
   * Room.user
   */
  export type Room$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    where?: RoomReservationWhereInput
    orderBy?: RoomReservationOrderByWithRelationInput | RoomReservationOrderByWithRelationInput[]
    cursor?: RoomReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomReservationScalarFieldEnum | RoomReservationScalarFieldEnum[]
  }


  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
  }



  /**
   * Model RoomReservation
   */

  export type AggregateRoomReservation = {
    _count: RoomReservationCountAggregateOutputType | null
    _avg: RoomReservationAvgAggregateOutputType | null
    _sum: RoomReservationSumAggregateOutputType | null
    _min: RoomReservationMinAggregateOutputType | null
    _max: RoomReservationMaxAggregateOutputType | null
  }

  export type RoomReservationAvgAggregateOutputType = {
    adults: number | null
    children: number | null
  }

  export type RoomReservationSumAggregateOutputType = {
    adults: number | null
    children: number | null
  }

  export type RoomReservationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roomId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    checkIn: Date | null
    checkOut: Date | null
    adults: number | null
    children: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type RoomReservationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roomId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    checkIn: Date | null
    checkOut: Date | null
    adults: number | null
    children: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type RoomReservationCountAggregateOutputType = {
    id: number
    userId: number
    roomId: number
    createdAt: number
    updatedAt: number
    checkIn: number
    checkOut: number
    adults: number
    children: number
    isDeleted: number
    deletedAt: number
    _all: number
  }


  export type RoomReservationAvgAggregateInputType = {
    adults?: true
    children?: true
  }

  export type RoomReservationSumAggregateInputType = {
    adults?: true
    children?: true
  }

  export type RoomReservationMinAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
    checkIn?: true
    checkOut?: true
    adults?: true
    children?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type RoomReservationMaxAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
    checkIn?: true
    checkOut?: true
    adults?: true
    children?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type RoomReservationCountAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
    checkIn?: true
    checkOut?: true
    adults?: true
    children?: true
    isDeleted?: true
    deletedAt?: true
    _all?: true
  }

  export type RoomReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomReservation to aggregate.
     */
    where?: RoomReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReservations to fetch.
     */
    orderBy?: RoomReservationOrderByWithRelationInput | RoomReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomReservations
    **/
    _count?: true | RoomReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomReservationMaxAggregateInputType
  }

  export type GetRoomReservationAggregateType<T extends RoomReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomReservation[P]>
      : GetScalarType<T[P], AggregateRoomReservation[P]>
  }




  export type RoomReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomReservationWhereInput
    orderBy?: RoomReservationOrderByWithAggregationInput | RoomReservationOrderByWithAggregationInput[]
    by: RoomReservationScalarFieldEnum[] | RoomReservationScalarFieldEnum
    having?: RoomReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomReservationCountAggregateInputType | true
    _avg?: RoomReservationAvgAggregateInputType
    _sum?: RoomReservationSumAggregateInputType
    _min?: RoomReservationMinAggregateInputType
    _max?: RoomReservationMaxAggregateInputType
  }

  export type RoomReservationGroupByOutputType = {
    id: string
    userId: string
    roomId: string
    createdAt: Date
    updatedAt: Date
    checkIn: Date
    checkOut: Date
    adults: number
    children: number
    isDeleted: boolean
    deletedAt: Date | null
    _count: RoomReservationCountAggregateOutputType | null
    _avg: RoomReservationAvgAggregateOutputType | null
    _sum: RoomReservationSumAggregateOutputType | null
    _min: RoomReservationMinAggregateOutputType | null
    _max: RoomReservationMaxAggregateOutputType | null
  }

  type GetRoomReservationGroupByPayload<T extends RoomReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomReservationGroupByOutputType[P]>
            : GetScalarType<T[P], RoomReservationGroupByOutputType[P]>
        }
      >
    >


  export type RoomReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    checkIn?: boolean
    checkOut?: boolean
    adults?: boolean
    children?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomReservation"]>

  export type RoomReservationSelectScalar = {
    id?: boolean
    userId?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    checkIn?: boolean
    checkOut?: boolean
    adults?: boolean
    children?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
  }

  export type RoomReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }


  export type $RoomReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomReservation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roomId: string
      createdAt: Date
      updatedAt: Date
      checkIn: Date
      checkOut: Date
      adults: number
      children: number
      isDeleted: boolean
      deletedAt: Date | null
    }, ExtArgs["result"]["roomReservation"]>
    composites: {}
  }


  type RoomReservationGetPayload<S extends boolean | null | undefined | RoomReservationDefaultArgs> = $Result.GetResult<Prisma.$RoomReservationPayload, S>

  type RoomReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomReservationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomReservationCountAggregateInputType | true
    }

  export interface RoomReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomReservation'], meta: { name: 'RoomReservation' } }
    /**
     * Find zero or one RoomReservation that matches the filter.
     * @param {RoomReservationFindUniqueArgs} args - Arguments to find a RoomReservation
     * @example
     * // Get one RoomReservation
     * const roomReservation = await prisma.roomReservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomReservationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomReservationFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomReservationClient<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomReservation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomReservationFindUniqueOrThrowArgs} args - Arguments to find a RoomReservation
     * @example
     * // Get one RoomReservation
     * const roomReservation = await prisma.roomReservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomReservationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomReservationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomReservationClient<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomReservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReservationFindFirstArgs} args - Arguments to find a RoomReservation
     * @example
     * // Get one RoomReservation
     * const roomReservation = await prisma.roomReservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomReservationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomReservationFindFirstArgs<ExtArgs>>
    ): Prisma__RoomReservationClient<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomReservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReservationFindFirstOrThrowArgs} args - Arguments to find a RoomReservation
     * @example
     * // Get one RoomReservation
     * const roomReservation = await prisma.roomReservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomReservationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomReservationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomReservationClient<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomReservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReservationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomReservations
     * const roomReservations = await prisma.roomReservation.findMany()
     * 
     * // Get first 10 RoomReservations
     * const roomReservations = await prisma.roomReservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomReservationWithIdOnly = await prisma.roomReservation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomReservationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomReservationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomReservation.
     * @param {RoomReservationCreateArgs} args - Arguments to create a RoomReservation.
     * @example
     * // Create one RoomReservation
     * const RoomReservation = await prisma.roomReservation.create({
     *   data: {
     *     // ... data to create a RoomReservation
     *   }
     * })
     * 
    **/
    create<T extends RoomReservationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomReservationCreateArgs<ExtArgs>>
    ): Prisma__RoomReservationClient<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomReservations.
     *     @param {RoomReservationCreateManyArgs} args - Arguments to create many RoomReservations.
     *     @example
     *     // Create many RoomReservations
     *     const roomReservation = await prisma.roomReservation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomReservationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomReservationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomReservation.
     * @param {RoomReservationDeleteArgs} args - Arguments to delete one RoomReservation.
     * @example
     * // Delete one RoomReservation
     * const RoomReservation = await prisma.roomReservation.delete({
     *   where: {
     *     // ... filter to delete one RoomReservation
     *   }
     * })
     * 
    **/
    delete<T extends RoomReservationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomReservationDeleteArgs<ExtArgs>>
    ): Prisma__RoomReservationClient<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomReservation.
     * @param {RoomReservationUpdateArgs} args - Arguments to update one RoomReservation.
     * @example
     * // Update one RoomReservation
     * const roomReservation = await prisma.roomReservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomReservationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomReservationUpdateArgs<ExtArgs>>
    ): Prisma__RoomReservationClient<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomReservations.
     * @param {RoomReservationDeleteManyArgs} args - Arguments to filter RoomReservations to delete.
     * @example
     * // Delete a few RoomReservations
     * const { count } = await prisma.roomReservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomReservationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomReservationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomReservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomReservations
     * const roomReservation = await prisma.roomReservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomReservationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomReservationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomReservation.
     * @param {RoomReservationUpsertArgs} args - Arguments to update or create a RoomReservation.
     * @example
     * // Update or create a RoomReservation
     * const roomReservation = await prisma.roomReservation.upsert({
     *   create: {
     *     // ... data to create a RoomReservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomReservation we want to update
     *   }
     * })
    **/
    upsert<T extends RoomReservationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomReservationUpsertArgs<ExtArgs>>
    ): Prisma__RoomReservationClient<$Result.GetResult<Prisma.$RoomReservationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomReservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReservationCountArgs} args - Arguments to filter RoomReservations to count.
     * @example
     * // Count the number of RoomReservations
     * const count = await prisma.roomReservation.count({
     *   where: {
     *     // ... the filter for the RoomReservations we want to count
     *   }
     * })
    **/
    count<T extends RoomReservationCountArgs>(
      args?: Subset<T, RoomReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomReservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomReservationAggregateArgs>(args: Subset<T, RoomReservationAggregateArgs>): Prisma.PrismaPromise<GetRoomReservationAggregateType<T>>

    /**
     * Group by RoomReservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomReservationGroupByArgs['orderBy'] }
        : { orderBy?: RoomReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomReservation model
   */
  readonly fields: RoomReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomReservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomReservation model
   */ 
  interface RoomReservationFieldRefs {
    readonly id: FieldRef<"RoomReservation", 'String'>
    readonly userId: FieldRef<"RoomReservation", 'String'>
    readonly roomId: FieldRef<"RoomReservation", 'String'>
    readonly createdAt: FieldRef<"RoomReservation", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomReservation", 'DateTime'>
    readonly checkIn: FieldRef<"RoomReservation", 'DateTime'>
    readonly checkOut: FieldRef<"RoomReservation", 'DateTime'>
    readonly adults: FieldRef<"RoomReservation", 'Int'>
    readonly children: FieldRef<"RoomReservation", 'Int'>
    readonly isDeleted: FieldRef<"RoomReservation", 'Boolean'>
    readonly deletedAt: FieldRef<"RoomReservation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * RoomReservation findUnique
   */
  export type RoomReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    /**
     * Filter, which RoomReservation to fetch.
     */
    where: RoomReservationWhereUniqueInput
  }


  /**
   * RoomReservation findUniqueOrThrow
   */
  export type RoomReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    /**
     * Filter, which RoomReservation to fetch.
     */
    where: RoomReservationWhereUniqueInput
  }


  /**
   * RoomReservation findFirst
   */
  export type RoomReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    /**
     * Filter, which RoomReservation to fetch.
     */
    where?: RoomReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReservations to fetch.
     */
    orderBy?: RoomReservationOrderByWithRelationInput | RoomReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomReservations.
     */
    cursor?: RoomReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomReservations.
     */
    distinct?: RoomReservationScalarFieldEnum | RoomReservationScalarFieldEnum[]
  }


  /**
   * RoomReservation findFirstOrThrow
   */
  export type RoomReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    /**
     * Filter, which RoomReservation to fetch.
     */
    where?: RoomReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReservations to fetch.
     */
    orderBy?: RoomReservationOrderByWithRelationInput | RoomReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomReservations.
     */
    cursor?: RoomReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomReservations.
     */
    distinct?: RoomReservationScalarFieldEnum | RoomReservationScalarFieldEnum[]
  }


  /**
   * RoomReservation findMany
   */
  export type RoomReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    /**
     * Filter, which RoomReservations to fetch.
     */
    where?: RoomReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReservations to fetch.
     */
    orderBy?: RoomReservationOrderByWithRelationInput | RoomReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomReservations.
     */
    cursor?: RoomReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReservations.
     */
    skip?: number
    distinct?: RoomReservationScalarFieldEnum | RoomReservationScalarFieldEnum[]
  }


  /**
   * RoomReservation create
   */
  export type RoomReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomReservation.
     */
    data: XOR<RoomReservationCreateInput, RoomReservationUncheckedCreateInput>
  }


  /**
   * RoomReservation createMany
   */
  export type RoomReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomReservations.
     */
    data: RoomReservationCreateManyInput | RoomReservationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoomReservation update
   */
  export type RoomReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomReservation.
     */
    data: XOR<RoomReservationUpdateInput, RoomReservationUncheckedUpdateInput>
    /**
     * Choose, which RoomReservation to update.
     */
    where: RoomReservationWhereUniqueInput
  }


  /**
   * RoomReservation updateMany
   */
  export type RoomReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomReservations.
     */
    data: XOR<RoomReservationUpdateManyMutationInput, RoomReservationUncheckedUpdateManyInput>
    /**
     * Filter which RoomReservations to update
     */
    where?: RoomReservationWhereInput
  }


  /**
   * RoomReservation upsert
   */
  export type RoomReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomReservation to update in case it exists.
     */
    where: RoomReservationWhereUniqueInput
    /**
     * In case the RoomReservation found by the `where` argument doesn't exist, create a new RoomReservation with this data.
     */
    create: XOR<RoomReservationCreateInput, RoomReservationUncheckedCreateInput>
    /**
     * In case the RoomReservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomReservationUpdateInput, RoomReservationUncheckedUpdateInput>
  }


  /**
   * RoomReservation delete
   */
  export type RoomReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
    /**
     * Filter which RoomReservation to delete.
     */
    where: RoomReservationWhereUniqueInput
  }


  /**
   * RoomReservation deleteMany
   */
  export type RoomReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomReservations to delete
     */
    where?: RoomReservationWhereInput
  }


  /**
   * RoomReservation without action
   */
  export type RoomReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReservation
     */
    select?: RoomReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReservationInclude<ExtArgs> | null
  }



  /**
   * Model ExtraServices
   */

  export type AggregateExtraServices = {
    _count: ExtraServicesCountAggregateOutputType | null
    _min: ExtraServicesMinAggregateOutputType | null
    _max: ExtraServicesMaxAggregateOutputType | null
  }

  export type ExtraServicesMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    price: string | null
    isDeleted: boolean | null
  }

  export type ExtraServicesMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    price: string | null
    isDeleted: boolean | null
  }

  export type ExtraServicesCountAggregateOutputType = {
    id: number
    roomId: number
    createdAt: number
    updatedAt: number
    name: number
    price: number
    facilities: number
    isDeleted: number
    _all: number
  }


  export type ExtraServicesMinAggregateInputType = {
    id?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    price?: true
    isDeleted?: true
  }

  export type ExtraServicesMaxAggregateInputType = {
    id?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    price?: true
    isDeleted?: true
  }

  export type ExtraServicesCountAggregateInputType = {
    id?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    price?: true
    facilities?: true
    isDeleted?: true
    _all?: true
  }

  export type ExtraServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtraServices to aggregate.
     */
    where?: ExtraServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraServices to fetch.
     */
    orderBy?: ExtraServicesOrderByWithRelationInput | ExtraServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExtraServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExtraServices
    **/
    _count?: true | ExtraServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtraServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtraServicesMaxAggregateInputType
  }

  export type GetExtraServicesAggregateType<T extends ExtraServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateExtraServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtraServices[P]>
      : GetScalarType<T[P], AggregateExtraServices[P]>
  }




  export type ExtraServicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtraServicesWhereInput
    orderBy?: ExtraServicesOrderByWithAggregationInput | ExtraServicesOrderByWithAggregationInput[]
    by: ExtraServicesScalarFieldEnum[] | ExtraServicesScalarFieldEnum
    having?: ExtraServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtraServicesCountAggregateInputType | true
    _min?: ExtraServicesMinAggregateInputType
    _max?: ExtraServicesMaxAggregateInputType
  }

  export type ExtraServicesGroupByOutputType = {
    id: string
    roomId: string
    createdAt: Date
    updatedAt: Date
    name: string
    price: string
    facilities: string[]
    isDeleted: boolean
    _count: ExtraServicesCountAggregateOutputType | null
    _min: ExtraServicesMinAggregateOutputType | null
    _max: ExtraServicesMaxAggregateOutputType | null
  }

  type GetExtraServicesGroupByPayload<T extends ExtraServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtraServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtraServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtraServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ExtraServicesGroupByOutputType[P]>
        }
      >
    >


  export type ExtraServicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    price?: boolean
    facilities?: boolean
    isDeleted?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extraServices"]>

  export type ExtraServicesSelectScalar = {
    id?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    price?: boolean
    facilities?: boolean
    isDeleted?: boolean
  }

  export type ExtraServicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }


  export type $ExtraServicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExtraServices"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      createdAt: Date
      updatedAt: Date
      name: string
      price: string
      facilities: string[]
      isDeleted: boolean
    }, ExtArgs["result"]["extraServices"]>
    composites: {}
  }


  type ExtraServicesGetPayload<S extends boolean | null | undefined | ExtraServicesDefaultArgs> = $Result.GetResult<Prisma.$ExtraServicesPayload, S>

  type ExtraServicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExtraServicesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExtraServicesCountAggregateInputType | true
    }

  export interface ExtraServicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExtraServices'], meta: { name: 'ExtraServices' } }
    /**
     * Find zero or one ExtraServices that matches the filter.
     * @param {ExtraServicesFindUniqueArgs} args - Arguments to find a ExtraServices
     * @example
     * // Get one ExtraServices
     * const extraServices = await prisma.extraServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExtraServicesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraServicesFindUniqueArgs<ExtArgs>>
    ): Prisma__ExtraServicesClient<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ExtraServices that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExtraServicesFindUniqueOrThrowArgs} args - Arguments to find a ExtraServices
     * @example
     * // Get one ExtraServices
     * const extraServices = await prisma.extraServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExtraServicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraServicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExtraServicesClient<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ExtraServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraServicesFindFirstArgs} args - Arguments to find a ExtraServices
     * @example
     * // Get one ExtraServices
     * const extraServices = await prisma.extraServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExtraServicesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraServicesFindFirstArgs<ExtArgs>>
    ): Prisma__ExtraServicesClient<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ExtraServices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraServicesFindFirstOrThrowArgs} args - Arguments to find a ExtraServices
     * @example
     * // Get one ExtraServices
     * const extraServices = await prisma.extraServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExtraServicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraServicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExtraServicesClient<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ExtraServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraServicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExtraServices
     * const extraServices = await prisma.extraServices.findMany()
     * 
     * // Get first 10 ExtraServices
     * const extraServices = await prisma.extraServices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extraServicesWithIdOnly = await prisma.extraServices.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExtraServicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraServicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ExtraServices.
     * @param {ExtraServicesCreateArgs} args - Arguments to create a ExtraServices.
     * @example
     * // Create one ExtraServices
     * const ExtraServices = await prisma.extraServices.create({
     *   data: {
     *     // ... data to create a ExtraServices
     *   }
     * })
     * 
    **/
    create<T extends ExtraServicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraServicesCreateArgs<ExtArgs>>
    ): Prisma__ExtraServicesClient<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ExtraServices.
     *     @param {ExtraServicesCreateManyArgs} args - Arguments to create many ExtraServices.
     *     @example
     *     // Create many ExtraServices
     *     const extraServices = await prisma.extraServices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExtraServicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraServicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExtraServices.
     * @param {ExtraServicesDeleteArgs} args - Arguments to delete one ExtraServices.
     * @example
     * // Delete one ExtraServices
     * const ExtraServices = await prisma.extraServices.delete({
     *   where: {
     *     // ... filter to delete one ExtraServices
     *   }
     * })
     * 
    **/
    delete<T extends ExtraServicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraServicesDeleteArgs<ExtArgs>>
    ): Prisma__ExtraServicesClient<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ExtraServices.
     * @param {ExtraServicesUpdateArgs} args - Arguments to update one ExtraServices.
     * @example
     * // Update one ExtraServices
     * const extraServices = await prisma.extraServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExtraServicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraServicesUpdateArgs<ExtArgs>>
    ): Prisma__ExtraServicesClient<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ExtraServices.
     * @param {ExtraServicesDeleteManyArgs} args - Arguments to filter ExtraServices to delete.
     * @example
     * // Delete a few ExtraServices
     * const { count } = await prisma.extraServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExtraServicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraServicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtraServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExtraServices
     * const extraServices = await prisma.extraServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExtraServicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraServicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExtraServices.
     * @param {ExtraServicesUpsertArgs} args - Arguments to update or create a ExtraServices.
     * @example
     * // Update or create a ExtraServices
     * const extraServices = await prisma.extraServices.upsert({
     *   create: {
     *     // ... data to create a ExtraServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExtraServices we want to update
     *   }
     * })
    **/
    upsert<T extends ExtraServicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraServicesUpsertArgs<ExtArgs>>
    ): Prisma__ExtraServicesClient<$Result.GetResult<Prisma.$ExtraServicesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ExtraServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraServicesCountArgs} args - Arguments to filter ExtraServices to count.
     * @example
     * // Count the number of ExtraServices
     * const count = await prisma.extraServices.count({
     *   where: {
     *     // ... the filter for the ExtraServices we want to count
     *   }
     * })
    **/
    count<T extends ExtraServicesCountArgs>(
      args?: Subset<T, ExtraServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtraServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExtraServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtraServicesAggregateArgs>(args: Subset<T, ExtraServicesAggregateArgs>): Prisma.PrismaPromise<GetExtraServicesAggregateType<T>>

    /**
     * Group by ExtraServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExtraServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtraServicesGroupByArgs['orderBy'] }
        : { orderBy?: ExtraServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExtraServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtraServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExtraServices model
   */
  readonly fields: ExtraServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExtraServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExtraServicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ExtraServices model
   */ 
  interface ExtraServicesFieldRefs {
    readonly id: FieldRef<"ExtraServices", 'String'>
    readonly roomId: FieldRef<"ExtraServices", 'String'>
    readonly createdAt: FieldRef<"ExtraServices", 'DateTime'>
    readonly updatedAt: FieldRef<"ExtraServices", 'DateTime'>
    readonly name: FieldRef<"ExtraServices", 'String'>
    readonly price: FieldRef<"ExtraServices", 'String'>
    readonly facilities: FieldRef<"ExtraServices", 'String[]'>
    readonly isDeleted: FieldRef<"ExtraServices", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ExtraServices findUnique
   */
  export type ExtraServicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    /**
     * Filter, which ExtraServices to fetch.
     */
    where: ExtraServicesWhereUniqueInput
  }


  /**
   * ExtraServices findUniqueOrThrow
   */
  export type ExtraServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    /**
     * Filter, which ExtraServices to fetch.
     */
    where: ExtraServicesWhereUniqueInput
  }


  /**
   * ExtraServices findFirst
   */
  export type ExtraServicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    /**
     * Filter, which ExtraServices to fetch.
     */
    where?: ExtraServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraServices to fetch.
     */
    orderBy?: ExtraServicesOrderByWithRelationInput | ExtraServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtraServices.
     */
    cursor?: ExtraServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtraServices.
     */
    distinct?: ExtraServicesScalarFieldEnum | ExtraServicesScalarFieldEnum[]
  }


  /**
   * ExtraServices findFirstOrThrow
   */
  export type ExtraServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    /**
     * Filter, which ExtraServices to fetch.
     */
    where?: ExtraServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraServices to fetch.
     */
    orderBy?: ExtraServicesOrderByWithRelationInput | ExtraServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtraServices.
     */
    cursor?: ExtraServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtraServices.
     */
    distinct?: ExtraServicesScalarFieldEnum | ExtraServicesScalarFieldEnum[]
  }


  /**
   * ExtraServices findMany
   */
  export type ExtraServicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    /**
     * Filter, which ExtraServices to fetch.
     */
    where?: ExtraServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraServices to fetch.
     */
    orderBy?: ExtraServicesOrderByWithRelationInput | ExtraServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExtraServices.
     */
    cursor?: ExtraServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraServices.
     */
    skip?: number
    distinct?: ExtraServicesScalarFieldEnum | ExtraServicesScalarFieldEnum[]
  }


  /**
   * ExtraServices create
   */
  export type ExtraServicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    /**
     * The data needed to create a ExtraServices.
     */
    data: XOR<ExtraServicesCreateInput, ExtraServicesUncheckedCreateInput>
  }


  /**
   * ExtraServices createMany
   */
  export type ExtraServicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExtraServices.
     */
    data: ExtraServicesCreateManyInput | ExtraServicesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ExtraServices update
   */
  export type ExtraServicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    /**
     * The data needed to update a ExtraServices.
     */
    data: XOR<ExtraServicesUpdateInput, ExtraServicesUncheckedUpdateInput>
    /**
     * Choose, which ExtraServices to update.
     */
    where: ExtraServicesWhereUniqueInput
  }


  /**
   * ExtraServices updateMany
   */
  export type ExtraServicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExtraServices.
     */
    data: XOR<ExtraServicesUpdateManyMutationInput, ExtraServicesUncheckedUpdateManyInput>
    /**
     * Filter which ExtraServices to update
     */
    where?: ExtraServicesWhereInput
  }


  /**
   * ExtraServices upsert
   */
  export type ExtraServicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    /**
     * The filter to search for the ExtraServices to update in case it exists.
     */
    where: ExtraServicesWhereUniqueInput
    /**
     * In case the ExtraServices found by the `where` argument doesn't exist, create a new ExtraServices with this data.
     */
    create: XOR<ExtraServicesCreateInput, ExtraServicesUncheckedCreateInput>
    /**
     * In case the ExtraServices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExtraServicesUpdateInput, ExtraServicesUncheckedUpdateInput>
  }


  /**
   * ExtraServices delete
   */
  export type ExtraServicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
    /**
     * Filter which ExtraServices to delete.
     */
    where: ExtraServicesWhereUniqueInput
  }


  /**
   * ExtraServices deleteMany
   */
  export type ExtraServicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtraServices to delete
     */
    where?: ExtraServicesWhereInput
  }


  /**
   * ExtraServices without action
   */
  export type ExtraServicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraServices
     */
    select?: ExtraServicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExtraServicesInclude<ExtArgs> | null
  }



  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rating: number | null
    comment: string | null
    isDeleted: boolean | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rating: number | null
    comment: string | null
    isDeleted: boolean | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    rating: number
    comment: number
    isDeleted: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    rating?: true
    comment?: true
    isDeleted?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    rating?: true
    comment?: true
    isDeleted?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    rating?: true
    comment?: true
    isDeleted?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    rating: number
    comment: string
    isDeleted: boolean
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rating?: boolean
    comment?: boolean
    isDeleted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rating?: boolean
    comment?: boolean
    isDeleted?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
      rating: number
      comment: string
      isDeleted: boolean
    }, ExtArgs["result"]["review"]>
    composites: {}
  }


  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends ReviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reviews.
     *     @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends ReviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
    readonly rating: FieldRef<"Review", 'Float'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly isDeleted: FieldRef<"Review", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }


  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }


  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }


  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }


  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
  }



  /**
   * Model Restaurant
   */

  export type AggregateRestaurant = {
    _count: RestaurantCountAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  export type RestaurantMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
  }

  export type RestaurantMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
  }

  export type RestaurantCountAggregateOutputType = {
    id: number
    adminId: number
    createdAt: number
    updatedAt: number
    description: number
    _all: number
  }


  export type RestaurantMinAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
  }

  export type RestaurantMaxAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
  }

  export type RestaurantCountAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    _all?: true
  }

  export type RestaurantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurant to aggregate.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Restaurants
    **/
    _count?: true | RestaurantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantMaxAggregateInputType
  }

  export type GetRestaurantAggregateType<T extends RestaurantAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurant[P]>
      : GetScalarType<T[P], AggregateRestaurant[P]>
  }




  export type RestaurantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWhereInput
    orderBy?: RestaurantOrderByWithAggregationInput | RestaurantOrderByWithAggregationInput[]
    by: RestaurantScalarFieldEnum[] | RestaurantScalarFieldEnum
    having?: RestaurantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantCountAggregateInputType | true
    _min?: RestaurantMinAggregateInputType
    _max?: RestaurantMaxAggregateInputType
  }

  export type RestaurantGroupByOutputType = {
    id: string
    adminId: string
    createdAt: Date
    updatedAt: Date
    description: string
    _count: RestaurantCountAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  type GetRestaurantGroupByPayload<T extends RestaurantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    user?: boolean | AdminDefaultArgs<ExtArgs>
    menu?: boolean | Restaurant$menuArgs<ExtArgs>
    _count?: boolean | RestaurantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurant"]>

  export type RestaurantSelectScalar = {
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
  }

  export type RestaurantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AdminDefaultArgs<ExtArgs>
    menu?: boolean | Restaurant$menuArgs<ExtArgs>
    _count?: boolean | RestaurantCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RestaurantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Restaurant"
    objects: {
      user: Prisma.$AdminPayload<ExtArgs>
      menu: Prisma.$MenuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      createdAt: Date
      updatedAt: Date
      description: string
    }, ExtArgs["result"]["restaurant"]>
    composites: {}
  }


  type RestaurantGetPayload<S extends boolean | null | undefined | RestaurantDefaultArgs> = $Result.GetResult<Prisma.$RestaurantPayload, S>

  type RestaurantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RestaurantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RestaurantCountAggregateInputType | true
    }

  export interface RestaurantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Restaurant'], meta: { name: 'Restaurant' } }
    /**
     * Find zero or one Restaurant that matches the filter.
     * @param {RestaurantFindUniqueArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RestaurantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RestaurantFindUniqueArgs<ExtArgs>>
    ): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Restaurant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RestaurantFindUniqueOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RestaurantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RestaurantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Restaurant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RestaurantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RestaurantFindFirstArgs<ExtArgs>>
    ): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Restaurant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RestaurantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RestaurantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Restaurants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restaurants
     * const restaurants = await prisma.restaurant.findMany()
     * 
     * // Get first 10 Restaurants
     * const restaurants = await prisma.restaurant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RestaurantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RestaurantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Restaurant.
     * @param {RestaurantCreateArgs} args - Arguments to create a Restaurant.
     * @example
     * // Create one Restaurant
     * const Restaurant = await prisma.restaurant.create({
     *   data: {
     *     // ... data to create a Restaurant
     *   }
     * })
     * 
    **/
    create<T extends RestaurantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RestaurantCreateArgs<ExtArgs>>
    ): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Restaurants.
     *     @param {RestaurantCreateManyArgs} args - Arguments to create many Restaurants.
     *     @example
     *     // Create many Restaurants
     *     const restaurant = await prisma.restaurant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RestaurantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RestaurantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Restaurant.
     * @param {RestaurantDeleteArgs} args - Arguments to delete one Restaurant.
     * @example
     * // Delete one Restaurant
     * const Restaurant = await prisma.restaurant.delete({
     *   where: {
     *     // ... filter to delete one Restaurant
     *   }
     * })
     * 
    **/
    delete<T extends RestaurantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RestaurantDeleteArgs<ExtArgs>>
    ): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Restaurant.
     * @param {RestaurantUpdateArgs} args - Arguments to update one Restaurant.
     * @example
     * // Update one Restaurant
     * const restaurant = await prisma.restaurant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RestaurantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RestaurantUpdateArgs<ExtArgs>>
    ): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Restaurants.
     * @param {RestaurantDeleteManyArgs} args - Arguments to filter Restaurants to delete.
     * @example
     * // Delete a few Restaurants
     * const { count } = await prisma.restaurant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RestaurantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RestaurantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restaurants
     * const restaurant = await prisma.restaurant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RestaurantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RestaurantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Restaurant.
     * @param {RestaurantUpsertArgs} args - Arguments to update or create a Restaurant.
     * @example
     * // Update or create a Restaurant
     * const restaurant = await prisma.restaurant.upsert({
     *   create: {
     *     // ... data to create a Restaurant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restaurant we want to update
     *   }
     * })
    **/
    upsert<T extends RestaurantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RestaurantUpsertArgs<ExtArgs>>
    ): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCountArgs} args - Arguments to filter Restaurants to count.
     * @example
     * // Count the number of Restaurants
     * const count = await prisma.restaurant.count({
     *   where: {
     *     // ... the filter for the Restaurants we want to count
     *   }
     * })
    **/
    count<T extends RestaurantCountArgs>(
      args?: Subset<T, RestaurantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantAggregateArgs>(args: Subset<T, RestaurantAggregateArgs>): Prisma.PrismaPromise<GetRestaurantAggregateType<T>>

    /**
     * Group by Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Restaurant model
   */
  readonly fields: RestaurantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Restaurant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    menu<T extends Restaurant$menuArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$menuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Restaurant model
   */ 
  interface RestaurantFieldRefs {
    readonly id: FieldRef<"Restaurant", 'String'>
    readonly adminId: FieldRef<"Restaurant", 'String'>
    readonly createdAt: FieldRef<"Restaurant", 'DateTime'>
    readonly updatedAt: FieldRef<"Restaurant", 'DateTime'>
    readonly description: FieldRef<"Restaurant", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Restaurant findUnique
   */
  export type RestaurantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
  }


  /**
   * Restaurant findUniqueOrThrow
   */
  export type RestaurantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
  }


  /**
   * Restaurant findFirst
   */
  export type RestaurantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }


  /**
   * Restaurant findFirstOrThrow
   */
  export type RestaurantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }


  /**
   * Restaurant findMany
   */
  export type RestaurantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurants to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }


  /**
   * Restaurant create
   */
  export type RestaurantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to create a Restaurant.
     */
    data: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
  }


  /**
   * Restaurant createMany
   */
  export type RestaurantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Restaurants.
     */
    data: RestaurantCreateManyInput | RestaurantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Restaurant update
   */
  export type RestaurantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to update a Restaurant.
     */
    data: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
    /**
     * Choose, which Restaurant to update.
     */
    where: RestaurantWhereUniqueInput
  }


  /**
   * Restaurant updateMany
   */
  export type RestaurantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Restaurants.
     */
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyInput>
    /**
     * Filter which Restaurants to update
     */
    where?: RestaurantWhereInput
  }


  /**
   * Restaurant upsert
   */
  export type RestaurantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The filter to search for the Restaurant to update in case it exists.
     */
    where: RestaurantWhereUniqueInput
    /**
     * In case the Restaurant found by the `where` argument doesn't exist, create a new Restaurant with this data.
     */
    create: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
    /**
     * In case the Restaurant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
  }


  /**
   * Restaurant delete
   */
  export type RestaurantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter which Restaurant to delete.
     */
    where: RestaurantWhereUniqueInput
  }


  /**
   * Restaurant deleteMany
   */
  export type RestaurantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurants to delete
     */
    where?: RestaurantWhereInput
  }


  /**
   * Restaurant.menu
   */
  export type Restaurant$menuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }


  /**
   * Restaurant without action
   */
  export type RestaurantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RestaurantInclude<ExtArgs> | null
  }



  /**
   * Model Menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuMinAggregateOutputType = {
    id: string | null
    userId: string | null
    restaurantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    menuTypes: $Enums.MenuTypes | null
    name: string | null
    ingredients: string | null
    price: string | null
    image: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    restaurantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    menuTypes: $Enums.MenuTypes | null
    name: string | null
    ingredients: string | null
    price: string | null
    image: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    userId: number
    restaurantId: number
    createdAt: number
    updatedAt: number
    menuTypes: number
    name: number
    ingredients: number
    price: number
    image: number
    isDeleted: number
    deletedAt: number
    _all: number
  }


  export type MenuMinAggregateInputType = {
    id?: true
    userId?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    menuTypes?: true
    name?: true
    ingredients?: true
    price?: true
    image?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    userId?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    menuTypes?: true
    name?: true
    ingredients?: true
    price?: true
    image?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    userId?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    menuTypes?: true
    name?: true
    ingredients?: true
    price?: true
    image?: true
    isDeleted?: true
    deletedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithAggregationInput | MenuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: string
    userId: string
    restaurantId: string
    createdAt: Date
    updatedAt: Date
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted: boolean
    deletedAt: Date | null
    _count: MenuCountAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menuTypes?: boolean
    name?: boolean
    ingredients?: boolean
    price?: boolean
    image?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectScalar = {
    id?: boolean
    userId?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menuTypes?: boolean
    name?: boolean
    ingredients?: boolean
    price?: boolean
    image?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
  }

  export type MenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }


  export type $MenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Menu"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      restaurantId: string
      createdAt: Date
      updatedAt: Date
      menuTypes: $Enums.MenuTypes
      name: string
      ingredients: string
      price: string
      image: string
      isDeleted: boolean
      deletedAt: Date | null
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }


  type MenuGetPayload<S extends boolean | null | undefined | MenuDefaultArgs> = $Result.GetResult<Prisma.$MenuPayload, S>

  type MenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MenuFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Menu'], meta: { name: 'Menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MenuFindUniqueArgs<ExtArgs>>
    ): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Menu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MenuFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MenuFindFirstArgs<ExtArgs>>
    ): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MenuFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MenuFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MenuFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
    **/
    create<T extends MenuCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MenuCreateArgs<ExtArgs>>
    ): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Menus.
     *     @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     *     @example
     *     // Create many Menus
     *     const menu = await prisma.menu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MenuCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
    **/
    delete<T extends MenuDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MenuDeleteArgs<ExtArgs>>
    ): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MenuUpdateArgs<ExtArgs>>
    ): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MenuDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MenuUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
    **/
    upsert<T extends MenuUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MenuUpsertArgs<ExtArgs>>
    ): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Menu model
   */
  readonly fields: MenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Menu model
   */ 
  interface MenuFieldRefs {
    readonly id: FieldRef<"Menu", 'String'>
    readonly userId: FieldRef<"Menu", 'String'>
    readonly restaurantId: FieldRef<"Menu", 'String'>
    readonly createdAt: FieldRef<"Menu", 'DateTime'>
    readonly updatedAt: FieldRef<"Menu", 'DateTime'>
    readonly menuTypes: FieldRef<"Menu", 'MenuTypes'>
    readonly name: FieldRef<"Menu", 'String'>
    readonly ingredients: FieldRef<"Menu", 'String'>
    readonly price: FieldRef<"Menu", 'String'>
    readonly image: FieldRef<"Menu", 'String'>
    readonly isDeleted: FieldRef<"Menu", 'Boolean'>
    readonly deletedAt: FieldRef<"Menu", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }


  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }


  /**
   * Menu findMany
   */
  export type MenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }


  /**
   * Menu create
   */
  export type MenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }


  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Menu update
   */
  export type MenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
  }


  /**
   * Menu upsert
   */
  export type MenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }


  /**
   * Menu delete
   */
  export type MenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
  }


  /**
   * Menu without action
   */
  export type MenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude<ExtArgs> | null
  }



  /**
   * Model ClubHouse
   */

  export type AggregateClubHouse = {
    _count: ClubHouseCountAggregateOutputType | null
    _min: ClubHouseMinAggregateOutputType | null
    _max: ClubHouseMaxAggregateOutputType | null
  }

  export type ClubHouseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clubhouseTypes: $Enums.clubhouseTypes | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    isDeleted: boolean | null
  }

  export type ClubHouseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clubhouseTypes: $Enums.clubhouseTypes | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    isDeleted: boolean | null
  }

  export type ClubHouseCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    clubhouseTypes: number
    description: number
    startTime: number
    endTime: number
    isDeleted: number
    _all: number
  }


  export type ClubHouseMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    clubhouseTypes?: true
    description?: true
    startTime?: true
    endTime?: true
    isDeleted?: true
  }

  export type ClubHouseMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    clubhouseTypes?: true
    description?: true
    startTime?: true
    endTime?: true
    isDeleted?: true
  }

  export type ClubHouseCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    clubhouseTypes?: true
    description?: true
    startTime?: true
    endTime?: true
    isDeleted?: true
    _all?: true
  }

  export type ClubHouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubHouse to aggregate.
     */
    where?: ClubHouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubHouses to fetch.
     */
    orderBy?: ClubHouseOrderByWithRelationInput | ClubHouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubHouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubHouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubHouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClubHouses
    **/
    _count?: true | ClubHouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubHouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubHouseMaxAggregateInputType
  }

  export type GetClubHouseAggregateType<T extends ClubHouseAggregateArgs> = {
        [P in keyof T & keyof AggregateClubHouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClubHouse[P]>
      : GetScalarType<T[P], AggregateClubHouse[P]>
  }




  export type ClubHouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubHouseWhereInput
    orderBy?: ClubHouseOrderByWithAggregationInput | ClubHouseOrderByWithAggregationInput[]
    by: ClubHouseScalarFieldEnum[] | ClubHouseScalarFieldEnum
    having?: ClubHouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubHouseCountAggregateInputType | true
    _min?: ClubHouseMinAggregateInputType
    _max?: ClubHouseMaxAggregateInputType
  }

  export type ClubHouseGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    clubhouseTypes: $Enums.clubhouseTypes
    description: string
    startTime: Date
    endTime: Date
    isDeleted: boolean
    _count: ClubHouseCountAggregateOutputType | null
    _min: ClubHouseMinAggregateOutputType | null
    _max: ClubHouseMaxAggregateOutputType | null
  }

  type GetClubHouseGroupByPayload<T extends ClubHouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubHouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubHouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubHouseGroupByOutputType[P]>
            : GetScalarType<T[P], ClubHouseGroupByOutputType[P]>
        }
      >
    >


  export type ClubHouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clubhouseTypes?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    isDeleted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubHouse"]>

  export type ClubHouseSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clubhouseTypes?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    isDeleted?: boolean
  }

  export type ClubHouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ClubHousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClubHouse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
      clubhouseTypes: $Enums.clubhouseTypes
      description: string
      startTime: Date
      endTime: Date
      isDeleted: boolean
    }, ExtArgs["result"]["clubHouse"]>
    composites: {}
  }


  type ClubHouseGetPayload<S extends boolean | null | undefined | ClubHouseDefaultArgs> = $Result.GetResult<Prisma.$ClubHousePayload, S>

  type ClubHouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClubHouseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClubHouseCountAggregateInputType | true
    }

  export interface ClubHouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClubHouse'], meta: { name: 'ClubHouse' } }
    /**
     * Find zero or one ClubHouse that matches the filter.
     * @param {ClubHouseFindUniqueArgs} args - Arguments to find a ClubHouse
     * @example
     * // Get one ClubHouse
     * const clubHouse = await prisma.clubHouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClubHouseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClubHouseFindUniqueArgs<ExtArgs>>
    ): Prisma__ClubHouseClient<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClubHouse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClubHouseFindUniqueOrThrowArgs} args - Arguments to find a ClubHouse
     * @example
     * // Get one ClubHouse
     * const clubHouse = await prisma.clubHouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClubHouseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClubHouseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClubHouseClient<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClubHouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubHouseFindFirstArgs} args - Arguments to find a ClubHouse
     * @example
     * // Get one ClubHouse
     * const clubHouse = await prisma.clubHouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClubHouseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClubHouseFindFirstArgs<ExtArgs>>
    ): Prisma__ClubHouseClient<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClubHouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubHouseFindFirstOrThrowArgs} args - Arguments to find a ClubHouse
     * @example
     * // Get one ClubHouse
     * const clubHouse = await prisma.clubHouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClubHouseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClubHouseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClubHouseClient<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClubHouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubHouseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClubHouses
     * const clubHouses = await prisma.clubHouse.findMany()
     * 
     * // Get first 10 ClubHouses
     * const clubHouses = await prisma.clubHouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubHouseWithIdOnly = await prisma.clubHouse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClubHouseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClubHouseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClubHouse.
     * @param {ClubHouseCreateArgs} args - Arguments to create a ClubHouse.
     * @example
     * // Create one ClubHouse
     * const ClubHouse = await prisma.clubHouse.create({
     *   data: {
     *     // ... data to create a ClubHouse
     *   }
     * })
     * 
    **/
    create<T extends ClubHouseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClubHouseCreateArgs<ExtArgs>>
    ): Prisma__ClubHouseClient<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClubHouses.
     *     @param {ClubHouseCreateManyArgs} args - Arguments to create many ClubHouses.
     *     @example
     *     // Create many ClubHouses
     *     const clubHouse = await prisma.clubHouse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClubHouseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClubHouseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClubHouse.
     * @param {ClubHouseDeleteArgs} args - Arguments to delete one ClubHouse.
     * @example
     * // Delete one ClubHouse
     * const ClubHouse = await prisma.clubHouse.delete({
     *   where: {
     *     // ... filter to delete one ClubHouse
     *   }
     * })
     * 
    **/
    delete<T extends ClubHouseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClubHouseDeleteArgs<ExtArgs>>
    ): Prisma__ClubHouseClient<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClubHouse.
     * @param {ClubHouseUpdateArgs} args - Arguments to update one ClubHouse.
     * @example
     * // Update one ClubHouse
     * const clubHouse = await prisma.clubHouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClubHouseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClubHouseUpdateArgs<ExtArgs>>
    ): Prisma__ClubHouseClient<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClubHouses.
     * @param {ClubHouseDeleteManyArgs} args - Arguments to filter ClubHouses to delete.
     * @example
     * // Delete a few ClubHouses
     * const { count } = await prisma.clubHouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClubHouseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClubHouseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubHouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubHouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClubHouses
     * const clubHouse = await prisma.clubHouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClubHouseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClubHouseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClubHouse.
     * @param {ClubHouseUpsertArgs} args - Arguments to update or create a ClubHouse.
     * @example
     * // Update or create a ClubHouse
     * const clubHouse = await prisma.clubHouse.upsert({
     *   create: {
     *     // ... data to create a ClubHouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClubHouse we want to update
     *   }
     * })
    **/
    upsert<T extends ClubHouseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClubHouseUpsertArgs<ExtArgs>>
    ): Prisma__ClubHouseClient<$Result.GetResult<Prisma.$ClubHousePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClubHouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubHouseCountArgs} args - Arguments to filter ClubHouses to count.
     * @example
     * // Count the number of ClubHouses
     * const count = await prisma.clubHouse.count({
     *   where: {
     *     // ... the filter for the ClubHouses we want to count
     *   }
     * })
    **/
    count<T extends ClubHouseCountArgs>(
      args?: Subset<T, ClubHouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubHouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClubHouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubHouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubHouseAggregateArgs>(args: Subset<T, ClubHouseAggregateArgs>): Prisma.PrismaPromise<GetClubHouseAggregateType<T>>

    /**
     * Group by ClubHouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubHouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubHouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubHouseGroupByArgs['orderBy'] }
        : { orderBy?: ClubHouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubHouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubHouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClubHouse model
   */
  readonly fields: ClubHouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClubHouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubHouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClubHouse model
   */ 
  interface ClubHouseFieldRefs {
    readonly id: FieldRef<"ClubHouse", 'String'>
    readonly userId: FieldRef<"ClubHouse", 'String'>
    readonly createdAt: FieldRef<"ClubHouse", 'DateTime'>
    readonly updatedAt: FieldRef<"ClubHouse", 'DateTime'>
    readonly clubhouseTypes: FieldRef<"ClubHouse", 'clubhouseTypes'>
    readonly description: FieldRef<"ClubHouse", 'String'>
    readonly startTime: FieldRef<"ClubHouse", 'DateTime'>
    readonly endTime: FieldRef<"ClubHouse", 'DateTime'>
    readonly isDeleted: FieldRef<"ClubHouse", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ClubHouse findUnique
   */
  export type ClubHouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    /**
     * Filter, which ClubHouse to fetch.
     */
    where: ClubHouseWhereUniqueInput
  }


  /**
   * ClubHouse findUniqueOrThrow
   */
  export type ClubHouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    /**
     * Filter, which ClubHouse to fetch.
     */
    where: ClubHouseWhereUniqueInput
  }


  /**
   * ClubHouse findFirst
   */
  export type ClubHouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    /**
     * Filter, which ClubHouse to fetch.
     */
    where?: ClubHouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubHouses to fetch.
     */
    orderBy?: ClubHouseOrderByWithRelationInput | ClubHouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubHouses.
     */
    cursor?: ClubHouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubHouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubHouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubHouses.
     */
    distinct?: ClubHouseScalarFieldEnum | ClubHouseScalarFieldEnum[]
  }


  /**
   * ClubHouse findFirstOrThrow
   */
  export type ClubHouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    /**
     * Filter, which ClubHouse to fetch.
     */
    where?: ClubHouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubHouses to fetch.
     */
    orderBy?: ClubHouseOrderByWithRelationInput | ClubHouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubHouses.
     */
    cursor?: ClubHouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubHouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubHouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubHouses.
     */
    distinct?: ClubHouseScalarFieldEnum | ClubHouseScalarFieldEnum[]
  }


  /**
   * ClubHouse findMany
   */
  export type ClubHouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    /**
     * Filter, which ClubHouses to fetch.
     */
    where?: ClubHouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubHouses to fetch.
     */
    orderBy?: ClubHouseOrderByWithRelationInput | ClubHouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClubHouses.
     */
    cursor?: ClubHouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubHouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubHouses.
     */
    skip?: number
    distinct?: ClubHouseScalarFieldEnum | ClubHouseScalarFieldEnum[]
  }


  /**
   * ClubHouse create
   */
  export type ClubHouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    /**
     * The data needed to create a ClubHouse.
     */
    data: XOR<ClubHouseCreateInput, ClubHouseUncheckedCreateInput>
  }


  /**
   * ClubHouse createMany
   */
  export type ClubHouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClubHouses.
     */
    data: ClubHouseCreateManyInput | ClubHouseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ClubHouse update
   */
  export type ClubHouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    /**
     * The data needed to update a ClubHouse.
     */
    data: XOR<ClubHouseUpdateInput, ClubHouseUncheckedUpdateInput>
    /**
     * Choose, which ClubHouse to update.
     */
    where: ClubHouseWhereUniqueInput
  }


  /**
   * ClubHouse updateMany
   */
  export type ClubHouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClubHouses.
     */
    data: XOR<ClubHouseUpdateManyMutationInput, ClubHouseUncheckedUpdateManyInput>
    /**
     * Filter which ClubHouses to update
     */
    where?: ClubHouseWhereInput
  }


  /**
   * ClubHouse upsert
   */
  export type ClubHouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    /**
     * The filter to search for the ClubHouse to update in case it exists.
     */
    where: ClubHouseWhereUniqueInput
    /**
     * In case the ClubHouse found by the `where` argument doesn't exist, create a new ClubHouse with this data.
     */
    create: XOR<ClubHouseCreateInput, ClubHouseUncheckedCreateInput>
    /**
     * In case the ClubHouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubHouseUpdateInput, ClubHouseUncheckedUpdateInput>
  }


  /**
   * ClubHouse delete
   */
  export type ClubHouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
    /**
     * Filter which ClubHouse to delete.
     */
    where: ClubHouseWhereUniqueInput
  }


  /**
   * ClubHouse deleteMany
   */
  export type ClubHouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubHouses to delete
     */
    where?: ClubHouseWhereInput
  }


  /**
   * ClubHouse without action
   */
  export type ClubHouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubHouse
     */
    select?: ClubHouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClubHouseInclude<ExtArgs> | null
  }



  /**
   * Model FAQS
   */

  export type AggregateFAQS = {
    _count: FAQSCountAggregateOutputType | null
    _min: FAQSMinAggregateOutputType | null
    _max: FAQSMaxAggregateOutputType | null
  }

  export type FAQSMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    question: string | null
    answer: string | null
    isDeleted: boolean | null
  }

  export type FAQSMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    question: string | null
    answer: string | null
    isDeleted: boolean | null
  }

  export type FAQSCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    question: number
    answer: number
    isDeleted: number
    _all: number
  }


  export type FAQSMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    question?: true
    answer?: true
    isDeleted?: true
  }

  export type FAQSMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    question?: true
    answer?: true
    isDeleted?: true
  }

  export type FAQSCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    question?: true
    answer?: true
    isDeleted?: true
    _all?: true
  }

  export type FAQSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to aggregate.
     */
    where?: FAQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQSOrderByWithRelationInput | FAQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQS
    **/
    _count?: true | FAQSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQSMaxAggregateInputType
  }

  export type GetFAQSAggregateType<T extends FAQSAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQS[P]>
      : GetScalarType<T[P], AggregateFAQS[P]>
  }




  export type FAQSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQSWhereInput
    orderBy?: FAQSOrderByWithAggregationInput | FAQSOrderByWithAggregationInput[]
    by: FAQSScalarFieldEnum[] | FAQSScalarFieldEnum
    having?: FAQSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQSCountAggregateInputType | true
    _min?: FAQSMinAggregateInputType
    _max?: FAQSMaxAggregateInputType
  }

  export type FAQSGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    question: string
    answer: string
    isDeleted: boolean
    _count: FAQSCountAggregateOutputType | null
    _min: FAQSMinAggregateOutputType | null
    _max: FAQSMaxAggregateOutputType | null
  }

  type GetFAQSGroupByPayload<T extends FAQSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQSGroupByOutputType[P]>
            : GetScalarType<T[P], FAQSGroupByOutputType[P]>
        }
      >
    >


  export type FAQSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean
    answer?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["fAQS"]>

  export type FAQSSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean
    answer?: boolean
    isDeleted?: boolean
  }


  export type $FAQSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQS"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      question: string
      answer: string
      isDeleted: boolean
    }, ExtArgs["result"]["fAQS"]>
    composites: {}
  }


  type FAQSGetPayload<S extends boolean | null | undefined | FAQSDefaultArgs> = $Result.GetResult<Prisma.$FAQSPayload, S>

  type FAQSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FAQSFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FAQSCountAggregateInputType | true
    }

  export interface FAQSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQS'], meta: { name: 'FAQS' } }
    /**
     * Find zero or one FAQS that matches the filter.
     * @param {FAQSFindUniqueArgs} args - Arguments to find a FAQS
     * @example
     * // Get one FAQS
     * const fAQS = await prisma.fAQS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FAQSFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FAQSFindUniqueArgs<ExtArgs>>
    ): Prisma__FAQSClient<$Result.GetResult<Prisma.$FAQSPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FAQS that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FAQSFindUniqueOrThrowArgs} args - Arguments to find a FAQS
     * @example
     * // Get one FAQS
     * const fAQS = await prisma.fAQS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FAQSFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQSFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FAQSClient<$Result.GetResult<Prisma.$FAQSPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQSFindFirstArgs} args - Arguments to find a FAQS
     * @example
     * // Get one FAQS
     * const fAQS = await prisma.fAQS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FAQSFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQSFindFirstArgs<ExtArgs>>
    ): Prisma__FAQSClient<$Result.GetResult<Prisma.$FAQSPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FAQS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQSFindFirstOrThrowArgs} args - Arguments to find a FAQS
     * @example
     * // Get one FAQS
     * const fAQS = await prisma.fAQS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FAQSFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQSFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FAQSClient<$Result.GetResult<Prisma.$FAQSPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQSFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQS.findMany()
     * 
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQSWithIdOnly = await prisma.fAQS.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FAQSFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQSFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQSPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FAQS.
     * @param {FAQSCreateArgs} args - Arguments to create a FAQS.
     * @example
     * // Create one FAQS
     * const FAQS = await prisma.fAQS.create({
     *   data: {
     *     // ... data to create a FAQS
     *   }
     * })
     * 
    **/
    create<T extends FAQSCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FAQSCreateArgs<ExtArgs>>
    ): Prisma__FAQSClient<$Result.GetResult<Prisma.$FAQSPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FAQS.
     *     @param {FAQSCreateManyArgs} args - Arguments to create many FAQS.
     *     @example
     *     // Create many FAQS
     *     const fAQS = await prisma.fAQS.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FAQSCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQSCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FAQS.
     * @param {FAQSDeleteArgs} args - Arguments to delete one FAQS.
     * @example
     * // Delete one FAQS
     * const FAQS = await prisma.fAQS.delete({
     *   where: {
     *     // ... filter to delete one FAQS
     *   }
     * })
     * 
    **/
    delete<T extends FAQSDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FAQSDeleteArgs<ExtArgs>>
    ): Prisma__FAQSClient<$Result.GetResult<Prisma.$FAQSPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FAQS.
     * @param {FAQSUpdateArgs} args - Arguments to update one FAQS.
     * @example
     * // Update one FAQS
     * const fAQS = await prisma.fAQS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FAQSUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FAQSUpdateArgs<ExtArgs>>
    ): Prisma__FAQSClient<$Result.GetResult<Prisma.$FAQSPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FAQS.
     * @param {FAQSDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FAQSDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQSDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQS = await prisma.fAQS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FAQSUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FAQSUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FAQS.
     * @param {FAQSUpsertArgs} args - Arguments to update or create a FAQS.
     * @example
     * // Update or create a FAQS
     * const fAQS = await prisma.fAQS.upsert({
     *   create: {
     *     // ... data to create a FAQS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQS we want to update
     *   }
     * })
    **/
    upsert<T extends FAQSUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FAQSUpsertArgs<ExtArgs>>
    ): Prisma__FAQSClient<$Result.GetResult<Prisma.$FAQSPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQSCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQS.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
    **/
    count<T extends FAQSCountArgs>(
      args?: Subset<T, FAQSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQSAggregateArgs>(args: Subset<T, FAQSAggregateArgs>): Prisma.PrismaPromise<GetFAQSAggregateType<T>>

    /**
     * Group by FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQSGroupByArgs['orderBy'] }
        : { orderBy?: FAQSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQS model
   */
  readonly fields: FAQSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FAQS model
   */ 
  interface FAQSFieldRefs {
    readonly id: FieldRef<"FAQS", 'String'>
    readonly createdAt: FieldRef<"FAQS", 'DateTime'>
    readonly updatedAt: FieldRef<"FAQS", 'DateTime'>
    readonly question: FieldRef<"FAQS", 'String'>
    readonly answer: FieldRef<"FAQS", 'String'>
    readonly isDeleted: FieldRef<"FAQS", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * FAQS findUnique
   */
  export type FAQSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where: FAQSWhereUniqueInput
  }


  /**
   * FAQS findUniqueOrThrow
   */
  export type FAQSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where: FAQSWhereUniqueInput
  }


  /**
   * FAQS findFirst
   */
  export type FAQSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQSOrderByWithRelationInput | FAQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQSScalarFieldEnum | FAQSScalarFieldEnum[]
  }


  /**
   * FAQS findFirstOrThrow
   */
  export type FAQSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQSOrderByWithRelationInput | FAQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQSScalarFieldEnum | FAQSScalarFieldEnum[]
  }


  /**
   * FAQS findMany
   */
  export type FAQSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQSOrderByWithRelationInput | FAQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQS.
     */
    cursor?: FAQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    distinct?: FAQSScalarFieldEnum | FAQSScalarFieldEnum[]
  }


  /**
   * FAQS create
   */
  export type FAQSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
    /**
     * The data needed to create a FAQS.
     */
    data: XOR<FAQSCreateInput, FAQSUncheckedCreateInput>
  }


  /**
   * FAQS createMany
   */
  export type FAQSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQSCreateManyInput | FAQSCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FAQS update
   */
  export type FAQSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
    /**
     * The data needed to update a FAQS.
     */
    data: XOR<FAQSUpdateInput, FAQSUncheckedUpdateInput>
    /**
     * Choose, which FAQS to update.
     */
    where: FAQSWhereUniqueInput
  }


  /**
   * FAQS updateMany
   */
  export type FAQSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQSUpdateManyMutationInput, FAQSUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQSWhereInput
  }


  /**
   * FAQS upsert
   */
  export type FAQSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
    /**
     * The filter to search for the FAQS to update in case it exists.
     */
    where: FAQSWhereUniqueInput
    /**
     * In case the FAQS found by the `where` argument doesn't exist, create a new FAQS with this data.
     */
    create: XOR<FAQSCreateInput, FAQSUncheckedCreateInput>
    /**
     * In case the FAQS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQSUpdateInput, FAQSUncheckedUpdateInput>
  }


  /**
   * FAQS delete
   */
  export type FAQSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
    /**
     * Filter which FAQS to delete.
     */
    where: FAQSWhereUniqueInput
  }


  /**
   * FAQS deleteMany
   */
  export type FAQSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQSWhereInput
  }


  /**
   * FAQS without action
   */
  export type FAQSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQS
     */
    select?: FAQSSelect<ExtArgs> | null
  }



  /**
   * Model News
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    subTitle: string | null
    description: string | null
    isDeleted: boolean | null
  }

  export type NewsMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    subTitle: string | null
    description: string | null
    isDeleted: boolean | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    adminId: number
    createdAt: number
    updatedAt: number
    title: number
    subTitle: number
    description: number
    images: number
    isDeleted: number
    _all: number
  }


  export type NewsMinAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    subTitle?: true
    description?: true
    isDeleted?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    subTitle?: true
    description?: true
    isDeleted?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    subTitle?: true
    description?: true
    images?: true
    isDeleted?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to aggregate.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithAggregationInput | NewsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    id: string
    adminId: string
    createdAt: Date
    updatedAt: Date
    title: string
    subTitle: string
    description: string
    images: string[]
    isDeleted: boolean
    _count: NewsCountAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    subTitle?: boolean
    description?: boolean
    images?: boolean
    isDeleted?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    replies?: boolean | News$repliesArgs<ExtArgs>
    _count?: boolean | NewsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectScalar = {
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    subTitle?: boolean
    description?: boolean
    images?: boolean
    isDeleted?: boolean
  }

  export type NewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    replies?: boolean | News$repliesArgs<ExtArgs>
    _count?: boolean | NewsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $NewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "News"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      replies: Prisma.$ReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      createdAt: Date
      updatedAt: Date
      title: string
      subTitle: string
      description: string
      images: string[]
      isDeleted: boolean
    }, ExtArgs["result"]["news"]>
    composites: {}
  }


  type NewsGetPayload<S extends boolean | null | undefined | NewsDefaultArgs> = $Result.GetResult<Prisma.$NewsPayload, S>

  type NewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface NewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['News'], meta: { name: 'News' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NewsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NewsFindUniqueArgs<ExtArgs>>
    ): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one News that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NewsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NewsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NewsFindFirstArgs<ExtArgs>>
    ): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NewsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NewsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NewsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
    **/
    create<T extends NewsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NewsCreateArgs<ExtArgs>>
    ): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many News.
     *     @param {NewsCreateManyArgs} args - Arguments to create many News.
     *     @example
     *     // Create many News
     *     const news = await prisma.news.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NewsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NewsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
    **/
    delete<T extends NewsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NewsDeleteArgs<ExtArgs>>
    ): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NewsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NewsUpdateArgs<ExtArgs>>
    ): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NewsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NewsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NewsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NewsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
    **/
    upsert<T extends NewsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NewsUpsertArgs<ExtArgs>>
    ): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the News model
   */
  readonly fields: NewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    replies<T extends News$repliesArgs<ExtArgs> = {}>(args?: Subset<T, News$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the News model
   */ 
  interface NewsFieldRefs {
    readonly id: FieldRef<"News", 'String'>
    readonly adminId: FieldRef<"News", 'String'>
    readonly createdAt: FieldRef<"News", 'DateTime'>
    readonly updatedAt: FieldRef<"News", 'DateTime'>
    readonly title: FieldRef<"News", 'String'>
    readonly subTitle: FieldRef<"News", 'String'>
    readonly description: FieldRef<"News", 'String'>
    readonly images: FieldRef<"News", 'String[]'>
    readonly isDeleted: FieldRef<"News", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }


  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }


  /**
   * News findFirst
   */
  export type NewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }


  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }


  /**
   * News findMany
   */
  export type NewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }


  /**
   * News create
   */
  export type NewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to create a News.
     */
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }


  /**
   * News createMany
   */
  export type NewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * News update
   */
  export type NewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to update a News.
     */
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     */
    where: NewsWhereUniqueInput
  }


  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
  }


  /**
   * News upsert
   */
  export type NewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The filter to search for the News to update in case it exists.
     */
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     */
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }


  /**
   * News delete
   */
  export type NewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter which News to delete.
     */
    where: NewsWhereUniqueInput
  }


  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to delete
     */
    where?: NewsWhereInput
  }


  /**
   * News.replies
   */
  export type News$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    where?: ReplyWhereInput
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    cursor?: ReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }


  /**
   * News without action
   */
  export type NewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NewsInclude<ExtArgs> | null
  }



  /**
   * Model Reply
   */

  export type AggregateReply = {
    _count: ReplyCountAggregateOutputType | null
    _min: ReplyMinAggregateOutputType | null
    _max: ReplyMaxAggregateOutputType | null
  }

  export type ReplyMinAggregateOutputType = {
    id: string | null
    newsId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fullName: string | null
    email: string | null
    comment: string | null
    isDeleted: boolean | null
  }

  export type ReplyMaxAggregateOutputType = {
    id: string | null
    newsId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fullName: string | null
    email: string | null
    comment: string | null
    isDeleted: boolean | null
  }

  export type ReplyCountAggregateOutputType = {
    id: number
    newsId: number
    createdAt: number
    updatedAt: number
    fullName: number
    email: number
    comment: number
    isDeleted: number
    _all: number
  }


  export type ReplyMinAggregateInputType = {
    id?: true
    newsId?: true
    createdAt?: true
    updatedAt?: true
    fullName?: true
    email?: true
    comment?: true
    isDeleted?: true
  }

  export type ReplyMaxAggregateInputType = {
    id?: true
    newsId?: true
    createdAt?: true
    updatedAt?: true
    fullName?: true
    email?: true
    comment?: true
    isDeleted?: true
  }

  export type ReplyCountAggregateInputType = {
    id?: true
    newsId?: true
    createdAt?: true
    updatedAt?: true
    fullName?: true
    email?: true
    comment?: true
    isDeleted?: true
    _all?: true
  }

  export type ReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reply to aggregate.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Replies
    **/
    _count?: true | ReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReplyMaxAggregateInputType
  }

  export type GetReplyAggregateType<T extends ReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReply[P]>
      : GetScalarType<T[P], AggregateReply[P]>
  }




  export type ReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyWhereInput
    orderBy?: ReplyOrderByWithAggregationInput | ReplyOrderByWithAggregationInput[]
    by: ReplyScalarFieldEnum[] | ReplyScalarFieldEnum
    having?: ReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReplyCountAggregateInputType | true
    _min?: ReplyMinAggregateInputType
    _max?: ReplyMaxAggregateInputType
  }

  export type ReplyGroupByOutputType = {
    id: string
    newsId: string
    createdAt: Date
    updatedAt: Date
    fullName: string
    email: string
    comment: string
    isDeleted: boolean
    _count: ReplyCountAggregateOutputType | null
    _min: ReplyMinAggregateOutputType | null
    _max: ReplyMaxAggregateOutputType | null
  }

  type GetReplyGroupByPayload<T extends ReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReplyGroupByOutputType[P]>
            : GetScalarType<T[P], ReplyGroupByOutputType[P]>
        }
      >
    >


  export type ReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    newsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fullName?: boolean
    email?: boolean
    comment?: boolean
    isDeleted?: boolean
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reply"]>

  export type ReplySelectScalar = {
    id?: boolean
    newsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fullName?: boolean
    email?: boolean
    comment?: boolean
    isDeleted?: boolean
  }

  export type ReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }


  export type $ReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reply"
    objects: {
      news: Prisma.$NewsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      newsId: string
      createdAt: Date
      updatedAt: Date
      fullName: string
      email: string
      comment: string
      isDeleted: boolean
    }, ExtArgs["result"]["reply"]>
    composites: {}
  }


  type ReplyGetPayload<S extends boolean | null | undefined | ReplyDefaultArgs> = $Result.GetResult<Prisma.$ReplyPayload, S>

  type ReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReplyCountAggregateInputType | true
    }

  export interface ReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reply'], meta: { name: 'Reply' } }
    /**
     * Find zero or one Reply that matches the filter.
     * @param {ReplyFindUniqueArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReplyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReplyFindUniqueArgs<ExtArgs>>
    ): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Reply that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReplyFindUniqueOrThrowArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReplyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReplyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Reply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindFirstArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReplyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReplyFindFirstArgs<ExtArgs>>
    ): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Reply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindFirstOrThrowArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReplyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReplyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Replies
     * const replies = await prisma.reply.findMany()
     * 
     * // Get first 10 Replies
     * const replies = await prisma.reply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const replyWithIdOnly = await prisma.reply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReplyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReplyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Reply.
     * @param {ReplyCreateArgs} args - Arguments to create a Reply.
     * @example
     * // Create one Reply
     * const Reply = await prisma.reply.create({
     *   data: {
     *     // ... data to create a Reply
     *   }
     * })
     * 
    **/
    create<T extends ReplyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReplyCreateArgs<ExtArgs>>
    ): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Replies.
     *     @param {ReplyCreateManyArgs} args - Arguments to create many Replies.
     *     @example
     *     // Create many Replies
     *     const reply = await prisma.reply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReplyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReplyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reply.
     * @param {ReplyDeleteArgs} args - Arguments to delete one Reply.
     * @example
     * // Delete one Reply
     * const Reply = await prisma.reply.delete({
     *   where: {
     *     // ... filter to delete one Reply
     *   }
     * })
     * 
    **/
    delete<T extends ReplyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReplyDeleteArgs<ExtArgs>>
    ): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Reply.
     * @param {ReplyUpdateArgs} args - Arguments to update one Reply.
     * @example
     * // Update one Reply
     * const reply = await prisma.reply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReplyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReplyUpdateArgs<ExtArgs>>
    ): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Replies.
     * @param {ReplyDeleteManyArgs} args - Arguments to filter Replies to delete.
     * @example
     * // Delete a few Replies
     * const { count } = await prisma.reply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReplyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReplyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Replies
     * const reply = await prisma.reply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReplyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReplyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reply.
     * @param {ReplyUpsertArgs} args - Arguments to update or create a Reply.
     * @example
     * // Update or create a Reply
     * const reply = await prisma.reply.upsert({
     *   create: {
     *     // ... data to create a Reply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reply we want to update
     *   }
     * })
    **/
    upsert<T extends ReplyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReplyUpsertArgs<ExtArgs>>
    ): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCountArgs} args - Arguments to filter Replies to count.
     * @example
     * // Count the number of Replies
     * const count = await prisma.reply.count({
     *   where: {
     *     // ... the filter for the Replies we want to count
     *   }
     * })
    **/
    count<T extends ReplyCountArgs>(
      args?: Subset<T, ReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReplyAggregateArgs>(args: Subset<T, ReplyAggregateArgs>): Prisma.PrismaPromise<GetReplyAggregateType<T>>

    /**
     * Group by Reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReplyGroupByArgs['orderBy'] }
        : { orderBy?: ReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reply model
   */
  readonly fields: ReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    news<T extends NewsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsDefaultArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Reply model
   */ 
  interface ReplyFieldRefs {
    readonly id: FieldRef<"Reply", 'String'>
    readonly newsId: FieldRef<"Reply", 'String'>
    readonly createdAt: FieldRef<"Reply", 'DateTime'>
    readonly updatedAt: FieldRef<"Reply", 'DateTime'>
    readonly fullName: FieldRef<"Reply", 'String'>
    readonly email: FieldRef<"Reply", 'String'>
    readonly comment: FieldRef<"Reply", 'String'>
    readonly isDeleted: FieldRef<"Reply", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Reply findUnique
   */
  export type ReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where: ReplyWhereUniqueInput
  }


  /**
   * Reply findUniqueOrThrow
   */
  export type ReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where: ReplyWhereUniqueInput
  }


  /**
   * Reply findFirst
   */
  export type ReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Replies.
     */
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }


  /**
   * Reply findFirstOrThrow
   */
  export type ReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Replies.
     */
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }


  /**
   * Reply findMany
   */
  export type ReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Replies to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }


  /**
   * Reply create
   */
  export type ReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a Reply.
     */
    data: XOR<ReplyCreateInput, ReplyUncheckedCreateInput>
  }


  /**
   * Reply createMany
   */
  export type ReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Replies.
     */
    data: ReplyCreateManyInput | ReplyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Reply update
   */
  export type ReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a Reply.
     */
    data: XOR<ReplyUpdateInput, ReplyUncheckedUpdateInput>
    /**
     * Choose, which Reply to update.
     */
    where: ReplyWhereUniqueInput
  }


  /**
   * Reply updateMany
   */
  export type ReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Replies.
     */
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyInput>
    /**
     * Filter which Replies to update
     */
    where?: ReplyWhereInput
  }


  /**
   * Reply upsert
   */
  export type ReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the Reply to update in case it exists.
     */
    where: ReplyWhereUniqueInput
    /**
     * In case the Reply found by the `where` argument doesn't exist, create a new Reply with this data.
     */
    create: XOR<ReplyCreateInput, ReplyUncheckedCreateInput>
    /**
     * In case the Reply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReplyUpdateInput, ReplyUncheckedUpdateInput>
  }


  /**
   * Reply delete
   */
  export type ReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter which Reply to delete.
     */
    where: ReplyWhereUniqueInput
  }


  /**
   * Reply deleteMany
   */
  export type ReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Replies to delete
     */
    where?: ReplyWhereInput
  }


  /**
   * Reply without action
   */
  export type ReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude<ExtArgs> | null
  }



  /**
   * Model ContactUs
   */

  export type AggregateContactUs = {
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  export type ContactUsMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fullName: string | null
    email: string | null
    phoneNum: string | null
    subject: string | null
    description: string | null
    isDeleted: boolean | null
    isRead: boolean | null
  }

  export type ContactUsMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fullName: string | null
    email: string | null
    phoneNum: string | null
    subject: string | null
    description: string | null
    isDeleted: boolean | null
    isRead: boolean | null
  }

  export type ContactUsCountAggregateOutputType = {
    id: number
    adminId: number
    createdAt: number
    updatedAt: number
    fullName: number
    email: number
    phoneNum: number
    subject: number
    description: number
    isDeleted: number
    isRead: number
    _all: number
  }


  export type ContactUsMinAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    fullName?: true
    email?: true
    phoneNum?: true
    subject?: true
    description?: true
    isDeleted?: true
    isRead?: true
  }

  export type ContactUsMaxAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    fullName?: true
    email?: true
    phoneNum?: true
    subject?: true
    description?: true
    isDeleted?: true
    isRead?: true
  }

  export type ContactUsCountAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    fullName?: true
    email?: true
    phoneNum?: true
    subject?: true
    description?: true
    isDeleted?: true
    isRead?: true
    _all?: true
  }

  export type ContactUsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactUs to aggregate.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contactuses
    **/
    _count?: true | ContactUsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactUsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactUsMaxAggregateInputType
  }

  export type GetContactUsAggregateType<T extends ContactUsAggregateArgs> = {
        [P in keyof T & keyof AggregateContactUs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactUs[P]>
      : GetScalarType<T[P], AggregateContactUs[P]>
  }




  export type ContactUsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactUsWhereInput
    orderBy?: ContactUsOrderByWithAggregationInput | ContactUsOrderByWithAggregationInput[]
    by: ContactUsScalarFieldEnum[] | ContactUsScalarFieldEnum
    having?: ContactUsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactUsCountAggregateInputType | true
    _min?: ContactUsMinAggregateInputType
    _max?: ContactUsMaxAggregateInputType
  }

  export type ContactUsGroupByOutputType = {
    id: string
    adminId: string | null
    createdAt: Date
    updatedAt: Date
    fullName: string
    email: string
    phoneNum: string
    subject: string
    description: string
    isDeleted: boolean
    isRead: boolean
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  type GetContactUsGroupByPayload<T extends ContactUsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactUsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactUsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
        }
      >
    >


  export type ContactUsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fullName?: boolean
    email?: boolean
    phoneNum?: boolean
    subject?: boolean
    description?: boolean
    isDeleted?: boolean
    isRead?: boolean
    byAdmin?: boolean | ContactUs$byAdminArgs<ExtArgs>
  }, ExtArgs["result"]["contactUs"]>

  export type ContactUsSelectScalar = {
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fullName?: boolean
    email?: boolean
    phoneNum?: boolean
    subject?: boolean
    description?: boolean
    isDeleted?: boolean
    isRead?: boolean
  }

  export type ContactUsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    byAdmin?: boolean | ContactUs$byAdminArgs<ExtArgs>
  }


  export type $ContactUsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactUs"
    objects: {
      byAdmin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string | null
      createdAt: Date
      updatedAt: Date
      fullName: string
      email: string
      phoneNum: string
      subject: string
      description: string
      isDeleted: boolean
      isRead: boolean
    }, ExtArgs["result"]["contactUs"]>
    composites: {}
  }


  type ContactUsGetPayload<S extends boolean | null | undefined | ContactUsDefaultArgs> = $Result.GetResult<Prisma.$ContactUsPayload, S>

  type ContactUsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactUsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactUsCountAggregateInputType | true
    }

  export interface ContactUsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactUs'], meta: { name: 'ContactUs' } }
    /**
     * Find zero or one ContactUs that matches the filter.
     * @param {ContactUsFindUniqueArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactUsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsFindUniqueArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContactUs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContactUsFindUniqueOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactUsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContactUs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactUsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsFindFirstArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContactUs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactUsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contactuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactuses
     * const contactuses = await prisma.contactUs.findMany()
     * 
     * // Get first 10 Contactuses
     * const contactuses = await prisma.contactUs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContactUsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContactUs.
     * @param {ContactUsCreateArgs} args - Arguments to create a ContactUs.
     * @example
     * // Create one ContactUs
     * const ContactUs = await prisma.contactUs.create({
     *   data: {
     *     // ... data to create a ContactUs
     *   }
     * })
     * 
    **/
    create<T extends ContactUsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsCreateArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contactuses.
     *     @param {ContactUsCreateManyArgs} args - Arguments to create many Contactuses.
     *     @example
     *     // Create many Contactuses
     *     const contactUs = await prisma.contactUs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContactUsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactUs.
     * @param {ContactUsDeleteArgs} args - Arguments to delete one ContactUs.
     * @example
     * // Delete one ContactUs
     * const ContactUs = await prisma.contactUs.delete({
     *   where: {
     *     // ... filter to delete one ContactUs
     *   }
     * })
     * 
    **/
    delete<T extends ContactUsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsDeleteArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContactUs.
     * @param {ContactUsUpdateArgs} args - Arguments to update one ContactUs.
     * @example
     * // Update one ContactUs
     * const contactUs = await prisma.contactUs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactUsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsUpdateArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contactuses.
     * @param {ContactUsDeleteManyArgs} args - Arguments to filter Contactuses to delete.
     * @example
     * // Delete a few Contactuses
     * const { count } = await prisma.contactUs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactUsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactUsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactUsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactUs.
     * @param {ContactUsUpsertArgs} args - Arguments to update or create a ContactUs.
     * @example
     * // Update or create a ContactUs
     * const contactUs = await prisma.contactUs.upsert({
     *   create: {
     *     // ... data to create a ContactUs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactUs we want to update
     *   }
     * })
    **/
    upsert<T extends ContactUsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUsUpsertArgs<ExtArgs>>
    ): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsCountArgs} args - Arguments to filter Contactuses to count.
     * @example
     * // Count the number of Contactuses
     * const count = await prisma.contactUs.count({
     *   where: {
     *     // ... the filter for the Contactuses we want to count
     *   }
     * })
    **/
    count<T extends ContactUsCountArgs>(
      args?: Subset<T, ContactUsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactUsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactUsAggregateArgs>(args: Subset<T, ContactUsAggregateArgs>): Prisma.PrismaPromise<GetContactUsAggregateType<T>>

    /**
     * Group by ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactUsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactUsGroupByArgs['orderBy'] }
        : { orderBy?: ContactUsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactUsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactUsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactUs model
   */
  readonly fields: ContactUsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactUs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactUsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    byAdmin<T extends ContactUs$byAdminArgs<ExtArgs> = {}>(args?: Subset<T, ContactUs$byAdminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ContactUs model
   */ 
  interface ContactUsFieldRefs {
    readonly id: FieldRef<"ContactUs", 'String'>
    readonly adminId: FieldRef<"ContactUs", 'String'>
    readonly createdAt: FieldRef<"ContactUs", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactUs", 'DateTime'>
    readonly fullName: FieldRef<"ContactUs", 'String'>
    readonly email: FieldRef<"ContactUs", 'String'>
    readonly phoneNum: FieldRef<"ContactUs", 'String'>
    readonly subject: FieldRef<"ContactUs", 'String'>
    readonly description: FieldRef<"ContactUs", 'String'>
    readonly isDeleted: FieldRef<"ContactUs", 'Boolean'>
    readonly isRead: FieldRef<"ContactUs", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ContactUs findUnique
   */
  export type ContactUsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs findUniqueOrThrow
   */
  export type ContactUsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs findFirst
   */
  export type ContactUsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }


  /**
   * ContactUs findFirstOrThrow
   */
  export type ContactUsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }


  /**
   * ContactUs findMany
   */
  export type ContactUsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter, which Contactuses to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }


  /**
   * ContactUs create
   */
  export type ContactUsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactUs.
     */
    data: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
  }


  /**
   * ContactUs createMany
   */
  export type ContactUsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contactuses.
     */
    data: ContactUsCreateManyInput | ContactUsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContactUs update
   */
  export type ContactUsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactUs.
     */
    data: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
    /**
     * Choose, which ContactUs to update.
     */
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs updateMany
   */
  export type ContactUsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contactuses.
     */
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyInput>
    /**
     * Filter which Contactuses to update
     */
    where?: ContactUsWhereInput
  }


  /**
   * ContactUs upsert
   */
  export type ContactUsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactUs to update in case it exists.
     */
    where: ContactUsWhereUniqueInput
    /**
     * In case the ContactUs found by the `where` argument doesn't exist, create a new ContactUs with this data.
     */
    create: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
    /**
     * In case the ContactUs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
  }


  /**
   * ContactUs delete
   */
  export type ContactUsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
    /**
     * Filter which ContactUs to delete.
     */
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs deleteMany
   */
  export type ContactUsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contactuses to delete
     */
    where?: ContactUsWhereInput
  }


  /**
   * ContactUs.byAdmin
   */
  export type ContactUs$byAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }


  /**
   * ContactUs without action
   */
  export type ContactUsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactUsInclude<ExtArgs> | null
  }



  /**
   * Model AppSettings
   */

  export type AggregateAppSettings = {
    _count: AppSettingsCountAggregateOutputType | null
    _min: AppSettingsMinAggregateOutputType | null
    _max: AppSettingsMaxAggregateOutputType | null
  }

  export type AppSettingsMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelName: string | null
    logo: string | null
    address: string | null
    phoneNum: string | null
    email: string | null
  }

  export type AppSettingsMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelName: string | null
    logo: string | null
    address: string | null
    phoneNum: string | null
    email: string | null
  }

  export type AppSettingsCountAggregateOutputType = {
    id: number
    adminId: number
    createdAt: number
    updatedAt: number
    hotelName: number
    logo: number
    address: number
    phoneNum: number
    email: number
    socialMedia: number
    _all: number
  }


  export type AppSettingsMinAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    hotelName?: true
    logo?: true
    address?: true
    phoneNum?: true
    email?: true
  }

  export type AppSettingsMaxAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    hotelName?: true
    logo?: true
    address?: true
    phoneNum?: true
    email?: true
  }

  export type AppSettingsCountAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    hotelName?: true
    logo?: true
    address?: true
    phoneNum?: true
    email?: true
    socialMedia?: true
    _all?: true
  }

  export type AppSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppSettings to aggregate.
     */
    where?: AppSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSettings to fetch.
     */
    orderBy?: AppSettingsOrderByWithRelationInput | AppSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppSettings
    **/
    _count?: true | AppSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppSettingsMaxAggregateInputType
  }

  export type GetAppSettingsAggregateType<T extends AppSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateAppSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppSettings[P]>
      : GetScalarType<T[P], AggregateAppSettings[P]>
  }




  export type AppSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppSettingsWhereInput
    orderBy?: AppSettingsOrderByWithAggregationInput | AppSettingsOrderByWithAggregationInput[]
    by: AppSettingsScalarFieldEnum[] | AppSettingsScalarFieldEnum
    having?: AppSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppSettingsCountAggregateInputType | true
    _min?: AppSettingsMinAggregateInputType
    _max?: AppSettingsMaxAggregateInputType
  }

  export type AppSettingsGroupByOutputType = {
    id: string
    adminId: string
    createdAt: Date
    updatedAt: Date
    hotelName: string
    logo: string
    address: string
    phoneNum: string
    email: string
    socialMedia: JsonValue
    _count: AppSettingsCountAggregateOutputType | null
    _min: AppSettingsMinAggregateOutputType | null
    _max: AppSettingsMaxAggregateOutputType | null
  }

  type GetAppSettingsGroupByPayload<T extends AppSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], AppSettingsGroupByOutputType[P]>
        }
      >
    >


  export type AppSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelName?: boolean
    logo?: boolean
    address?: boolean
    phoneNum?: boolean
    email?: boolean
    socialMedia?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appSettings"]>

  export type AppSettingsSelectScalar = {
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelName?: boolean
    logo?: boolean
    address?: boolean
    phoneNum?: boolean
    email?: boolean
    socialMedia?: boolean
  }

  export type AppSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }


  export type $AppSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppSettings"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      createdAt: Date
      updatedAt: Date
      hotelName: string
      logo: string
      address: string
      phoneNum: string
      email: string
      socialMedia: Prisma.JsonValue
    }, ExtArgs["result"]["appSettings"]>
    composites: {}
  }


  type AppSettingsGetPayload<S extends boolean | null | undefined | AppSettingsDefaultArgs> = $Result.GetResult<Prisma.$AppSettingsPayload, S>

  type AppSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppSettingsCountAggregateInputType | true
    }

  export interface AppSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppSettings'], meta: { name: 'AppSettings' } }
    /**
     * Find zero or one AppSettings that matches the filter.
     * @param {AppSettingsFindUniqueArgs} args - Arguments to find a AppSettings
     * @example
     * // Get one AppSettings
     * const appSettings = await prisma.appSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppSettingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AppSettingsFindUniqueArgs<ExtArgs>>
    ): Prisma__AppSettingsClient<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AppSettings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AppSettingsFindUniqueOrThrowArgs} args - Arguments to find a AppSettings
     * @example
     * // Get one AppSettings
     * const appSettings = await prisma.appSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AppSettingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppSettingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AppSettingsClient<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AppSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSettingsFindFirstArgs} args - Arguments to find a AppSettings
     * @example
     * // Get one AppSettings
     * const appSettings = await prisma.appSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppSettingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AppSettingsFindFirstArgs<ExtArgs>>
    ): Prisma__AppSettingsClient<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AppSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSettingsFindFirstOrThrowArgs} args - Arguments to find a AppSettings
     * @example
     * // Get one AppSettings
     * const appSettings = await prisma.appSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AppSettingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppSettingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AppSettingsClient<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AppSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSettingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppSettings
     * const appSettings = await prisma.appSettings.findMany()
     * 
     * // Get first 10 AppSettings
     * const appSettings = await prisma.appSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appSettingsWithIdOnly = await prisma.appSettings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppSettingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppSettingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AppSettings.
     * @param {AppSettingsCreateArgs} args - Arguments to create a AppSettings.
     * @example
     * // Create one AppSettings
     * const AppSettings = await prisma.appSettings.create({
     *   data: {
     *     // ... data to create a AppSettings
     *   }
     * })
     * 
    **/
    create<T extends AppSettingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AppSettingsCreateArgs<ExtArgs>>
    ): Prisma__AppSettingsClient<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AppSettings.
     *     @param {AppSettingsCreateManyArgs} args - Arguments to create many AppSettings.
     *     @example
     *     // Create many AppSettings
     *     const appSettings = await prisma.appSettings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppSettingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppSettingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AppSettings.
     * @param {AppSettingsDeleteArgs} args - Arguments to delete one AppSettings.
     * @example
     * // Delete one AppSettings
     * const AppSettings = await prisma.appSettings.delete({
     *   where: {
     *     // ... filter to delete one AppSettings
     *   }
     * })
     * 
    **/
    delete<T extends AppSettingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AppSettingsDeleteArgs<ExtArgs>>
    ): Prisma__AppSettingsClient<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AppSettings.
     * @param {AppSettingsUpdateArgs} args - Arguments to update one AppSettings.
     * @example
     * // Update one AppSettings
     * const appSettings = await prisma.appSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppSettingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AppSettingsUpdateArgs<ExtArgs>>
    ): Prisma__AppSettingsClient<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AppSettings.
     * @param {AppSettingsDeleteManyArgs} args - Arguments to filter AppSettings to delete.
     * @example
     * // Delete a few AppSettings
     * const { count } = await prisma.appSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppSettingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppSettingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppSettings
     * const appSettings = await prisma.appSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppSettingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AppSettingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppSettings.
     * @param {AppSettingsUpsertArgs} args - Arguments to update or create a AppSettings.
     * @example
     * // Update or create a AppSettings
     * const appSettings = await prisma.appSettings.upsert({
     *   create: {
     *     // ... data to create a AppSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppSettings we want to update
     *   }
     * })
    **/
    upsert<T extends AppSettingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AppSettingsUpsertArgs<ExtArgs>>
    ): Prisma__AppSettingsClient<$Result.GetResult<Prisma.$AppSettingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AppSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSettingsCountArgs} args - Arguments to filter AppSettings to count.
     * @example
     * // Count the number of AppSettings
     * const count = await prisma.appSettings.count({
     *   where: {
     *     // ... the filter for the AppSettings we want to count
     *   }
     * })
    **/
    count<T extends AppSettingsCountArgs>(
      args?: Subset<T, AppSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppSettingsAggregateArgs>(args: Subset<T, AppSettingsAggregateArgs>): Prisma.PrismaPromise<GetAppSettingsAggregateType<T>>

    /**
     * Group by AppSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppSettingsGroupByArgs['orderBy'] }
        : { orderBy?: AppSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppSettings model
   */
  readonly fields: AppSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AppSettings model
   */ 
  interface AppSettingsFieldRefs {
    readonly id: FieldRef<"AppSettings", 'String'>
    readonly adminId: FieldRef<"AppSettings", 'String'>
    readonly createdAt: FieldRef<"AppSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"AppSettings", 'DateTime'>
    readonly hotelName: FieldRef<"AppSettings", 'String'>
    readonly logo: FieldRef<"AppSettings", 'String'>
    readonly address: FieldRef<"AppSettings", 'String'>
    readonly phoneNum: FieldRef<"AppSettings", 'String'>
    readonly email: FieldRef<"AppSettings", 'String'>
    readonly socialMedia: FieldRef<"AppSettings", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * AppSettings findUnique
   */
  export type AppSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AppSettings to fetch.
     */
    where: AppSettingsWhereUniqueInput
  }


  /**
   * AppSettings findUniqueOrThrow
   */
  export type AppSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AppSettings to fetch.
     */
    where: AppSettingsWhereUniqueInput
  }


  /**
   * AppSettings findFirst
   */
  export type AppSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AppSettings to fetch.
     */
    where?: AppSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSettings to fetch.
     */
    orderBy?: AppSettingsOrderByWithRelationInput | AppSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppSettings.
     */
    cursor?: AppSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppSettings.
     */
    distinct?: AppSettingsScalarFieldEnum | AppSettingsScalarFieldEnum[]
  }


  /**
   * AppSettings findFirstOrThrow
   */
  export type AppSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AppSettings to fetch.
     */
    where?: AppSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSettings to fetch.
     */
    orderBy?: AppSettingsOrderByWithRelationInput | AppSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppSettings.
     */
    cursor?: AppSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppSettings.
     */
    distinct?: AppSettingsScalarFieldEnum | AppSettingsScalarFieldEnum[]
  }


  /**
   * AppSettings findMany
   */
  export type AppSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AppSettings to fetch.
     */
    where?: AppSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSettings to fetch.
     */
    orderBy?: AppSettingsOrderByWithRelationInput | AppSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppSettings.
     */
    cursor?: AppSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSettings.
     */
    skip?: number
    distinct?: AppSettingsScalarFieldEnum | AppSettingsScalarFieldEnum[]
  }


  /**
   * AppSettings create
   */
  export type AppSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a AppSettings.
     */
    data: XOR<AppSettingsCreateInput, AppSettingsUncheckedCreateInput>
  }


  /**
   * AppSettings createMany
   */
  export type AppSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppSettings.
     */
    data: AppSettingsCreateManyInput | AppSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AppSettings update
   */
  export type AppSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a AppSettings.
     */
    data: XOR<AppSettingsUpdateInput, AppSettingsUncheckedUpdateInput>
    /**
     * Choose, which AppSettings to update.
     */
    where: AppSettingsWhereUniqueInput
  }


  /**
   * AppSettings updateMany
   */
  export type AppSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppSettings.
     */
    data: XOR<AppSettingsUpdateManyMutationInput, AppSettingsUncheckedUpdateManyInput>
    /**
     * Filter which AppSettings to update
     */
    where?: AppSettingsWhereInput
  }


  /**
   * AppSettings upsert
   */
  export type AppSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the AppSettings to update in case it exists.
     */
    where: AppSettingsWhereUniqueInput
    /**
     * In case the AppSettings found by the `where` argument doesn't exist, create a new AppSettings with this data.
     */
    create: XOR<AppSettingsCreateInput, AppSettingsUncheckedCreateInput>
    /**
     * In case the AppSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppSettingsUpdateInput, AppSettingsUncheckedUpdateInput>
  }


  /**
   * AppSettings delete
   */
  export type AppSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
    /**
     * Filter which AppSettings to delete.
     */
    where: AppSettingsWhereUniqueInput
  }


  /**
   * AppSettings deleteMany
   */
  export type AppSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppSettings to delete
     */
    where?: AppSettingsWhereInput
  }


  /**
   * AppSettings without action
   */
  export type AppSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSettings
     */
    select?: AppSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppSettingsInclude<ExtArgs> | null
  }



  /**
   * Model HomeSliders
   */

  export type AggregateHomeSliders = {
    _count: HomeSlidersCountAggregateOutputType | null
    _min: HomeSlidersMinAggregateOutputType | null
    _max: HomeSlidersMaxAggregateOutputType | null
  }

  export type HomeSlidersMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    photo: string | null
    header: string | null
    paragraph: string | null
    isDeleted: boolean | null
  }

  export type HomeSlidersMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    photo: string | null
    header: string | null
    paragraph: string | null
    isDeleted: boolean | null
  }

  export type HomeSlidersCountAggregateOutputType = {
    id: number
    adminId: number
    createdAt: number
    updatedAt: number
    photo: number
    header: number
    paragraph: number
    isDeleted: number
    _all: number
  }


  export type HomeSlidersMinAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    photo?: true
    header?: true
    paragraph?: true
    isDeleted?: true
  }

  export type HomeSlidersMaxAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    photo?: true
    header?: true
    paragraph?: true
    isDeleted?: true
  }

  export type HomeSlidersCountAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    photo?: true
    header?: true
    paragraph?: true
    isDeleted?: true
    _all?: true
  }

  export type HomeSlidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeSliders to aggregate.
     */
    where?: HomeSlidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeSliders to fetch.
     */
    orderBy?: HomeSlidersOrderByWithRelationInput | HomeSlidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeSlidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeSliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomeSliders
    **/
    _count?: true | HomeSlidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeSlidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeSlidersMaxAggregateInputType
  }

  export type GetHomeSlidersAggregateType<T extends HomeSlidersAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeSliders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeSliders[P]>
      : GetScalarType<T[P], AggregateHomeSliders[P]>
  }




  export type HomeSlidersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeSlidersWhereInput
    orderBy?: HomeSlidersOrderByWithAggregationInput | HomeSlidersOrderByWithAggregationInput[]
    by: HomeSlidersScalarFieldEnum[] | HomeSlidersScalarFieldEnum
    having?: HomeSlidersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeSlidersCountAggregateInputType | true
    _min?: HomeSlidersMinAggregateInputType
    _max?: HomeSlidersMaxAggregateInputType
  }

  export type HomeSlidersGroupByOutputType = {
    id: string
    adminId: string
    createdAt: Date
    updatedAt: Date
    photo: string
    header: string
    paragraph: string
    isDeleted: boolean
    _count: HomeSlidersCountAggregateOutputType | null
    _min: HomeSlidersMinAggregateOutputType | null
    _max: HomeSlidersMaxAggregateOutputType | null
  }

  type GetHomeSlidersGroupByPayload<T extends HomeSlidersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomeSlidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeSlidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeSlidersGroupByOutputType[P]>
            : GetScalarType<T[P], HomeSlidersGroupByOutputType[P]>
        }
      >
    >


  export type HomeSlidersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photo?: boolean
    header?: boolean
    paragraph?: boolean
    isDeleted?: boolean
    byAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeSliders"]>

  export type HomeSlidersSelectScalar = {
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photo?: boolean
    header?: boolean
    paragraph?: boolean
    isDeleted?: boolean
  }

  export type HomeSlidersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    byAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }


  export type $HomeSlidersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HomeSliders"
    objects: {
      byAdmin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      createdAt: Date
      updatedAt: Date
      photo: string
      header: string
      paragraph: string
      isDeleted: boolean
    }, ExtArgs["result"]["homeSliders"]>
    composites: {}
  }


  type HomeSlidersGetPayload<S extends boolean | null | undefined | HomeSlidersDefaultArgs> = $Result.GetResult<Prisma.$HomeSlidersPayload, S>

  type HomeSlidersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HomeSlidersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HomeSlidersCountAggregateInputType | true
    }

  export interface HomeSlidersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HomeSliders'], meta: { name: 'HomeSliders' } }
    /**
     * Find zero or one HomeSliders that matches the filter.
     * @param {HomeSlidersFindUniqueArgs} args - Arguments to find a HomeSliders
     * @example
     * // Get one HomeSliders
     * const homeSliders = await prisma.homeSliders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HomeSlidersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HomeSlidersFindUniqueArgs<ExtArgs>>
    ): Prisma__HomeSlidersClient<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HomeSliders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HomeSlidersFindUniqueOrThrowArgs} args - Arguments to find a HomeSliders
     * @example
     * // Get one HomeSliders
     * const homeSliders = await prisma.homeSliders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HomeSlidersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HomeSlidersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HomeSlidersClient<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HomeSliders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeSlidersFindFirstArgs} args - Arguments to find a HomeSliders
     * @example
     * // Get one HomeSliders
     * const homeSliders = await prisma.homeSliders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HomeSlidersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HomeSlidersFindFirstArgs<ExtArgs>>
    ): Prisma__HomeSlidersClient<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HomeSliders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeSlidersFindFirstOrThrowArgs} args - Arguments to find a HomeSliders
     * @example
     * // Get one HomeSliders
     * const homeSliders = await prisma.homeSliders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HomeSlidersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HomeSlidersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HomeSlidersClient<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HomeSliders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeSlidersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomeSliders
     * const homeSliders = await prisma.homeSliders.findMany()
     * 
     * // Get first 10 HomeSliders
     * const homeSliders = await prisma.homeSliders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeSlidersWithIdOnly = await prisma.homeSliders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HomeSlidersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HomeSlidersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HomeSliders.
     * @param {HomeSlidersCreateArgs} args - Arguments to create a HomeSliders.
     * @example
     * // Create one HomeSliders
     * const HomeSliders = await prisma.homeSliders.create({
     *   data: {
     *     // ... data to create a HomeSliders
     *   }
     * })
     * 
    **/
    create<T extends HomeSlidersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HomeSlidersCreateArgs<ExtArgs>>
    ): Prisma__HomeSlidersClient<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HomeSliders.
     *     @param {HomeSlidersCreateManyArgs} args - Arguments to create many HomeSliders.
     *     @example
     *     // Create many HomeSliders
     *     const homeSliders = await prisma.homeSliders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HomeSlidersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HomeSlidersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HomeSliders.
     * @param {HomeSlidersDeleteArgs} args - Arguments to delete one HomeSliders.
     * @example
     * // Delete one HomeSliders
     * const HomeSliders = await prisma.homeSliders.delete({
     *   where: {
     *     // ... filter to delete one HomeSliders
     *   }
     * })
     * 
    **/
    delete<T extends HomeSlidersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HomeSlidersDeleteArgs<ExtArgs>>
    ): Prisma__HomeSlidersClient<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HomeSliders.
     * @param {HomeSlidersUpdateArgs} args - Arguments to update one HomeSliders.
     * @example
     * // Update one HomeSliders
     * const homeSliders = await prisma.homeSliders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HomeSlidersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HomeSlidersUpdateArgs<ExtArgs>>
    ): Prisma__HomeSlidersClient<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HomeSliders.
     * @param {HomeSlidersDeleteManyArgs} args - Arguments to filter HomeSliders to delete.
     * @example
     * // Delete a few HomeSliders
     * const { count } = await prisma.homeSliders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HomeSlidersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HomeSlidersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeSlidersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomeSliders
     * const homeSliders = await prisma.homeSliders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HomeSlidersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HomeSlidersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HomeSliders.
     * @param {HomeSlidersUpsertArgs} args - Arguments to update or create a HomeSliders.
     * @example
     * // Update or create a HomeSliders
     * const homeSliders = await prisma.homeSliders.upsert({
     *   create: {
     *     // ... data to create a HomeSliders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomeSliders we want to update
     *   }
     * })
    **/
    upsert<T extends HomeSlidersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HomeSlidersUpsertArgs<ExtArgs>>
    ): Prisma__HomeSlidersClient<$Result.GetResult<Prisma.$HomeSlidersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HomeSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeSlidersCountArgs} args - Arguments to filter HomeSliders to count.
     * @example
     * // Count the number of HomeSliders
     * const count = await prisma.homeSliders.count({
     *   where: {
     *     // ... the filter for the HomeSliders we want to count
     *   }
     * })
    **/
    count<T extends HomeSlidersCountArgs>(
      args?: Subset<T, HomeSlidersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeSlidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomeSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeSlidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeSlidersAggregateArgs>(args: Subset<T, HomeSlidersAggregateArgs>): Prisma.PrismaPromise<GetHomeSlidersAggregateType<T>>

    /**
     * Group by HomeSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeSlidersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeSlidersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeSlidersGroupByArgs['orderBy'] }
        : { orderBy?: HomeSlidersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeSlidersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeSlidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HomeSliders model
   */
  readonly fields: HomeSlidersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HomeSliders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomeSlidersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    byAdmin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HomeSliders model
   */ 
  interface HomeSlidersFieldRefs {
    readonly id: FieldRef<"HomeSliders", 'String'>
    readonly adminId: FieldRef<"HomeSliders", 'String'>
    readonly createdAt: FieldRef<"HomeSliders", 'DateTime'>
    readonly updatedAt: FieldRef<"HomeSliders", 'DateTime'>
    readonly photo: FieldRef<"HomeSliders", 'String'>
    readonly header: FieldRef<"HomeSliders", 'String'>
    readonly paragraph: FieldRef<"HomeSliders", 'String'>
    readonly isDeleted: FieldRef<"HomeSliders", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * HomeSliders findUnique
   */
  export type HomeSlidersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    /**
     * Filter, which HomeSliders to fetch.
     */
    where: HomeSlidersWhereUniqueInput
  }


  /**
   * HomeSliders findUniqueOrThrow
   */
  export type HomeSlidersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    /**
     * Filter, which HomeSliders to fetch.
     */
    where: HomeSlidersWhereUniqueInput
  }


  /**
   * HomeSliders findFirst
   */
  export type HomeSlidersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    /**
     * Filter, which HomeSliders to fetch.
     */
    where?: HomeSlidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeSliders to fetch.
     */
    orderBy?: HomeSlidersOrderByWithRelationInput | HomeSlidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeSliders.
     */
    cursor?: HomeSlidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeSliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeSliders.
     */
    distinct?: HomeSlidersScalarFieldEnum | HomeSlidersScalarFieldEnum[]
  }


  /**
   * HomeSliders findFirstOrThrow
   */
  export type HomeSlidersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    /**
     * Filter, which HomeSliders to fetch.
     */
    where?: HomeSlidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeSliders to fetch.
     */
    orderBy?: HomeSlidersOrderByWithRelationInput | HomeSlidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeSliders.
     */
    cursor?: HomeSlidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeSliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeSliders.
     */
    distinct?: HomeSlidersScalarFieldEnum | HomeSlidersScalarFieldEnum[]
  }


  /**
   * HomeSliders findMany
   */
  export type HomeSlidersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    /**
     * Filter, which HomeSliders to fetch.
     */
    where?: HomeSlidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeSliders to fetch.
     */
    orderBy?: HomeSlidersOrderByWithRelationInput | HomeSlidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomeSliders.
     */
    cursor?: HomeSlidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeSliders.
     */
    skip?: number
    distinct?: HomeSlidersScalarFieldEnum | HomeSlidersScalarFieldEnum[]
  }


  /**
   * HomeSliders create
   */
  export type HomeSlidersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    /**
     * The data needed to create a HomeSliders.
     */
    data: XOR<HomeSlidersCreateInput, HomeSlidersUncheckedCreateInput>
  }


  /**
   * HomeSliders createMany
   */
  export type HomeSlidersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HomeSliders.
     */
    data: HomeSlidersCreateManyInput | HomeSlidersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * HomeSliders update
   */
  export type HomeSlidersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    /**
     * The data needed to update a HomeSliders.
     */
    data: XOR<HomeSlidersUpdateInput, HomeSlidersUncheckedUpdateInput>
    /**
     * Choose, which HomeSliders to update.
     */
    where: HomeSlidersWhereUniqueInput
  }


  /**
   * HomeSliders updateMany
   */
  export type HomeSlidersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HomeSliders.
     */
    data: XOR<HomeSlidersUpdateManyMutationInput, HomeSlidersUncheckedUpdateManyInput>
    /**
     * Filter which HomeSliders to update
     */
    where?: HomeSlidersWhereInput
  }


  /**
   * HomeSliders upsert
   */
  export type HomeSlidersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    /**
     * The filter to search for the HomeSliders to update in case it exists.
     */
    where: HomeSlidersWhereUniqueInput
    /**
     * In case the HomeSliders found by the `where` argument doesn't exist, create a new HomeSliders with this data.
     */
    create: XOR<HomeSlidersCreateInput, HomeSlidersUncheckedCreateInput>
    /**
     * In case the HomeSliders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeSlidersUpdateInput, HomeSlidersUncheckedUpdateInput>
  }


  /**
   * HomeSliders delete
   */
  export type HomeSlidersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
    /**
     * Filter which HomeSliders to delete.
     */
    where: HomeSlidersWhereUniqueInput
  }


  /**
   * HomeSliders deleteMany
   */
  export type HomeSlidersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeSliders to delete
     */
    where?: HomeSlidersWhereInput
  }


  /**
   * HomeSliders without action
   */
  export type HomeSlidersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeSliders
     */
    select?: HomeSlidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeSlidersInclude<ExtArgs> | null
  }



  /**
   * Model PromotionVid
   */

  export type AggregatePromotionVid = {
    _count: PromotionVidCountAggregateOutputType | null
    _min: PromotionVidMinAggregateOutputType | null
    _max: PromotionVidMaxAggregateOutputType | null
  }

  export type PromotionVidMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    video: string | null
    description: string | null
  }

  export type PromotionVidMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    video: string | null
    description: string | null
  }

  export type PromotionVidCountAggregateOutputType = {
    id: number
    adminId: number
    createdAt: number
    updatedAt: number
    video: number
    description: number
    _all: number
  }


  export type PromotionVidMinAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    video?: true
    description?: true
  }

  export type PromotionVidMaxAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    video?: true
    description?: true
  }

  export type PromotionVidCountAggregateInputType = {
    id?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    video?: true
    description?: true
    _all?: true
  }

  export type PromotionVidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionVid to aggregate.
     */
    where?: PromotionVidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionVids to fetch.
     */
    orderBy?: PromotionVidOrderByWithRelationInput | PromotionVidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionVidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionVids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionVids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionVids
    **/
    _count?: true | PromotionVidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionVidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionVidMaxAggregateInputType
  }

  export type GetPromotionVidAggregateType<T extends PromotionVidAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionVid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionVid[P]>
      : GetScalarType<T[P], AggregatePromotionVid[P]>
  }




  export type PromotionVidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionVidWhereInput
    orderBy?: PromotionVidOrderByWithAggregationInput | PromotionVidOrderByWithAggregationInput[]
    by: PromotionVidScalarFieldEnum[] | PromotionVidScalarFieldEnum
    having?: PromotionVidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionVidCountAggregateInputType | true
    _min?: PromotionVidMinAggregateInputType
    _max?: PromotionVidMaxAggregateInputType
  }

  export type PromotionVidGroupByOutputType = {
    id: string
    adminId: string
    createdAt: Date
    updatedAt: Date
    video: string
    description: string
    _count: PromotionVidCountAggregateOutputType | null
    _min: PromotionVidMinAggregateOutputType | null
    _max: PromotionVidMaxAggregateOutputType | null
  }

  type GetPromotionVidGroupByPayload<T extends PromotionVidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionVidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionVidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionVidGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionVidGroupByOutputType[P]>
        }
      >
    >


  export type PromotionVidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    video?: boolean
    description?: boolean
    byAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionVid"]>

  export type PromotionVidSelectScalar = {
    id?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    video?: boolean
    description?: boolean
  }

  export type PromotionVidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    byAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }


  export type $PromotionVidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionVid"
    objects: {
      byAdmin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      createdAt: Date
      updatedAt: Date
      video: string
      description: string
    }, ExtArgs["result"]["promotionVid"]>
    composites: {}
  }


  type PromotionVidGetPayload<S extends boolean | null | undefined | PromotionVidDefaultArgs> = $Result.GetResult<Prisma.$PromotionVidPayload, S>

  type PromotionVidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromotionVidFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromotionVidCountAggregateInputType | true
    }

  export interface PromotionVidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionVid'], meta: { name: 'PromotionVid' } }
    /**
     * Find zero or one PromotionVid that matches the filter.
     * @param {PromotionVidFindUniqueArgs} args - Arguments to find a PromotionVid
     * @example
     * // Get one PromotionVid
     * const promotionVid = await prisma.promotionVid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromotionVidFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionVidFindUniqueArgs<ExtArgs>>
    ): Prisma__PromotionVidClient<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PromotionVid that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PromotionVidFindUniqueOrThrowArgs} args - Arguments to find a PromotionVid
     * @example
     * // Get one PromotionVid
     * const promotionVid = await prisma.promotionVid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromotionVidFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionVidFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PromotionVidClient<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PromotionVid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionVidFindFirstArgs} args - Arguments to find a PromotionVid
     * @example
     * // Get one PromotionVid
     * const promotionVid = await prisma.promotionVid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromotionVidFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionVidFindFirstArgs<ExtArgs>>
    ): Prisma__PromotionVidClient<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PromotionVid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionVidFindFirstOrThrowArgs} args - Arguments to find a PromotionVid
     * @example
     * // Get one PromotionVid
     * const promotionVid = await prisma.promotionVid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromotionVidFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionVidFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PromotionVidClient<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PromotionVids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionVidFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionVids
     * const promotionVids = await prisma.promotionVid.findMany()
     * 
     * // Get first 10 PromotionVids
     * const promotionVids = await prisma.promotionVid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionVidWithIdOnly = await prisma.promotionVid.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromotionVidFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionVidFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PromotionVid.
     * @param {PromotionVidCreateArgs} args - Arguments to create a PromotionVid.
     * @example
     * // Create one PromotionVid
     * const PromotionVid = await prisma.promotionVid.create({
     *   data: {
     *     // ... data to create a PromotionVid
     *   }
     * })
     * 
    **/
    create<T extends PromotionVidCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionVidCreateArgs<ExtArgs>>
    ): Prisma__PromotionVidClient<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PromotionVids.
     *     @param {PromotionVidCreateManyArgs} args - Arguments to create many PromotionVids.
     *     @example
     *     // Create many PromotionVids
     *     const promotionVid = await prisma.promotionVid.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromotionVidCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionVidCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromotionVid.
     * @param {PromotionVidDeleteArgs} args - Arguments to delete one PromotionVid.
     * @example
     * // Delete one PromotionVid
     * const PromotionVid = await prisma.promotionVid.delete({
     *   where: {
     *     // ... filter to delete one PromotionVid
     *   }
     * })
     * 
    **/
    delete<T extends PromotionVidDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionVidDeleteArgs<ExtArgs>>
    ): Prisma__PromotionVidClient<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PromotionVid.
     * @param {PromotionVidUpdateArgs} args - Arguments to update one PromotionVid.
     * @example
     * // Update one PromotionVid
     * const promotionVid = await prisma.promotionVid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromotionVidUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionVidUpdateArgs<ExtArgs>>
    ): Prisma__PromotionVidClient<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PromotionVids.
     * @param {PromotionVidDeleteManyArgs} args - Arguments to filter PromotionVids to delete.
     * @example
     * // Delete a few PromotionVids
     * const { count } = await prisma.promotionVid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromotionVidDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionVidDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionVids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionVidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionVids
     * const promotionVid = await prisma.promotionVid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromotionVidUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionVidUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromotionVid.
     * @param {PromotionVidUpsertArgs} args - Arguments to update or create a PromotionVid.
     * @example
     * // Update or create a PromotionVid
     * const promotionVid = await prisma.promotionVid.upsert({
     *   create: {
     *     // ... data to create a PromotionVid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionVid we want to update
     *   }
     * })
    **/
    upsert<T extends PromotionVidUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionVidUpsertArgs<ExtArgs>>
    ): Prisma__PromotionVidClient<$Result.GetResult<Prisma.$PromotionVidPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PromotionVids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionVidCountArgs} args - Arguments to filter PromotionVids to count.
     * @example
     * // Count the number of PromotionVids
     * const count = await prisma.promotionVid.count({
     *   where: {
     *     // ... the filter for the PromotionVids we want to count
     *   }
     * })
    **/
    count<T extends PromotionVidCountArgs>(
      args?: Subset<T, PromotionVidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionVidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionVid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionVidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionVidAggregateArgs>(args: Subset<T, PromotionVidAggregateArgs>): Prisma.PrismaPromise<GetPromotionVidAggregateType<T>>

    /**
     * Group by PromotionVid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionVidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionVidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionVidGroupByArgs['orderBy'] }
        : { orderBy?: PromotionVidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionVidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionVidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionVid model
   */
  readonly fields: PromotionVidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionVid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionVidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    byAdmin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PromotionVid model
   */ 
  interface PromotionVidFieldRefs {
    readonly id: FieldRef<"PromotionVid", 'String'>
    readonly adminId: FieldRef<"PromotionVid", 'String'>
    readonly createdAt: FieldRef<"PromotionVid", 'DateTime'>
    readonly updatedAt: FieldRef<"PromotionVid", 'DateTime'>
    readonly video: FieldRef<"PromotionVid", 'String'>
    readonly description: FieldRef<"PromotionVid", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PromotionVid findUnique
   */
  export type PromotionVidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    /**
     * Filter, which PromotionVid to fetch.
     */
    where: PromotionVidWhereUniqueInput
  }


  /**
   * PromotionVid findUniqueOrThrow
   */
  export type PromotionVidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    /**
     * Filter, which PromotionVid to fetch.
     */
    where: PromotionVidWhereUniqueInput
  }


  /**
   * PromotionVid findFirst
   */
  export type PromotionVidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    /**
     * Filter, which PromotionVid to fetch.
     */
    where?: PromotionVidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionVids to fetch.
     */
    orderBy?: PromotionVidOrderByWithRelationInput | PromotionVidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionVids.
     */
    cursor?: PromotionVidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionVids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionVids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionVids.
     */
    distinct?: PromotionVidScalarFieldEnum | PromotionVidScalarFieldEnum[]
  }


  /**
   * PromotionVid findFirstOrThrow
   */
  export type PromotionVidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    /**
     * Filter, which PromotionVid to fetch.
     */
    where?: PromotionVidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionVids to fetch.
     */
    orderBy?: PromotionVidOrderByWithRelationInput | PromotionVidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionVids.
     */
    cursor?: PromotionVidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionVids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionVids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionVids.
     */
    distinct?: PromotionVidScalarFieldEnum | PromotionVidScalarFieldEnum[]
  }


  /**
   * PromotionVid findMany
   */
  export type PromotionVidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    /**
     * Filter, which PromotionVids to fetch.
     */
    where?: PromotionVidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionVids to fetch.
     */
    orderBy?: PromotionVidOrderByWithRelationInput | PromotionVidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionVids.
     */
    cursor?: PromotionVidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionVids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionVids.
     */
    skip?: number
    distinct?: PromotionVidScalarFieldEnum | PromotionVidScalarFieldEnum[]
  }


  /**
   * PromotionVid create
   */
  export type PromotionVidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionVid.
     */
    data: XOR<PromotionVidCreateInput, PromotionVidUncheckedCreateInput>
  }


  /**
   * PromotionVid createMany
   */
  export type PromotionVidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionVids.
     */
    data: PromotionVidCreateManyInput | PromotionVidCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PromotionVid update
   */
  export type PromotionVidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionVid.
     */
    data: XOR<PromotionVidUpdateInput, PromotionVidUncheckedUpdateInput>
    /**
     * Choose, which PromotionVid to update.
     */
    where: PromotionVidWhereUniqueInput
  }


  /**
   * PromotionVid updateMany
   */
  export type PromotionVidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionVids.
     */
    data: XOR<PromotionVidUpdateManyMutationInput, PromotionVidUncheckedUpdateManyInput>
    /**
     * Filter which PromotionVids to update
     */
    where?: PromotionVidWhereInput
  }


  /**
   * PromotionVid upsert
   */
  export type PromotionVidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionVid to update in case it exists.
     */
    where: PromotionVidWhereUniqueInput
    /**
     * In case the PromotionVid found by the `where` argument doesn't exist, create a new PromotionVid with this data.
     */
    create: XOR<PromotionVidCreateInput, PromotionVidUncheckedCreateInput>
    /**
     * In case the PromotionVid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionVidUpdateInput, PromotionVidUncheckedUpdateInput>
  }


  /**
   * PromotionVid delete
   */
  export type PromotionVidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
    /**
     * Filter which PromotionVid to delete.
     */
    where: PromotionVidWhereUniqueInput
  }


  /**
   * PromotionVid deleteMany
   */
  export type PromotionVidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionVids to delete
     */
    where?: PromotionVidWhereInput
  }


  /**
   * PromotionVid without action
   */
  export type PromotionVidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionVid
     */
    select?: PromotionVidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionVidInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fullName: 'fullName',
    email: 'email',
    password: 'password',
    username: 'username',
    profilePic: 'profilePic',
    birthDate: 'birthDate',
    phoneNum: 'phoneNum',
    isDeleted: 'isDeleted',
    emailConfirmed: 'emailConfirmed',
    role: 'role'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fName: 'fName',
    lName: 'lName',
    username: 'username',
    email: 'email',
    password: 'password',
    profilePic: 'profilePic',
    birthDate: 'birthDate',
    country: 'country',
    nationalID: 'nationalID',
    isBlocked: 'isBlocked',
    isDeleted: 'isDeleted',
    emailConfirmed: 'emailConfirmed',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ResetTokenScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    token: 'token',
    userId: 'userId',
    adminId: 'adminId',
    expireAt: 'expireAt'
  };

  export type ResetTokenScalarFieldEnum = (typeof ResetTokenScalarFieldEnum)[keyof typeof ResetTokenScalarFieldEnum]


  export const ConfirmTokenScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    token: 'token',
    userId: 'userId',
    adminId: 'adminId',
    expireAt: 'expireAt'
  };

  export type ConfirmTokenScalarFieldEnum = (typeof ConfirmTokenScalarFieldEnum)[keyof typeof ConfirmTokenScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    token: 'token',
    userId: 'userId',
    adminId: 'adminId',
    expireAt: 'expireAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    roomNum: 'roomNum',
    types: 'types',
    price: 'price',
    description: 'description',
    aminities: 'aminities',
    images: 'images',
    view: 'view',
    isDeleted: 'isDeleted'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const RoomReservationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roomId: 'roomId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    checkIn: 'checkIn',
    checkOut: 'checkOut',
    adults: 'adults',
    children: 'children',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt'
  };

  export type RoomReservationScalarFieldEnum = (typeof RoomReservationScalarFieldEnum)[keyof typeof RoomReservationScalarFieldEnum]


  export const ExtraServicesScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    price: 'price',
    facilities: 'facilities',
    isDeleted: 'isDeleted'
  };

  export type ExtraServicesScalarFieldEnum = (typeof ExtraServicesScalarFieldEnum)[keyof typeof ExtraServicesScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rating: 'rating',
    comment: 'comment',
    isDeleted: 'isDeleted'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const RestaurantScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description'
  };

  export type RestaurantScalarFieldEnum = (typeof RestaurantScalarFieldEnum)[keyof typeof RestaurantScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    restaurantId: 'restaurantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    menuTypes: 'menuTypes',
    name: 'name',
    ingredients: 'ingredients',
    price: 'price',
    image: 'image',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const ClubHouseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clubhouseTypes: 'clubhouseTypes',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    isDeleted: 'isDeleted'
  };

  export type ClubHouseScalarFieldEnum = (typeof ClubHouseScalarFieldEnum)[keyof typeof ClubHouseScalarFieldEnum]


  export const FAQSScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    question: 'question',
    answer: 'answer',
    isDeleted: 'isDeleted'
  };

  export type FAQSScalarFieldEnum = (typeof FAQSScalarFieldEnum)[keyof typeof FAQSScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    title: 'title',
    subTitle: 'subTitle',
    description: 'description',
    images: 'images',
    isDeleted: 'isDeleted'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const ReplyScalarFieldEnum: {
    id: 'id',
    newsId: 'newsId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fullName: 'fullName',
    email: 'email',
    comment: 'comment',
    isDeleted: 'isDeleted'
  };

  export type ReplyScalarFieldEnum = (typeof ReplyScalarFieldEnum)[keyof typeof ReplyScalarFieldEnum]


  export const ContactUsScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fullName: 'fullName',
    email: 'email',
    phoneNum: 'phoneNum',
    subject: 'subject',
    description: 'description',
    isDeleted: 'isDeleted',
    isRead: 'isRead'
  };

  export type ContactUsScalarFieldEnum = (typeof ContactUsScalarFieldEnum)[keyof typeof ContactUsScalarFieldEnum]


  export const AppSettingsScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hotelName: 'hotelName',
    logo: 'logo',
    address: 'address',
    phoneNum: 'phoneNum',
    email: 'email',
    socialMedia: 'socialMedia'
  };

  export type AppSettingsScalarFieldEnum = (typeof AppSettingsScalarFieldEnum)[keyof typeof AppSettingsScalarFieldEnum]


  export const HomeSlidersScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    photo: 'photo',
    header: 'header',
    paragraph: 'paragraph',
    isDeleted: 'isDeleted'
  };

  export type HomeSlidersScalarFieldEnum = (typeof HomeSlidersScalarFieldEnum)[keyof typeof HomeSlidersScalarFieldEnum]


  export const PromotionVidScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    video: 'video',
    description: 'description'
  };

  export type PromotionVidScalarFieldEnum = (typeof PromotionVidScalarFieldEnum)[keyof typeof PromotionVidScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ROLE'
   */
  export type EnumROLEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ROLE'>
    


  /**
   * Reference to a field of type 'ROLE[]'
   */
  export type ListEnumROLEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ROLE[]'>
    


  /**
   * Reference to a field of type 'RoomTypes'
   */
  export type EnumRoomTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomTypes'>
    


  /**
   * Reference to a field of type 'RoomTypes[]'
   */
  export type ListEnumRoomTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomTypes[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MenuTypes'
   */
  export type EnumMenuTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MenuTypes'>
    


  /**
   * Reference to a field of type 'MenuTypes[]'
   */
  export type ListEnumMenuTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MenuTypes[]'>
    


  /**
   * Reference to a field of type 'clubhouseTypes'
   */
  export type EnumclubhouseTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'clubhouseTypes'>
    


  /**
   * Reference to a field of type 'clubhouseTypes[]'
   */
  export type ListEnumclubhouseTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'clubhouseTypes[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    fullName?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    username?: StringFilter<"Admin"> | string
    profilePic?: StringNullableFilter<"Admin"> | string | null
    birthDate?: DateTimeFilter<"Admin"> | Date | string
    phoneNum?: StringFilter<"Admin"> | string
    isDeleted?: BoolFilter<"Admin"> | boolean
    emailConfirmed?: BoolFilter<"Admin"> | boolean
    role?: EnumROLEFilter<"Admin"> | $Enums.ROLE
    news?: NewsListRelationFilter
    contact?: ContactUsListRelationFilter
    restaurant?: RestaurantListRelationFilter
    AppSettings?: AppSettingsListRelationFilter
    ResetToken?: XOR<ResetTokenNullableRelationFilter, ResetTokenWhereInput> | null
    ConfirmToken?: XOR<ConfirmTokenNullableRelationFilter, ConfirmTokenWhereInput> | null
    RefreshToken?: XOR<RefreshTokenNullableRelationFilter, RefreshTokenWhereInput> | null
    HomeSliders?: HomeSlidersListRelationFilter
    PromotionVid?: XOR<PromotionVidNullableRelationFilter, PromotionVidWhereInput> | null
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profilePic?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    phoneNum?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
    news?: NewsOrderByRelationAggregateInput
    contact?: ContactUsOrderByRelationAggregateInput
    restaurant?: RestaurantOrderByRelationAggregateInput
    AppSettings?: AppSettingsOrderByRelationAggregateInput
    ResetToken?: ResetTokenOrderByWithRelationInput
    ConfirmToken?: ConfirmTokenOrderByWithRelationInput
    RefreshToken?: RefreshTokenOrderByWithRelationInput
    HomeSliders?: HomeSlidersOrderByRelationAggregateInput
    PromotionVid?: PromotionVidOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    phoneNum?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    fullName?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    profilePic?: StringNullableFilter<"Admin"> | string | null
    birthDate?: DateTimeFilter<"Admin"> | Date | string
    isDeleted?: BoolFilter<"Admin"> | boolean
    emailConfirmed?: BoolFilter<"Admin"> | boolean
    role?: EnumROLEFilter<"Admin"> | $Enums.ROLE
    news?: NewsListRelationFilter
    contact?: ContactUsListRelationFilter
    restaurant?: RestaurantListRelationFilter
    AppSettings?: AppSettingsListRelationFilter
    ResetToken?: XOR<ResetTokenNullableRelationFilter, ResetTokenWhereInput> | null
    ConfirmToken?: XOR<ConfirmTokenNullableRelationFilter, ConfirmTokenWhereInput> | null
    RefreshToken?: XOR<RefreshTokenNullableRelationFilter, RefreshTokenWhereInput> | null
    HomeSliders?: HomeSlidersListRelationFilter
    PromotionVid?: XOR<PromotionVidNullableRelationFilter, PromotionVidWhereInput> | null
  }, "id" | "email" | "username" | "phoneNum">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profilePic?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    phoneNum?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    fullName?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    username?: StringWithAggregatesFilter<"Admin"> | string
    profilePic?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    birthDate?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    phoneNum?: StringWithAggregatesFilter<"Admin"> | string
    isDeleted?: BoolWithAggregatesFilter<"Admin"> | boolean
    emailConfirmed?: BoolWithAggregatesFilter<"Admin"> | boolean
    role?: EnumROLEWithAggregatesFilter<"Admin"> | $Enums.ROLE
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    fName?: StringFilter<"User"> | string
    lName?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profilePic?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeFilter<"User"> | Date | string
    country?: StringFilter<"User"> | string
    nationalID?: StringFilter<"User"> | string
    isBlocked?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    emailConfirmed?: BoolFilter<"User"> | boolean
    role?: EnumROLEFilter<"User"> | $Enums.ROLE
    room?: RoomReservationListRelationFilter
    review?: XOR<ReviewNullableRelationFilter, ReviewWhereInput> | null
    menu?: MenuListRelationFilter
    clubHouse?: ClubHouseListRelationFilter
    ResetToken?: XOR<ResetTokenNullableRelationFilter, ResetTokenWhereInput> | null
    ConfirmToken?: XOR<ConfirmTokenNullableRelationFilter, ConfirmTokenWhereInput> | null
    RefreshToken?: XOR<RefreshTokenNullableRelationFilter, RefreshTokenWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fName?: SortOrder
    lName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profilePic?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    nationalID?: SortOrder
    isBlocked?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
    room?: RoomReservationOrderByRelationAggregateInput
    review?: ReviewOrderByWithRelationInput
    menu?: MenuOrderByRelationAggregateInput
    clubHouse?: ClubHouseOrderByRelationAggregateInput
    ResetToken?: ResetTokenOrderByWithRelationInput
    ConfirmToken?: ConfirmTokenOrderByWithRelationInput
    RefreshToken?: RefreshTokenOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    nationalID?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    fName?: StringFilter<"User"> | string
    lName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profilePic?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeFilter<"User"> | Date | string
    country?: StringFilter<"User"> | string
    isBlocked?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    emailConfirmed?: BoolFilter<"User"> | boolean
    role?: EnumROLEFilter<"User"> | $Enums.ROLE
    room?: RoomReservationListRelationFilter
    review?: XOR<ReviewNullableRelationFilter, ReviewWhereInput> | null
    menu?: MenuListRelationFilter
    clubHouse?: ClubHouseListRelationFilter
    ResetToken?: XOR<ResetTokenNullableRelationFilter, ResetTokenWhereInput> | null
    ConfirmToken?: XOR<ConfirmTokenNullableRelationFilter, ConfirmTokenWhereInput> | null
    RefreshToken?: XOR<RefreshTokenNullableRelationFilter, RefreshTokenWhereInput> | null
  }, "id" | "username" | "email" | "nationalID">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fName?: SortOrder
    lName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profilePic?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    nationalID?: SortOrder
    isBlocked?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    fName?: StringWithAggregatesFilter<"User"> | string
    lName?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    profilePic?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: DateTimeWithAggregatesFilter<"User"> | Date | string
    country?: StringWithAggregatesFilter<"User"> | string
    nationalID?: StringWithAggregatesFilter<"User"> | string
    isBlocked?: BoolWithAggregatesFilter<"User"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    emailConfirmed?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumROLEWithAggregatesFilter<"User"> | $Enums.ROLE
  }

  export type ResetTokenWhereInput = {
    AND?: ResetTokenWhereInput | ResetTokenWhereInput[]
    OR?: ResetTokenWhereInput[]
    NOT?: ResetTokenWhereInput | ResetTokenWhereInput[]
    id?: StringFilter<"ResetToken"> | string
    createdAt?: DateTimeFilter<"ResetToken"> | Date | string
    token?: StringFilter<"ResetToken"> | string
    userId?: StringNullableFilter<"ResetToken"> | string | null
    adminId?: StringNullableFilter<"ResetToken"> | string | null
    expireAt?: DateTimeFilter<"ResetToken"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }

  export type ResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    expireAt?: SortOrder
    user?: UserOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type ResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    adminId?: string
    AND?: ResetTokenWhereInput | ResetTokenWhereInput[]
    OR?: ResetTokenWhereInput[]
    NOT?: ResetTokenWhereInput | ResetTokenWhereInput[]
    createdAt?: DateTimeFilter<"ResetToken"> | Date | string
    token?: StringFilter<"ResetToken"> | string
    expireAt?: DateTimeFilter<"ResetToken"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }, "id" | "userId" | "adminId">

  export type ResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    expireAt?: SortOrder
    _count?: ResetTokenCountOrderByAggregateInput
    _max?: ResetTokenMaxOrderByAggregateInput
    _min?: ResetTokenMinOrderByAggregateInput
  }

  export type ResetTokenScalarWhereWithAggregatesInput = {
    AND?: ResetTokenScalarWhereWithAggregatesInput | ResetTokenScalarWhereWithAggregatesInput[]
    OR?: ResetTokenScalarWhereWithAggregatesInput[]
    NOT?: ResetTokenScalarWhereWithAggregatesInput | ResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResetToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ResetToken"> | Date | string
    token?: StringWithAggregatesFilter<"ResetToken"> | string
    userId?: StringNullableWithAggregatesFilter<"ResetToken"> | string | null
    adminId?: StringNullableWithAggregatesFilter<"ResetToken"> | string | null
    expireAt?: DateTimeWithAggregatesFilter<"ResetToken"> | Date | string
  }

  export type ConfirmTokenWhereInput = {
    AND?: ConfirmTokenWhereInput | ConfirmTokenWhereInput[]
    OR?: ConfirmTokenWhereInput[]
    NOT?: ConfirmTokenWhereInput | ConfirmTokenWhereInput[]
    id?: StringFilter<"ConfirmToken"> | string
    createdAt?: DateTimeFilter<"ConfirmToken"> | Date | string
    token?: StringFilter<"ConfirmToken"> | string
    userId?: StringNullableFilter<"ConfirmToken"> | string | null
    adminId?: StringNullableFilter<"ConfirmToken"> | string | null
    expireAt?: DateTimeFilter<"ConfirmToken"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }

  export type ConfirmTokenOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    expireAt?: SortOrder
    user?: UserOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type ConfirmTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    adminId?: string
    AND?: ConfirmTokenWhereInput | ConfirmTokenWhereInput[]
    OR?: ConfirmTokenWhereInput[]
    NOT?: ConfirmTokenWhereInput | ConfirmTokenWhereInput[]
    createdAt?: DateTimeFilter<"ConfirmToken"> | Date | string
    token?: StringFilter<"ConfirmToken"> | string
    expireAt?: DateTimeFilter<"ConfirmToken"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }, "id" | "userId" | "adminId">

  export type ConfirmTokenOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    expireAt?: SortOrder
    _count?: ConfirmTokenCountOrderByAggregateInput
    _max?: ConfirmTokenMaxOrderByAggregateInput
    _min?: ConfirmTokenMinOrderByAggregateInput
  }

  export type ConfirmTokenScalarWhereWithAggregatesInput = {
    AND?: ConfirmTokenScalarWhereWithAggregatesInput | ConfirmTokenScalarWhereWithAggregatesInput[]
    OR?: ConfirmTokenScalarWhereWithAggregatesInput[]
    NOT?: ConfirmTokenScalarWhereWithAggregatesInput | ConfirmTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConfirmToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConfirmToken"> | Date | string
    token?: StringWithAggregatesFilter<"ConfirmToken"> | string
    userId?: StringNullableWithAggregatesFilter<"ConfirmToken"> | string | null
    adminId?: StringNullableWithAggregatesFilter<"ConfirmToken"> | string | null
    expireAt?: DateTimeWithAggregatesFilter<"ConfirmToken"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringNullableFilter<"RefreshToken"> | string | null
    adminId?: StringNullableFilter<"RefreshToken"> | string | null
    expireAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    expireAt?: SortOrder
    user?: UserOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    adminId?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    token?: StringFilter<"RefreshToken"> | string
    expireAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }, "id" | "userId" | "adminId">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    expireAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    adminId?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    expireAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    roomNum?: StringFilter<"Room"> | string
    types?: EnumRoomTypesFilter<"Room"> | $Enums.RoomTypes
    price?: StringFilter<"Room"> | string
    description?: StringFilter<"Room"> | string
    aminities?: StringNullableListFilter<"Room">
    images?: StringNullableListFilter<"Room">
    view?: StringFilter<"Room"> | string
    isDeleted?: BoolFilter<"Room"> | boolean
    extraServices?: ExtraServicesListRelationFilter
    user?: RoomReservationListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roomNum?: SortOrder
    types?: SortOrder
    price?: SortOrder
    description?: SortOrder
    aminities?: SortOrder
    images?: SortOrder
    view?: SortOrder
    isDeleted?: SortOrder
    extraServices?: ExtraServicesOrderByRelationAggregateInput
    user?: RoomReservationOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomNum?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    types?: EnumRoomTypesFilter<"Room"> | $Enums.RoomTypes
    price?: StringFilter<"Room"> | string
    description?: StringFilter<"Room"> | string
    aminities?: StringNullableListFilter<"Room">
    images?: StringNullableListFilter<"Room">
    view?: StringFilter<"Room"> | string
    isDeleted?: BoolFilter<"Room"> | boolean
    extraServices?: ExtraServicesListRelationFilter
    user?: RoomReservationListRelationFilter
  }, "id" | "roomNum">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roomNum?: SortOrder
    types?: SortOrder
    price?: SortOrder
    description?: SortOrder
    aminities?: SortOrder
    images?: SortOrder
    view?: SortOrder
    isDeleted?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    roomNum?: StringWithAggregatesFilter<"Room"> | string
    types?: EnumRoomTypesWithAggregatesFilter<"Room"> | $Enums.RoomTypes
    price?: StringWithAggregatesFilter<"Room"> | string
    description?: StringWithAggregatesFilter<"Room"> | string
    aminities?: StringNullableListFilter<"Room">
    images?: StringNullableListFilter<"Room">
    view?: StringWithAggregatesFilter<"Room"> | string
    isDeleted?: BoolWithAggregatesFilter<"Room"> | boolean
  }

  export type RoomReservationWhereInput = {
    AND?: RoomReservationWhereInput | RoomReservationWhereInput[]
    OR?: RoomReservationWhereInput[]
    NOT?: RoomReservationWhereInput | RoomReservationWhereInput[]
    id?: StringFilter<"RoomReservation"> | string
    userId?: StringFilter<"RoomReservation"> | string
    roomId?: StringFilter<"RoomReservation"> | string
    createdAt?: DateTimeFilter<"RoomReservation"> | Date | string
    updatedAt?: DateTimeFilter<"RoomReservation"> | Date | string
    checkIn?: DateTimeFilter<"RoomReservation"> | Date | string
    checkOut?: DateTimeFilter<"RoomReservation"> | Date | string
    adults?: IntFilter<"RoomReservation"> | number
    children?: IntFilter<"RoomReservation"> | number
    isDeleted?: BoolFilter<"RoomReservation"> | boolean
    deletedAt?: DateTimeNullableFilter<"RoomReservation"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }

  export type RoomReservationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
  }

  export type RoomReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomId_userId?: RoomReservationRoomIdUserIdCompoundUniqueInput
    AND?: RoomReservationWhereInput | RoomReservationWhereInput[]
    OR?: RoomReservationWhereInput[]
    NOT?: RoomReservationWhereInput | RoomReservationWhereInput[]
    userId?: StringFilter<"RoomReservation"> | string
    roomId?: StringFilter<"RoomReservation"> | string
    createdAt?: DateTimeFilter<"RoomReservation"> | Date | string
    updatedAt?: DateTimeFilter<"RoomReservation"> | Date | string
    checkIn?: DateTimeFilter<"RoomReservation"> | Date | string
    checkOut?: DateTimeFilter<"RoomReservation"> | Date | string
    adults?: IntFilter<"RoomReservation"> | number
    children?: IntFilter<"RoomReservation"> | number
    isDeleted?: BoolFilter<"RoomReservation"> | boolean
    deletedAt?: DateTimeNullableFilter<"RoomReservation"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }, "id" | "roomId_userId">

  export type RoomReservationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RoomReservationCountOrderByAggregateInput
    _avg?: RoomReservationAvgOrderByAggregateInput
    _max?: RoomReservationMaxOrderByAggregateInput
    _min?: RoomReservationMinOrderByAggregateInput
    _sum?: RoomReservationSumOrderByAggregateInput
  }

  export type RoomReservationScalarWhereWithAggregatesInput = {
    AND?: RoomReservationScalarWhereWithAggregatesInput | RoomReservationScalarWhereWithAggregatesInput[]
    OR?: RoomReservationScalarWhereWithAggregatesInput[]
    NOT?: RoomReservationScalarWhereWithAggregatesInput | RoomReservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomReservation"> | string
    userId?: StringWithAggregatesFilter<"RoomReservation"> | string
    roomId?: StringWithAggregatesFilter<"RoomReservation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RoomReservation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomReservation"> | Date | string
    checkIn?: DateTimeWithAggregatesFilter<"RoomReservation"> | Date | string
    checkOut?: DateTimeWithAggregatesFilter<"RoomReservation"> | Date | string
    adults?: IntWithAggregatesFilter<"RoomReservation"> | number
    children?: IntWithAggregatesFilter<"RoomReservation"> | number
    isDeleted?: BoolWithAggregatesFilter<"RoomReservation"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RoomReservation"> | Date | string | null
  }

  export type ExtraServicesWhereInput = {
    AND?: ExtraServicesWhereInput | ExtraServicesWhereInput[]
    OR?: ExtraServicesWhereInput[]
    NOT?: ExtraServicesWhereInput | ExtraServicesWhereInput[]
    id?: StringFilter<"ExtraServices"> | string
    roomId?: StringFilter<"ExtraServices"> | string
    createdAt?: DateTimeFilter<"ExtraServices"> | Date | string
    updatedAt?: DateTimeFilter<"ExtraServices"> | Date | string
    name?: StringFilter<"ExtraServices"> | string
    price?: StringFilter<"ExtraServices"> | string
    facilities?: StringNullableListFilter<"ExtraServices">
    isDeleted?: BoolFilter<"ExtraServices"> | boolean
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }

  export type ExtraServicesOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    price?: SortOrder
    facilities?: SortOrder
    isDeleted?: SortOrder
    room?: RoomOrderByWithRelationInput
  }

  export type ExtraServicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExtraServicesWhereInput | ExtraServicesWhereInput[]
    OR?: ExtraServicesWhereInput[]
    NOT?: ExtraServicesWhereInput | ExtraServicesWhereInput[]
    roomId?: StringFilter<"ExtraServices"> | string
    createdAt?: DateTimeFilter<"ExtraServices"> | Date | string
    updatedAt?: DateTimeFilter<"ExtraServices"> | Date | string
    name?: StringFilter<"ExtraServices"> | string
    price?: StringFilter<"ExtraServices"> | string
    facilities?: StringNullableListFilter<"ExtraServices">
    isDeleted?: BoolFilter<"ExtraServices"> | boolean
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }, "id">

  export type ExtraServicesOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    price?: SortOrder
    facilities?: SortOrder
    isDeleted?: SortOrder
    _count?: ExtraServicesCountOrderByAggregateInput
    _max?: ExtraServicesMaxOrderByAggregateInput
    _min?: ExtraServicesMinOrderByAggregateInput
  }

  export type ExtraServicesScalarWhereWithAggregatesInput = {
    AND?: ExtraServicesScalarWhereWithAggregatesInput | ExtraServicesScalarWhereWithAggregatesInput[]
    OR?: ExtraServicesScalarWhereWithAggregatesInput[]
    NOT?: ExtraServicesScalarWhereWithAggregatesInput | ExtraServicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExtraServices"> | string
    roomId?: StringWithAggregatesFilter<"ExtraServices"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExtraServices"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExtraServices"> | Date | string
    name?: StringWithAggregatesFilter<"ExtraServices"> | string
    price?: StringWithAggregatesFilter<"ExtraServices"> | string
    facilities?: StringNullableListFilter<"ExtraServices">
    isDeleted?: BoolWithAggregatesFilter<"ExtraServices"> | boolean
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    rating?: FloatFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    isDeleted?: BoolFilter<"Review"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    rating?: FloatFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    isDeleted?: BoolFilter<"Review"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    rating?: FloatWithAggregatesFilter<"Review"> | number
    comment?: StringWithAggregatesFilter<"Review"> | string
    isDeleted?: BoolWithAggregatesFilter<"Review"> | boolean
  }

  export type RestaurantWhereInput = {
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    id?: StringFilter<"Restaurant"> | string
    adminId?: StringFilter<"Restaurant"> | string
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    description?: StringFilter<"Restaurant"> | string
    user?: XOR<AdminRelationFilter, AdminWhereInput>
    menu?: MenuListRelationFilter
  }

  export type RestaurantOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    user?: AdminOrderByWithRelationInput
    menu?: MenuOrderByRelationAggregateInput
  }

  export type RestaurantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    adminId?: StringFilter<"Restaurant"> | string
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    description?: StringFilter<"Restaurant"> | string
    user?: XOR<AdminRelationFilter, AdminWhereInput>
    menu?: MenuListRelationFilter
  }, "id">

  export type RestaurantOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    _count?: RestaurantCountOrderByAggregateInput
    _max?: RestaurantMaxOrderByAggregateInput
    _min?: RestaurantMinOrderByAggregateInput
  }

  export type RestaurantScalarWhereWithAggregatesInput = {
    AND?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    OR?: RestaurantScalarWhereWithAggregatesInput[]
    NOT?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Restaurant"> | string
    adminId?: StringWithAggregatesFilter<"Restaurant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Restaurant"> | Date | string
    description?: StringWithAggregatesFilter<"Restaurant"> | string
  }

  export type MenuWhereInput = {
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    id?: StringFilter<"Menu"> | string
    userId?: StringFilter<"Menu"> | string
    restaurantId?: StringFilter<"Menu"> | string
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    menuTypes?: EnumMenuTypesFilter<"Menu"> | $Enums.MenuTypes
    name?: StringFilter<"Menu"> | string
    ingredients?: StringFilter<"Menu"> | string
    price?: StringFilter<"Menu"> | string
    image?: StringFilter<"Menu"> | string
    isDeleted?: BoolFilter<"Menu"> | boolean
    deletedAt?: DateTimeNullableFilter<"Menu"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuTypes?: SortOrder
    name?: SortOrder
    ingredients?: SortOrder
    price?: SortOrder
    image?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    restaurant?: RestaurantOrderByWithRelationInput
  }

  export type MenuWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    userId?: StringFilter<"Menu"> | string
    restaurantId?: StringFilter<"Menu"> | string
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    menuTypes?: EnumMenuTypesFilter<"Menu"> | $Enums.MenuTypes
    name?: StringFilter<"Menu"> | string
    ingredients?: StringFilter<"Menu"> | string
    price?: StringFilter<"Menu"> | string
    image?: StringFilter<"Menu"> | string
    isDeleted?: BoolFilter<"Menu"> | boolean
    deletedAt?: DateTimeNullableFilter<"Menu"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
  }, "id">

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuTypes?: SortOrder
    name?: SortOrder
    ingredients?: SortOrder
    price?: SortOrder
    image?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MenuCountOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    OR?: MenuScalarWhereWithAggregatesInput[]
    NOT?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Menu"> | string
    userId?: StringWithAggregatesFilter<"Menu"> | string
    restaurantId?: StringWithAggregatesFilter<"Menu"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    menuTypes?: EnumMenuTypesWithAggregatesFilter<"Menu"> | $Enums.MenuTypes
    name?: StringWithAggregatesFilter<"Menu"> | string
    ingredients?: StringWithAggregatesFilter<"Menu"> | string
    price?: StringWithAggregatesFilter<"Menu"> | string
    image?: StringWithAggregatesFilter<"Menu"> | string
    isDeleted?: BoolWithAggregatesFilter<"Menu"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Menu"> | Date | string | null
  }

  export type ClubHouseWhereInput = {
    AND?: ClubHouseWhereInput | ClubHouseWhereInput[]
    OR?: ClubHouseWhereInput[]
    NOT?: ClubHouseWhereInput | ClubHouseWhereInput[]
    id?: StringFilter<"ClubHouse"> | string
    userId?: StringFilter<"ClubHouse"> | string
    createdAt?: DateTimeFilter<"ClubHouse"> | Date | string
    updatedAt?: DateTimeFilter<"ClubHouse"> | Date | string
    clubhouseTypes?: EnumclubhouseTypesFilter<"ClubHouse"> | $Enums.clubhouseTypes
    description?: StringFilter<"ClubHouse"> | string
    startTime?: DateTimeFilter<"ClubHouse"> | Date | string
    endTime?: DateTimeFilter<"ClubHouse"> | Date | string
    isDeleted?: BoolFilter<"ClubHouse"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ClubHouseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clubhouseTypes?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isDeleted?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ClubHouseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClubHouseWhereInput | ClubHouseWhereInput[]
    OR?: ClubHouseWhereInput[]
    NOT?: ClubHouseWhereInput | ClubHouseWhereInput[]
    userId?: StringFilter<"ClubHouse"> | string
    createdAt?: DateTimeFilter<"ClubHouse"> | Date | string
    updatedAt?: DateTimeFilter<"ClubHouse"> | Date | string
    clubhouseTypes?: EnumclubhouseTypesFilter<"ClubHouse"> | $Enums.clubhouseTypes
    description?: StringFilter<"ClubHouse"> | string
    startTime?: DateTimeFilter<"ClubHouse"> | Date | string
    endTime?: DateTimeFilter<"ClubHouse"> | Date | string
    isDeleted?: BoolFilter<"ClubHouse"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ClubHouseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clubhouseTypes?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isDeleted?: SortOrder
    _count?: ClubHouseCountOrderByAggregateInput
    _max?: ClubHouseMaxOrderByAggregateInput
    _min?: ClubHouseMinOrderByAggregateInput
  }

  export type ClubHouseScalarWhereWithAggregatesInput = {
    AND?: ClubHouseScalarWhereWithAggregatesInput | ClubHouseScalarWhereWithAggregatesInput[]
    OR?: ClubHouseScalarWhereWithAggregatesInput[]
    NOT?: ClubHouseScalarWhereWithAggregatesInput | ClubHouseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClubHouse"> | string
    userId?: StringWithAggregatesFilter<"ClubHouse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClubHouse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClubHouse"> | Date | string
    clubhouseTypes?: EnumclubhouseTypesWithAggregatesFilter<"ClubHouse"> | $Enums.clubhouseTypes
    description?: StringWithAggregatesFilter<"ClubHouse"> | string
    startTime?: DateTimeWithAggregatesFilter<"ClubHouse"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"ClubHouse"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"ClubHouse"> | boolean
  }

  export type FAQSWhereInput = {
    AND?: FAQSWhereInput | FAQSWhereInput[]
    OR?: FAQSWhereInput[]
    NOT?: FAQSWhereInput | FAQSWhereInput[]
    id?: StringFilter<"FAQS"> | string
    createdAt?: DateTimeFilter<"FAQS"> | Date | string
    updatedAt?: DateTimeFilter<"FAQS"> | Date | string
    question?: StringFilter<"FAQS"> | string
    answer?: StringFilter<"FAQS"> | string
    isDeleted?: BoolFilter<"FAQS"> | boolean
  }

  export type FAQSOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    isDeleted?: SortOrder
  }

  export type FAQSWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FAQSWhereInput | FAQSWhereInput[]
    OR?: FAQSWhereInput[]
    NOT?: FAQSWhereInput | FAQSWhereInput[]
    createdAt?: DateTimeFilter<"FAQS"> | Date | string
    updatedAt?: DateTimeFilter<"FAQS"> | Date | string
    question?: StringFilter<"FAQS"> | string
    answer?: StringFilter<"FAQS"> | string
    isDeleted?: BoolFilter<"FAQS"> | boolean
  }, "id">

  export type FAQSOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    isDeleted?: SortOrder
    _count?: FAQSCountOrderByAggregateInput
    _max?: FAQSMaxOrderByAggregateInput
    _min?: FAQSMinOrderByAggregateInput
  }

  export type FAQSScalarWhereWithAggregatesInput = {
    AND?: FAQSScalarWhereWithAggregatesInput | FAQSScalarWhereWithAggregatesInput[]
    OR?: FAQSScalarWhereWithAggregatesInput[]
    NOT?: FAQSScalarWhereWithAggregatesInput | FAQSScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FAQS"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FAQS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FAQS"> | Date | string
    question?: StringWithAggregatesFilter<"FAQS"> | string
    answer?: StringWithAggregatesFilter<"FAQS"> | string
    isDeleted?: BoolWithAggregatesFilter<"FAQS"> | boolean
  }

  export type NewsWhereInput = {
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    id?: StringFilter<"News"> | string
    adminId?: StringFilter<"News"> | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
    title?: StringFilter<"News"> | string
    subTitle?: StringFilter<"News"> | string
    description?: StringFilter<"News"> | string
    images?: StringNullableListFilter<"News">
    isDeleted?: BoolFilter<"News"> | boolean
    admin?: XOR<AdminRelationFilter, AdminWhereInput>
    replies?: ReplyListRelationFilter
  }

  export type NewsOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    description?: SortOrder
    images?: SortOrder
    isDeleted?: SortOrder
    admin?: AdminOrderByWithRelationInput
    replies?: ReplyOrderByRelationAggregateInput
  }

  export type NewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    adminId?: StringFilter<"News"> | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
    title?: StringFilter<"News"> | string
    subTitle?: StringFilter<"News"> | string
    description?: StringFilter<"News"> | string
    images?: StringNullableListFilter<"News">
    isDeleted?: BoolFilter<"News"> | boolean
    admin?: XOR<AdminRelationFilter, AdminWhereInput>
    replies?: ReplyListRelationFilter
  }, "id">

  export type NewsOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    description?: SortOrder
    images?: SortOrder
    isDeleted?: SortOrder
    _count?: NewsCountOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    OR?: NewsScalarWhereWithAggregatesInput[]
    NOT?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"News"> | string
    adminId?: StringWithAggregatesFilter<"News"> | string
    createdAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    title?: StringWithAggregatesFilter<"News"> | string
    subTitle?: StringWithAggregatesFilter<"News"> | string
    description?: StringWithAggregatesFilter<"News"> | string
    images?: StringNullableListFilter<"News">
    isDeleted?: BoolWithAggregatesFilter<"News"> | boolean
  }

  export type ReplyWhereInput = {
    AND?: ReplyWhereInput | ReplyWhereInput[]
    OR?: ReplyWhereInput[]
    NOT?: ReplyWhereInput | ReplyWhereInput[]
    id?: StringFilter<"Reply"> | string
    newsId?: StringFilter<"Reply"> | string
    createdAt?: DateTimeFilter<"Reply"> | Date | string
    updatedAt?: DateTimeFilter<"Reply"> | Date | string
    fullName?: StringFilter<"Reply"> | string
    email?: StringFilter<"Reply"> | string
    comment?: StringFilter<"Reply"> | string
    isDeleted?: BoolFilter<"Reply"> | boolean
    news?: XOR<NewsRelationFilter, NewsWhereInput>
  }

  export type ReplyOrderByWithRelationInput = {
    id?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
    news?: NewsOrderByWithRelationInput
  }

  export type ReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReplyWhereInput | ReplyWhereInput[]
    OR?: ReplyWhereInput[]
    NOT?: ReplyWhereInput | ReplyWhereInput[]
    newsId?: StringFilter<"Reply"> | string
    createdAt?: DateTimeFilter<"Reply"> | Date | string
    updatedAt?: DateTimeFilter<"Reply"> | Date | string
    fullName?: StringFilter<"Reply"> | string
    email?: StringFilter<"Reply"> | string
    comment?: StringFilter<"Reply"> | string
    isDeleted?: BoolFilter<"Reply"> | boolean
    news?: XOR<NewsRelationFilter, NewsWhereInput>
  }, "id">

  export type ReplyOrderByWithAggregationInput = {
    id?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
    _count?: ReplyCountOrderByAggregateInput
    _max?: ReplyMaxOrderByAggregateInput
    _min?: ReplyMinOrderByAggregateInput
  }

  export type ReplyScalarWhereWithAggregatesInput = {
    AND?: ReplyScalarWhereWithAggregatesInput | ReplyScalarWhereWithAggregatesInput[]
    OR?: ReplyScalarWhereWithAggregatesInput[]
    NOT?: ReplyScalarWhereWithAggregatesInput | ReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reply"> | string
    newsId?: StringWithAggregatesFilter<"Reply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Reply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reply"> | Date | string
    fullName?: StringWithAggregatesFilter<"Reply"> | string
    email?: StringWithAggregatesFilter<"Reply"> | string
    comment?: StringWithAggregatesFilter<"Reply"> | string
    isDeleted?: BoolWithAggregatesFilter<"Reply"> | boolean
  }

  export type ContactUsWhereInput = {
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    id?: StringFilter<"ContactUs"> | string
    adminId?: StringNullableFilter<"ContactUs"> | string | null
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeFilter<"ContactUs"> | Date | string
    fullName?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    phoneNum?: StringFilter<"ContactUs"> | string
    subject?: StringFilter<"ContactUs"> | string
    description?: StringFilter<"ContactUs"> | string
    isDeleted?: BoolFilter<"ContactUs"> | boolean
    isRead?: BoolFilter<"ContactUs"> | boolean
    byAdmin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }

  export type ContactUsOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phoneNum?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    isRead?: SortOrder
    byAdmin?: AdminOrderByWithRelationInput
  }

  export type ContactUsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    adminId?: StringNullableFilter<"ContactUs"> | string | null
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeFilter<"ContactUs"> | Date | string
    fullName?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    phoneNum?: StringFilter<"ContactUs"> | string
    subject?: StringFilter<"ContactUs"> | string
    description?: StringFilter<"ContactUs"> | string
    isDeleted?: BoolFilter<"ContactUs"> | boolean
    isRead?: BoolFilter<"ContactUs"> | boolean
    byAdmin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }, "id">

  export type ContactUsOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phoneNum?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    isRead?: SortOrder
    _count?: ContactUsCountOrderByAggregateInput
    _max?: ContactUsMaxOrderByAggregateInput
    _min?: ContactUsMinOrderByAggregateInput
  }

  export type ContactUsScalarWhereWithAggregatesInput = {
    AND?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    OR?: ContactUsScalarWhereWithAggregatesInput[]
    NOT?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactUs"> | string
    adminId?: StringNullableWithAggregatesFilter<"ContactUs"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactUs"> | Date | string
    fullName?: StringWithAggregatesFilter<"ContactUs"> | string
    email?: StringWithAggregatesFilter<"ContactUs"> | string
    phoneNum?: StringWithAggregatesFilter<"ContactUs"> | string
    subject?: StringWithAggregatesFilter<"ContactUs"> | string
    description?: StringWithAggregatesFilter<"ContactUs"> | string
    isDeleted?: BoolWithAggregatesFilter<"ContactUs"> | boolean
    isRead?: BoolWithAggregatesFilter<"ContactUs"> | boolean
  }

  export type AppSettingsWhereInput = {
    AND?: AppSettingsWhereInput | AppSettingsWhereInput[]
    OR?: AppSettingsWhereInput[]
    NOT?: AppSettingsWhereInput | AppSettingsWhereInput[]
    id?: StringFilter<"AppSettings"> | string
    adminId?: StringFilter<"AppSettings"> | string
    createdAt?: DateTimeFilter<"AppSettings"> | Date | string
    updatedAt?: DateTimeFilter<"AppSettings"> | Date | string
    hotelName?: StringFilter<"AppSettings"> | string
    logo?: StringFilter<"AppSettings"> | string
    address?: StringFilter<"AppSettings"> | string
    phoneNum?: StringFilter<"AppSettings"> | string
    email?: StringFilter<"AppSettings"> | string
    socialMedia?: JsonFilter<"AppSettings">
    admin?: XOR<AdminRelationFilter, AdminWhereInput>
  }

  export type AppSettingsOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelName?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    phoneNum?: SortOrder
    email?: SortOrder
    socialMedia?: SortOrder
    admin?: AdminOrderByWithRelationInput
  }

  export type AppSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppSettingsWhereInput | AppSettingsWhereInput[]
    OR?: AppSettingsWhereInput[]
    NOT?: AppSettingsWhereInput | AppSettingsWhereInput[]
    adminId?: StringFilter<"AppSettings"> | string
    createdAt?: DateTimeFilter<"AppSettings"> | Date | string
    updatedAt?: DateTimeFilter<"AppSettings"> | Date | string
    hotelName?: StringFilter<"AppSettings"> | string
    logo?: StringFilter<"AppSettings"> | string
    address?: StringFilter<"AppSettings"> | string
    phoneNum?: StringFilter<"AppSettings"> | string
    email?: StringFilter<"AppSettings"> | string
    socialMedia?: JsonFilter<"AppSettings">
    admin?: XOR<AdminRelationFilter, AdminWhereInput>
  }, "id">

  export type AppSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelName?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    phoneNum?: SortOrder
    email?: SortOrder
    socialMedia?: SortOrder
    _count?: AppSettingsCountOrderByAggregateInput
    _max?: AppSettingsMaxOrderByAggregateInput
    _min?: AppSettingsMinOrderByAggregateInput
  }

  export type AppSettingsScalarWhereWithAggregatesInput = {
    AND?: AppSettingsScalarWhereWithAggregatesInput | AppSettingsScalarWhereWithAggregatesInput[]
    OR?: AppSettingsScalarWhereWithAggregatesInput[]
    NOT?: AppSettingsScalarWhereWithAggregatesInput | AppSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppSettings"> | string
    adminId?: StringWithAggregatesFilter<"AppSettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AppSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AppSettings"> | Date | string
    hotelName?: StringWithAggregatesFilter<"AppSettings"> | string
    logo?: StringWithAggregatesFilter<"AppSettings"> | string
    address?: StringWithAggregatesFilter<"AppSettings"> | string
    phoneNum?: StringWithAggregatesFilter<"AppSettings"> | string
    email?: StringWithAggregatesFilter<"AppSettings"> | string
    socialMedia?: JsonWithAggregatesFilter<"AppSettings">
  }

  export type HomeSlidersWhereInput = {
    AND?: HomeSlidersWhereInput | HomeSlidersWhereInput[]
    OR?: HomeSlidersWhereInput[]
    NOT?: HomeSlidersWhereInput | HomeSlidersWhereInput[]
    id?: StringFilter<"HomeSliders"> | string
    adminId?: StringFilter<"HomeSliders"> | string
    createdAt?: DateTimeFilter<"HomeSliders"> | Date | string
    updatedAt?: DateTimeFilter<"HomeSliders"> | Date | string
    photo?: StringFilter<"HomeSliders"> | string
    header?: StringFilter<"HomeSliders"> | string
    paragraph?: StringFilter<"HomeSliders"> | string
    isDeleted?: BoolFilter<"HomeSliders"> | boolean
    byAdmin?: XOR<AdminRelationFilter, AdminWhereInput>
  }

  export type HomeSlidersOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrder
    header?: SortOrder
    paragraph?: SortOrder
    isDeleted?: SortOrder
    byAdmin?: AdminOrderByWithRelationInput
  }

  export type HomeSlidersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HomeSlidersWhereInput | HomeSlidersWhereInput[]
    OR?: HomeSlidersWhereInput[]
    NOT?: HomeSlidersWhereInput | HomeSlidersWhereInput[]
    adminId?: StringFilter<"HomeSliders"> | string
    createdAt?: DateTimeFilter<"HomeSliders"> | Date | string
    updatedAt?: DateTimeFilter<"HomeSliders"> | Date | string
    photo?: StringFilter<"HomeSliders"> | string
    header?: StringFilter<"HomeSliders"> | string
    paragraph?: StringFilter<"HomeSliders"> | string
    isDeleted?: BoolFilter<"HomeSliders"> | boolean
    byAdmin?: XOR<AdminRelationFilter, AdminWhereInput>
  }, "id">

  export type HomeSlidersOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrder
    header?: SortOrder
    paragraph?: SortOrder
    isDeleted?: SortOrder
    _count?: HomeSlidersCountOrderByAggregateInput
    _max?: HomeSlidersMaxOrderByAggregateInput
    _min?: HomeSlidersMinOrderByAggregateInput
  }

  export type HomeSlidersScalarWhereWithAggregatesInput = {
    AND?: HomeSlidersScalarWhereWithAggregatesInput | HomeSlidersScalarWhereWithAggregatesInput[]
    OR?: HomeSlidersScalarWhereWithAggregatesInput[]
    NOT?: HomeSlidersScalarWhereWithAggregatesInput | HomeSlidersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HomeSliders"> | string
    adminId?: StringWithAggregatesFilter<"HomeSliders"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HomeSliders"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HomeSliders"> | Date | string
    photo?: StringWithAggregatesFilter<"HomeSliders"> | string
    header?: StringWithAggregatesFilter<"HomeSliders"> | string
    paragraph?: StringWithAggregatesFilter<"HomeSliders"> | string
    isDeleted?: BoolWithAggregatesFilter<"HomeSliders"> | boolean
  }

  export type PromotionVidWhereInput = {
    AND?: PromotionVidWhereInput | PromotionVidWhereInput[]
    OR?: PromotionVidWhereInput[]
    NOT?: PromotionVidWhereInput | PromotionVidWhereInput[]
    id?: StringFilter<"PromotionVid"> | string
    adminId?: StringFilter<"PromotionVid"> | string
    createdAt?: DateTimeFilter<"PromotionVid"> | Date | string
    updatedAt?: DateTimeFilter<"PromotionVid"> | Date | string
    video?: StringFilter<"PromotionVid"> | string
    description?: StringFilter<"PromotionVid"> | string
    byAdmin?: XOR<AdminRelationFilter, AdminWhereInput>
  }

  export type PromotionVidOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    video?: SortOrder
    description?: SortOrder
    byAdmin?: AdminOrderByWithRelationInput
  }

  export type PromotionVidWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adminId?: string
    AND?: PromotionVidWhereInput | PromotionVidWhereInput[]
    OR?: PromotionVidWhereInput[]
    NOT?: PromotionVidWhereInput | PromotionVidWhereInput[]
    createdAt?: DateTimeFilter<"PromotionVid"> | Date | string
    updatedAt?: DateTimeFilter<"PromotionVid"> | Date | string
    video?: StringFilter<"PromotionVid"> | string
    description?: StringFilter<"PromotionVid"> | string
    byAdmin?: XOR<AdminRelationFilter, AdminWhereInput>
  }, "id" | "adminId">

  export type PromotionVidOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    video?: SortOrder
    description?: SortOrder
    _count?: PromotionVidCountOrderByAggregateInput
    _max?: PromotionVidMaxOrderByAggregateInput
    _min?: PromotionVidMinOrderByAggregateInput
  }

  export type PromotionVidScalarWhereWithAggregatesInput = {
    AND?: PromotionVidScalarWhereWithAggregatesInput | PromotionVidScalarWhereWithAggregatesInput[]
    OR?: PromotionVidScalarWhereWithAggregatesInput[]
    NOT?: PromotionVidScalarWhereWithAggregatesInput | PromotionVidScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromotionVid"> | string
    adminId?: StringWithAggregatesFilter<"PromotionVid"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PromotionVid"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PromotionVid"> | Date | string
    video?: StringWithAggregatesFilter<"PromotionVid"> | string
    description?: StringWithAggregatesFilter<"PromotionVid"> | string
  }

  export type AdminCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsCreateNestedManyWithoutAdminInput
    contact?: ContactUsCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidCreateNestedOneWithoutByAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsUncheckedCreateNestedManyWithoutAdminInput
    contact?: ContactUsUncheckedCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsUncheckedCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidUncheckedCreateNestedOneWithoutByAdminInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUpdateOneWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUncheckedUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUncheckedUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUncheckedUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUncheckedUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedOneWithoutUserInput
    menu?: MenuCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedOneWithoutUserInput
    menu?: MenuUncheckedCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseUncheckedCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateOneWithoutUserNestedInput
    menu?: MenuUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateOneWithoutUserNestedInput
    menu?: MenuUncheckedUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUncheckedUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
  }

  export type ResetTokenCreateInput = {
    id?: string
    createdAt?: Date | string
    token: string
    expireAt: Date | string
    user?: UserCreateNestedOneWithoutResetTokenInput
    admin?: AdminCreateNestedOneWithoutResetTokenInput
  }

  export type ResetTokenUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    token: string
    userId?: string | null
    adminId?: string | null
    expireAt: Date | string
  }

  export type ResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResetTokenNestedInput
    admin?: AdminUpdateOneWithoutResetTokenNestedInput
  }

  export type ResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResetTokenCreateManyInput = {
    id?: string
    createdAt?: Date | string
    token: string
    userId?: string | null
    adminId?: string | null
    expireAt: Date | string
  }

  export type ResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfirmTokenCreateInput = {
    id?: string
    createdAt?: Date | string
    token: string
    expireAt: Date | string
    user?: UserCreateNestedOneWithoutConfirmTokenInput
    admin?: AdminCreateNestedOneWithoutConfirmTokenInput
  }

  export type ConfirmTokenUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    token: string
    userId?: string | null
    adminId?: string | null
    expireAt: Date | string
  }

  export type ConfirmTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutConfirmTokenNestedInput
    admin?: AdminUpdateOneWithoutConfirmTokenNestedInput
  }

  export type ConfirmTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfirmTokenCreateManyInput = {
    id?: string
    createdAt?: Date | string
    token: string
    userId?: string | null
    adminId?: string | null
    expireAt: Date | string
  }

  export type ConfirmTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfirmTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    createdAt?: Date | string
    token: string
    expireAt: Date | string
    user?: UserCreateNestedOneWithoutRefreshTokenInput
    admin?: AdminCreateNestedOneWithoutRefreshTokenInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    token: string
    userId?: string | null
    adminId?: string | null
    expireAt: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRefreshTokenNestedInput
    admin?: AdminUpdateOneWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    createdAt?: Date | string
    token: string
    userId?: string | null
    adminId?: string | null
    expireAt: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomNum: string
    types?: $Enums.RoomTypes
    price: string
    description: string
    aminities?: RoomCreateaminitiesInput | string[]
    images?: RoomCreateimagesInput | string[]
    view: string
    isDeleted?: boolean
    extraServices?: ExtraServicesCreateNestedManyWithoutRoomInput
    user?: RoomReservationCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomNum: string
    types?: $Enums.RoomTypes
    price: string
    description: string
    aminities?: RoomCreateaminitiesInput | string[]
    images?: RoomCreateimagesInput | string[]
    view: string
    isDeleted?: boolean
    extraServices?: ExtraServicesUncheckedCreateNestedManyWithoutRoomInput
    user?: RoomReservationUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNum?: StringFieldUpdateOperationsInput | string
    types?: EnumRoomTypesFieldUpdateOperationsInput | $Enums.RoomTypes
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    aminities?: RoomUpdateaminitiesInput | string[]
    images?: RoomUpdateimagesInput | string[]
    view?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    extraServices?: ExtraServicesUpdateManyWithoutRoomNestedInput
    user?: RoomReservationUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNum?: StringFieldUpdateOperationsInput | string
    types?: EnumRoomTypesFieldUpdateOperationsInput | $Enums.RoomTypes
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    aminities?: RoomUpdateaminitiesInput | string[]
    images?: RoomUpdateimagesInput | string[]
    view?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    extraServices?: ExtraServicesUncheckedUpdateManyWithoutRoomNestedInput
    user?: RoomReservationUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomNum: string
    types?: $Enums.RoomTypes
    price: string
    description: string
    aminities?: RoomCreateaminitiesInput | string[]
    images?: RoomCreateimagesInput | string[]
    view: string
    isDeleted?: boolean
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNum?: StringFieldUpdateOperationsInput | string
    types?: EnumRoomTypesFieldUpdateOperationsInput | $Enums.RoomTypes
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    aminities?: RoomUpdateaminitiesInput | string[]
    images?: RoomUpdateimagesInput | string[]
    view?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNum?: StringFieldUpdateOperationsInput | string
    types?: EnumRoomTypesFieldUpdateOperationsInput | $Enums.RoomTypes
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    aminities?: RoomUpdateaminitiesInput | string[]
    images?: RoomUpdateimagesInput | string[]
    view?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomReservationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: Date | string
    checkOut: Date | string
    adults: number
    children: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRoomInput
    room: RoomCreateNestedOneWithoutUserInput
  }

  export type RoomReservationUncheckedCreateInput = {
    id?: string
    userId: string
    roomId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: Date | string
    checkOut: Date | string
    adults: number
    children: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type RoomReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRoomNestedInput
    room?: RoomUpdateOneRequiredWithoutUserNestedInput
  }

  export type RoomReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoomReservationCreateManyInput = {
    id?: string
    userId: string
    roomId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: Date | string
    checkOut: Date | string
    adults: number
    children: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type RoomReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoomReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExtraServicesCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    price: string
    facilities?: ExtraServicesCreatefacilitiesInput | string[]
    isDeleted?: boolean
    room: RoomCreateNestedOneWithoutExtraServicesInput
  }

  export type ExtraServicesUncheckedCreateInput = {
    id?: string
    roomId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    price: string
    facilities?: ExtraServicesCreatefacilitiesInput | string[]
    isDeleted?: boolean
  }

  export type ExtraServicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    facilities?: ExtraServicesUpdatefacilitiesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    room?: RoomUpdateOneRequiredWithoutExtraServicesNestedInput
  }

  export type ExtraServicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    facilities?: ExtraServicesUpdatefacilitiesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExtraServicesCreateManyInput = {
    id?: string
    roomId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    price: string
    facilities?: ExtraServicesCreatefacilitiesInput | string[]
    isDeleted?: boolean
  }

  export type ExtraServicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    facilities?: ExtraServicesUpdatefacilitiesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExtraServicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    facilities?: ExtraServicesUpdatefacilitiesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: number
    comment: string
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: number
    comment: string
    isDeleted?: boolean
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: number
    comment: string
    isDeleted?: boolean
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    user: AdminCreateNestedOneWithoutRestaurantInput
    menu?: MenuCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    menu?: MenuUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    user?: AdminUpdateOneRequiredWithoutRestaurantNestedInput
    menu?: MenuUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    menu?: MenuUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantCreateManyInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type RestaurantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RestaurantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type MenuCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMenuInput
    restaurant: RestaurantCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateInput = {
    id?: string
    userId: string
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MenuUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMenuNestedInput
    restaurant?: RestaurantUpdateOneRequiredWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuCreateManyInput = {
    id?: string
    userId: string
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MenuUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubHouseCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clubhouseTypes: $Enums.clubhouseTypes
    description: string
    startTime: Date | string
    endTime: Date | string
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutClubHouseInput
  }

  export type ClubHouseUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clubhouseTypes: $Enums.clubhouseTypes
    description: string
    startTime: Date | string
    endTime: Date | string
    isDeleted?: boolean
  }

  export type ClubHouseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubhouseTypes?: EnumclubhouseTypesFieldUpdateOperationsInput | $Enums.clubhouseTypes
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutClubHouseNestedInput
  }

  export type ClubHouseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubhouseTypes?: EnumclubhouseTypesFieldUpdateOperationsInput | $Enums.clubhouseTypes
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClubHouseCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clubhouseTypes: $Enums.clubhouseTypes
    description: string
    startTime: Date | string
    endTime: Date | string
    isDeleted?: boolean
  }

  export type ClubHouseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubhouseTypes?: EnumclubhouseTypesFieldUpdateOperationsInput | $Enums.clubhouseTypes
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClubHouseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubhouseTypes?: EnumclubhouseTypesFieldUpdateOperationsInput | $Enums.clubhouseTypes
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FAQSCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: string
    answer: string
    isDeleted?: boolean
  }

  export type FAQSUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: string
    answer: string
    isDeleted?: boolean
  }

  export type FAQSUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FAQSUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FAQSCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: string
    answer: string
    isDeleted?: boolean
  }

  export type FAQSUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FAQSUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NewsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    subTitle: string
    description: string
    images?: NewsCreateimagesInput | string[]
    isDeleted?: boolean
    admin: AdminCreateNestedOneWithoutNewsInput
    replies?: ReplyCreateNestedManyWithoutNewsInput
  }

  export type NewsUncheckedCreateInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    subTitle: string
    description: string
    images?: NewsCreateimagesInput | string[]
    isDeleted?: boolean
    replies?: ReplyUncheckedCreateNestedManyWithoutNewsInput
  }

  export type NewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    images?: NewsUpdateimagesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutNewsNestedInput
    replies?: ReplyUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    images?: NewsUpdateimagesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    replies?: ReplyUncheckedUpdateManyWithoutNewsNestedInput
  }

  export type NewsCreateManyInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    subTitle: string
    description: string
    images?: NewsCreateimagesInput | string[]
    isDeleted?: boolean
  }

  export type NewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    images?: NewsUpdateimagesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    images?: NewsUpdateimagesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReplyCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    comment: string
    isDeleted?: boolean
    news: NewsCreateNestedOneWithoutRepliesInput
  }

  export type ReplyUncheckedCreateInput = {
    id?: string
    newsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    comment: string
    isDeleted?: boolean
  }

  export type ReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    news?: NewsUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReplyCreateManyInput = {
    id?: string
    newsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    comment: string
    isDeleted?: boolean
  }

  export type ReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactUsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    phoneNum: string
    subject: string
    description: string
    isDeleted?: boolean
    isRead?: boolean
    byAdmin?: AdminCreateNestedOneWithoutContactInput
  }

  export type ContactUsUncheckedCreateInput = {
    id?: string
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    phoneNum: string
    subject: string
    description: string
    isDeleted?: boolean
    isRead?: boolean
  }

  export type ContactUsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    byAdmin?: AdminUpdateOneWithoutContactNestedInput
  }

  export type ContactUsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactUsCreateManyInput = {
    id?: string
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    phoneNum: string
    subject: string
    description: string
    isDeleted?: boolean
    isRead?: boolean
  }

  export type ContactUsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactUsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppSettingsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelName: string
    logo: string
    address: string
    phoneNum: string
    email: string
    socialMedia: JsonNullValueInput | InputJsonValue
    admin: AdminCreateNestedOneWithoutAppSettingsInput
  }

  export type AppSettingsUncheckedCreateInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelName: string
    logo: string
    address: string
    phoneNum: string
    email: string
    socialMedia: JsonNullValueInput | InputJsonValue
  }

  export type AppSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelName?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    socialMedia?: JsonNullValueInput | InputJsonValue
    admin?: AdminUpdateOneRequiredWithoutAppSettingsNestedInput
  }

  export type AppSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelName?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    socialMedia?: JsonNullValueInput | InputJsonValue
  }

  export type AppSettingsCreateManyInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelName: string
    logo: string
    address: string
    phoneNum: string
    email: string
    socialMedia: JsonNullValueInput | InputJsonValue
  }

  export type AppSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelName?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    socialMedia?: JsonNullValueInput | InputJsonValue
  }

  export type AppSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelName?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    socialMedia?: JsonNullValueInput | InputJsonValue
  }

  export type HomeSlidersCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: string
    header: string
    paragraph: string
    isDeleted?: boolean
    byAdmin: AdminCreateNestedOneWithoutHomeSlidersInput
  }

  export type HomeSlidersUncheckedCreateInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: string
    header: string
    paragraph: string
    isDeleted?: boolean
  }

  export type HomeSlidersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    header?: StringFieldUpdateOperationsInput | string
    paragraph?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    byAdmin?: AdminUpdateOneRequiredWithoutHomeSlidersNestedInput
  }

  export type HomeSlidersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    header?: StringFieldUpdateOperationsInput | string
    paragraph?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HomeSlidersCreateManyInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: string
    header: string
    paragraph: string
    isDeleted?: boolean
  }

  export type HomeSlidersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    header?: StringFieldUpdateOperationsInput | string
    paragraph?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HomeSlidersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    header?: StringFieldUpdateOperationsInput | string
    paragraph?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromotionVidCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    video: string
    description: string
    byAdmin: AdminCreateNestedOneWithoutPromotionVidInput
  }

  export type PromotionVidUncheckedCreateInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    video: string
    description: string
  }

  export type PromotionVidUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    byAdmin?: AdminUpdateOneRequiredWithoutPromotionVidNestedInput
  }

  export type PromotionVidUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionVidCreateManyInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    video: string
    description: string
  }

  export type PromotionVidUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionVidUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumROLEFilter<$PrismaModel = never> = {
    equals?: $Enums.ROLE | EnumROLEFieldRefInput<$PrismaModel>
    in?: $Enums.ROLE[] | ListEnumROLEFieldRefInput<$PrismaModel>
    notIn?: $Enums.ROLE[] | ListEnumROLEFieldRefInput<$PrismaModel>
    not?: NestedEnumROLEFilter<$PrismaModel> | $Enums.ROLE
  }

  export type NewsListRelationFilter = {
    every?: NewsWhereInput
    some?: NewsWhereInput
    none?: NewsWhereInput
  }

  export type ContactUsListRelationFilter = {
    every?: ContactUsWhereInput
    some?: ContactUsWhereInput
    none?: ContactUsWhereInput
  }

  export type RestaurantListRelationFilter = {
    every?: RestaurantWhereInput
    some?: RestaurantWhereInput
    none?: RestaurantWhereInput
  }

  export type AppSettingsListRelationFilter = {
    every?: AppSettingsWhereInput
    some?: AppSettingsWhereInput
    none?: AppSettingsWhereInput
  }

  export type ResetTokenNullableRelationFilter = {
    is?: ResetTokenWhereInput | null
    isNot?: ResetTokenWhereInput | null
  }

  export type ConfirmTokenNullableRelationFilter = {
    is?: ConfirmTokenWhereInput | null
    isNot?: ConfirmTokenWhereInput | null
  }

  export type RefreshTokenNullableRelationFilter = {
    is?: RefreshTokenWhereInput | null
    isNot?: RefreshTokenWhereInput | null
  }

  export type HomeSlidersListRelationFilter = {
    every?: HomeSlidersWhereInput
    some?: HomeSlidersWhereInput
    none?: HomeSlidersWhereInput
  }

  export type PromotionVidNullableRelationFilter = {
    is?: PromotionVidWhereInput | null
    isNot?: PromotionVidWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactUsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HomeSlidersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profilePic?: SortOrder
    birthDate?: SortOrder
    phoneNum?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profilePic?: SortOrder
    birthDate?: SortOrder
    phoneNum?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profilePic?: SortOrder
    birthDate?: SortOrder
    phoneNum?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumROLEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ROLE | EnumROLEFieldRefInput<$PrismaModel>
    in?: $Enums.ROLE[] | ListEnumROLEFieldRefInput<$PrismaModel>
    notIn?: $Enums.ROLE[] | ListEnumROLEFieldRefInput<$PrismaModel>
    not?: NestedEnumROLEWithAggregatesFilter<$PrismaModel> | $Enums.ROLE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumROLEFilter<$PrismaModel>
    _max?: NestedEnumROLEFilter<$PrismaModel>
  }

  export type RoomReservationListRelationFilter = {
    every?: RoomReservationWhereInput
    some?: RoomReservationWhereInput
    none?: RoomReservationWhereInput
  }

  export type ReviewNullableRelationFilter = {
    is?: ReviewWhereInput | null
    isNot?: ReviewWhereInput | null
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type ClubHouseListRelationFilter = {
    every?: ClubHouseWhereInput
    some?: ClubHouseWhereInput
    none?: ClubHouseWhereInput
  }

  export type RoomReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubHouseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fName?: SortOrder
    lName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profilePic?: SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    nationalID?: SortOrder
    isBlocked?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fName?: SortOrder
    lName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profilePic?: SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    nationalID?: SortOrder
    isBlocked?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fName?: SortOrder
    lName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profilePic?: SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    nationalID?: SortOrder
    isBlocked?: SortOrder
    isDeleted?: SortOrder
    emailConfirmed?: SortOrder
    role?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AdminNullableRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type ResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    expireAt?: SortOrder
  }

  export type ResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    expireAt?: SortOrder
  }

  export type ResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    expireAt?: SortOrder
  }

  export type ConfirmTokenCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    expireAt?: SortOrder
  }

  export type ConfirmTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    expireAt?: SortOrder
  }

  export type ConfirmTokenMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    expireAt?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    expireAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    expireAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    expireAt?: SortOrder
  }

  export type EnumRoomTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomTypes | EnumRoomTypesFieldRefInput<$PrismaModel>
    in?: $Enums.RoomTypes[] | ListEnumRoomTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomTypes[] | ListEnumRoomTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypesFilter<$PrismaModel> | $Enums.RoomTypes
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ExtraServicesListRelationFilter = {
    every?: ExtraServicesWhereInput
    some?: ExtraServicesWhereInput
    none?: ExtraServicesWhereInput
  }

  export type ExtraServicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roomNum?: SortOrder
    types?: SortOrder
    price?: SortOrder
    description?: SortOrder
    aminities?: SortOrder
    images?: SortOrder
    view?: SortOrder
    isDeleted?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roomNum?: SortOrder
    types?: SortOrder
    price?: SortOrder
    description?: SortOrder
    view?: SortOrder
    isDeleted?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roomNum?: SortOrder
    types?: SortOrder
    price?: SortOrder
    description?: SortOrder
    view?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumRoomTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomTypes | EnumRoomTypesFieldRefInput<$PrismaModel>
    in?: $Enums.RoomTypes[] | ListEnumRoomTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomTypes[] | ListEnumRoomTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypesWithAggregatesFilter<$PrismaModel> | $Enums.RoomTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypesFilter<$PrismaModel>
    _max?: NestedEnumRoomTypesFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type RoomReservationRoomIdUserIdCompoundUniqueInput = {
    roomId: string
    userId: string
  }

  export type RoomReservationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type RoomReservationAvgOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
  }

  export type RoomReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type RoomReservationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type RoomReservationSumOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ExtraServicesCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    price?: SortOrder
    facilities?: SortOrder
    isDeleted?: SortOrder
  }

  export type ExtraServicesMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isDeleted?: SortOrder
  }

  export type ExtraServicesMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isDeleted?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AdminRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type RestaurantCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type RestaurantMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type RestaurantMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type EnumMenuTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuTypes | EnumMenuTypesFieldRefInput<$PrismaModel>
    in?: $Enums.MenuTypes[] | ListEnumMenuTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuTypes[] | ListEnumMenuTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypesFilter<$PrismaModel> | $Enums.MenuTypes
  }

  export type RestaurantRelationFilter = {
    is?: RestaurantWhereInput
    isNot?: RestaurantWhereInput
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuTypes?: SortOrder
    name?: SortOrder
    ingredients?: SortOrder
    price?: SortOrder
    image?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuTypes?: SortOrder
    name?: SortOrder
    ingredients?: SortOrder
    price?: SortOrder
    image?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuTypes?: SortOrder
    name?: SortOrder
    ingredients?: SortOrder
    price?: SortOrder
    image?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumMenuTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuTypes | EnumMenuTypesFieldRefInput<$PrismaModel>
    in?: $Enums.MenuTypes[] | ListEnumMenuTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuTypes[] | ListEnumMenuTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypesWithAggregatesFilter<$PrismaModel> | $Enums.MenuTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuTypesFilter<$PrismaModel>
    _max?: NestedEnumMenuTypesFilter<$PrismaModel>
  }

  export type EnumclubhouseTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.clubhouseTypes | EnumclubhouseTypesFieldRefInput<$PrismaModel>
    in?: $Enums.clubhouseTypes[] | ListEnumclubhouseTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.clubhouseTypes[] | ListEnumclubhouseTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumclubhouseTypesFilter<$PrismaModel> | $Enums.clubhouseTypes
  }

  export type ClubHouseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clubhouseTypes?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isDeleted?: SortOrder
  }

  export type ClubHouseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clubhouseTypes?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isDeleted?: SortOrder
  }

  export type ClubHouseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clubhouseTypes?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumclubhouseTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.clubhouseTypes | EnumclubhouseTypesFieldRefInput<$PrismaModel>
    in?: $Enums.clubhouseTypes[] | ListEnumclubhouseTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.clubhouseTypes[] | ListEnumclubhouseTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumclubhouseTypesWithAggregatesFilter<$PrismaModel> | $Enums.clubhouseTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumclubhouseTypesFilter<$PrismaModel>
    _max?: NestedEnumclubhouseTypesFilter<$PrismaModel>
  }

  export type FAQSCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    isDeleted?: SortOrder
  }

  export type FAQSMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    isDeleted?: SortOrder
  }

  export type FAQSMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    isDeleted?: SortOrder
  }

  export type ReplyListRelationFilter = {
    every?: ReplyWhereInput
    some?: ReplyWhereInput
    none?: ReplyWhereInput
  }

  export type ReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    description?: SortOrder
    images?: SortOrder
    isDeleted?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
  }

  export type NewsRelationFilter = {
    is?: NewsWhereInput
    isNot?: NewsWhereInput
  }

  export type ReplyCountOrderByAggregateInput = {
    id?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
  }

  export type ReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
  }

  export type ReplyMinOrderByAggregateInput = {
    id?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    comment?: SortOrder
    isDeleted?: SortOrder
  }

  export type ContactUsCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phoneNum?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    isRead?: SortOrder
  }

  export type ContactUsMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phoneNum?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    isRead?: SortOrder
  }

  export type ContactUsMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phoneNum?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    isRead?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AppSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelName?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    phoneNum?: SortOrder
    email?: SortOrder
    socialMedia?: SortOrder
  }

  export type AppSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelName?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    phoneNum?: SortOrder
    email?: SortOrder
  }

  export type AppSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelName?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    phoneNum?: SortOrder
    email?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type HomeSlidersCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrder
    header?: SortOrder
    paragraph?: SortOrder
    isDeleted?: SortOrder
  }

  export type HomeSlidersMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrder
    header?: SortOrder
    paragraph?: SortOrder
    isDeleted?: SortOrder
  }

  export type HomeSlidersMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrder
    header?: SortOrder
    paragraph?: SortOrder
    isDeleted?: SortOrder
  }

  export type PromotionVidCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    video?: SortOrder
    description?: SortOrder
  }

  export type PromotionVidMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    video?: SortOrder
    description?: SortOrder
  }

  export type PromotionVidMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    video?: SortOrder
    description?: SortOrder
  }

  export type NewsCreateNestedManyWithoutAdminInput = {
    create?: XOR<NewsCreateWithoutAdminInput, NewsUncheckedCreateWithoutAdminInput> | NewsCreateWithoutAdminInput[] | NewsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutAdminInput | NewsCreateOrConnectWithoutAdminInput[]
    createMany?: NewsCreateManyAdminInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type ContactUsCreateNestedManyWithoutByAdminInput = {
    create?: XOR<ContactUsCreateWithoutByAdminInput, ContactUsUncheckedCreateWithoutByAdminInput> | ContactUsCreateWithoutByAdminInput[] | ContactUsUncheckedCreateWithoutByAdminInput[]
    connectOrCreate?: ContactUsCreateOrConnectWithoutByAdminInput | ContactUsCreateOrConnectWithoutByAdminInput[]
    createMany?: ContactUsCreateManyByAdminInputEnvelope
    connect?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
  }

  export type RestaurantCreateNestedManyWithoutUserInput = {
    create?: XOR<RestaurantCreateWithoutUserInput, RestaurantUncheckedCreateWithoutUserInput> | RestaurantCreateWithoutUserInput[] | RestaurantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutUserInput | RestaurantCreateOrConnectWithoutUserInput[]
    createMany?: RestaurantCreateManyUserInputEnvelope
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
  }

  export type AppSettingsCreateNestedManyWithoutAdminInput = {
    create?: XOR<AppSettingsCreateWithoutAdminInput, AppSettingsUncheckedCreateWithoutAdminInput> | AppSettingsCreateWithoutAdminInput[] | AppSettingsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AppSettingsCreateOrConnectWithoutAdminInput | AppSettingsCreateOrConnectWithoutAdminInput[]
    createMany?: AppSettingsCreateManyAdminInputEnvelope
    connect?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
  }

  export type ResetTokenCreateNestedOneWithoutAdminInput = {
    create?: XOR<ResetTokenCreateWithoutAdminInput, ResetTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ResetTokenCreateOrConnectWithoutAdminInput
    connect?: ResetTokenWhereUniqueInput
  }

  export type ConfirmTokenCreateNestedOneWithoutAdminInput = {
    create?: XOR<ConfirmTokenCreateWithoutAdminInput, ConfirmTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ConfirmTokenCreateOrConnectWithoutAdminInput
    connect?: ConfirmTokenWhereUniqueInput
  }

  export type RefreshTokenCreateNestedOneWithoutAdminInput = {
    create?: XOR<RefreshTokenCreateWithoutAdminInput, RefreshTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutAdminInput
    connect?: RefreshTokenWhereUniqueInput
  }

  export type HomeSlidersCreateNestedManyWithoutByAdminInput = {
    create?: XOR<HomeSlidersCreateWithoutByAdminInput, HomeSlidersUncheckedCreateWithoutByAdminInput> | HomeSlidersCreateWithoutByAdminInput[] | HomeSlidersUncheckedCreateWithoutByAdminInput[]
    connectOrCreate?: HomeSlidersCreateOrConnectWithoutByAdminInput | HomeSlidersCreateOrConnectWithoutByAdminInput[]
    createMany?: HomeSlidersCreateManyByAdminInputEnvelope
    connect?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
  }

  export type PromotionVidCreateNestedOneWithoutByAdminInput = {
    create?: XOR<PromotionVidCreateWithoutByAdminInput, PromotionVidUncheckedCreateWithoutByAdminInput>
    connectOrCreate?: PromotionVidCreateOrConnectWithoutByAdminInput
    connect?: PromotionVidWhereUniqueInput
  }

  export type NewsUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<NewsCreateWithoutAdminInput, NewsUncheckedCreateWithoutAdminInput> | NewsCreateWithoutAdminInput[] | NewsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutAdminInput | NewsCreateOrConnectWithoutAdminInput[]
    createMany?: NewsCreateManyAdminInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type ContactUsUncheckedCreateNestedManyWithoutByAdminInput = {
    create?: XOR<ContactUsCreateWithoutByAdminInput, ContactUsUncheckedCreateWithoutByAdminInput> | ContactUsCreateWithoutByAdminInput[] | ContactUsUncheckedCreateWithoutByAdminInput[]
    connectOrCreate?: ContactUsCreateOrConnectWithoutByAdminInput | ContactUsCreateOrConnectWithoutByAdminInput[]
    createMany?: ContactUsCreateManyByAdminInputEnvelope
    connect?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
  }

  export type RestaurantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RestaurantCreateWithoutUserInput, RestaurantUncheckedCreateWithoutUserInput> | RestaurantCreateWithoutUserInput[] | RestaurantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutUserInput | RestaurantCreateOrConnectWithoutUserInput[]
    createMany?: RestaurantCreateManyUserInputEnvelope
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
  }

  export type AppSettingsUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AppSettingsCreateWithoutAdminInput, AppSettingsUncheckedCreateWithoutAdminInput> | AppSettingsCreateWithoutAdminInput[] | AppSettingsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AppSettingsCreateOrConnectWithoutAdminInput | AppSettingsCreateOrConnectWithoutAdminInput[]
    createMany?: AppSettingsCreateManyAdminInputEnvelope
    connect?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
  }

  export type ResetTokenUncheckedCreateNestedOneWithoutAdminInput = {
    create?: XOR<ResetTokenCreateWithoutAdminInput, ResetTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ResetTokenCreateOrConnectWithoutAdminInput
    connect?: ResetTokenWhereUniqueInput
  }

  export type ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput = {
    create?: XOR<ConfirmTokenCreateWithoutAdminInput, ConfirmTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ConfirmTokenCreateOrConnectWithoutAdminInput
    connect?: ConfirmTokenWhereUniqueInput
  }

  export type RefreshTokenUncheckedCreateNestedOneWithoutAdminInput = {
    create?: XOR<RefreshTokenCreateWithoutAdminInput, RefreshTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutAdminInput
    connect?: RefreshTokenWhereUniqueInput
  }

  export type HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput = {
    create?: XOR<HomeSlidersCreateWithoutByAdminInput, HomeSlidersUncheckedCreateWithoutByAdminInput> | HomeSlidersCreateWithoutByAdminInput[] | HomeSlidersUncheckedCreateWithoutByAdminInput[]
    connectOrCreate?: HomeSlidersCreateOrConnectWithoutByAdminInput | HomeSlidersCreateOrConnectWithoutByAdminInput[]
    createMany?: HomeSlidersCreateManyByAdminInputEnvelope
    connect?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
  }

  export type PromotionVidUncheckedCreateNestedOneWithoutByAdminInput = {
    create?: XOR<PromotionVidCreateWithoutByAdminInput, PromotionVidUncheckedCreateWithoutByAdminInput>
    connectOrCreate?: PromotionVidCreateOrConnectWithoutByAdminInput
    connect?: PromotionVidWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumROLEFieldUpdateOperationsInput = {
    set?: $Enums.ROLE
  }

  export type NewsUpdateManyWithoutAdminNestedInput = {
    create?: XOR<NewsCreateWithoutAdminInput, NewsUncheckedCreateWithoutAdminInput> | NewsCreateWithoutAdminInput[] | NewsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutAdminInput | NewsCreateOrConnectWithoutAdminInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutAdminInput | NewsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: NewsCreateManyAdminInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutAdminInput | NewsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutAdminInput | NewsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type ContactUsUpdateManyWithoutByAdminNestedInput = {
    create?: XOR<ContactUsCreateWithoutByAdminInput, ContactUsUncheckedCreateWithoutByAdminInput> | ContactUsCreateWithoutByAdminInput[] | ContactUsUncheckedCreateWithoutByAdminInput[]
    connectOrCreate?: ContactUsCreateOrConnectWithoutByAdminInput | ContactUsCreateOrConnectWithoutByAdminInput[]
    upsert?: ContactUsUpsertWithWhereUniqueWithoutByAdminInput | ContactUsUpsertWithWhereUniqueWithoutByAdminInput[]
    createMany?: ContactUsCreateManyByAdminInputEnvelope
    set?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
    disconnect?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
    delete?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
    connect?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
    update?: ContactUsUpdateWithWhereUniqueWithoutByAdminInput | ContactUsUpdateWithWhereUniqueWithoutByAdminInput[]
    updateMany?: ContactUsUpdateManyWithWhereWithoutByAdminInput | ContactUsUpdateManyWithWhereWithoutByAdminInput[]
    deleteMany?: ContactUsScalarWhereInput | ContactUsScalarWhereInput[]
  }

  export type RestaurantUpdateManyWithoutUserNestedInput = {
    create?: XOR<RestaurantCreateWithoutUserInput, RestaurantUncheckedCreateWithoutUserInput> | RestaurantCreateWithoutUserInput[] | RestaurantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutUserInput | RestaurantCreateOrConnectWithoutUserInput[]
    upsert?: RestaurantUpsertWithWhereUniqueWithoutUserInput | RestaurantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RestaurantCreateManyUserInputEnvelope
    set?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    disconnect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    delete?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    update?: RestaurantUpdateWithWhereUniqueWithoutUserInput | RestaurantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RestaurantUpdateManyWithWhereWithoutUserInput | RestaurantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
  }

  export type AppSettingsUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AppSettingsCreateWithoutAdminInput, AppSettingsUncheckedCreateWithoutAdminInput> | AppSettingsCreateWithoutAdminInput[] | AppSettingsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AppSettingsCreateOrConnectWithoutAdminInput | AppSettingsCreateOrConnectWithoutAdminInput[]
    upsert?: AppSettingsUpsertWithWhereUniqueWithoutAdminInput | AppSettingsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AppSettingsCreateManyAdminInputEnvelope
    set?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
    disconnect?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
    delete?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
    connect?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
    update?: AppSettingsUpdateWithWhereUniqueWithoutAdminInput | AppSettingsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AppSettingsUpdateManyWithWhereWithoutAdminInput | AppSettingsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AppSettingsScalarWhereInput | AppSettingsScalarWhereInput[]
  }

  export type ResetTokenUpdateOneWithoutAdminNestedInput = {
    create?: XOR<ResetTokenCreateWithoutAdminInput, ResetTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ResetTokenCreateOrConnectWithoutAdminInput
    upsert?: ResetTokenUpsertWithoutAdminInput
    disconnect?: ResetTokenWhereInput | boolean
    delete?: ResetTokenWhereInput | boolean
    connect?: ResetTokenWhereUniqueInput
    update?: XOR<XOR<ResetTokenUpdateToOneWithWhereWithoutAdminInput, ResetTokenUpdateWithoutAdminInput>, ResetTokenUncheckedUpdateWithoutAdminInput>
  }

  export type ConfirmTokenUpdateOneWithoutAdminNestedInput = {
    create?: XOR<ConfirmTokenCreateWithoutAdminInput, ConfirmTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ConfirmTokenCreateOrConnectWithoutAdminInput
    upsert?: ConfirmTokenUpsertWithoutAdminInput
    disconnect?: ConfirmTokenWhereInput | boolean
    delete?: ConfirmTokenWhereInput | boolean
    connect?: ConfirmTokenWhereUniqueInput
    update?: XOR<XOR<ConfirmTokenUpdateToOneWithWhereWithoutAdminInput, ConfirmTokenUpdateWithoutAdminInput>, ConfirmTokenUncheckedUpdateWithoutAdminInput>
  }

  export type RefreshTokenUpdateOneWithoutAdminNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutAdminInput, RefreshTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutAdminInput
    upsert?: RefreshTokenUpsertWithoutAdminInput
    disconnect?: RefreshTokenWhereInput | boolean
    delete?: RefreshTokenWhereInput | boolean
    connect?: RefreshTokenWhereUniqueInput
    update?: XOR<XOR<RefreshTokenUpdateToOneWithWhereWithoutAdminInput, RefreshTokenUpdateWithoutAdminInput>, RefreshTokenUncheckedUpdateWithoutAdminInput>
  }

  export type HomeSlidersUpdateManyWithoutByAdminNestedInput = {
    create?: XOR<HomeSlidersCreateWithoutByAdminInput, HomeSlidersUncheckedCreateWithoutByAdminInput> | HomeSlidersCreateWithoutByAdminInput[] | HomeSlidersUncheckedCreateWithoutByAdminInput[]
    connectOrCreate?: HomeSlidersCreateOrConnectWithoutByAdminInput | HomeSlidersCreateOrConnectWithoutByAdminInput[]
    upsert?: HomeSlidersUpsertWithWhereUniqueWithoutByAdminInput | HomeSlidersUpsertWithWhereUniqueWithoutByAdminInput[]
    createMany?: HomeSlidersCreateManyByAdminInputEnvelope
    set?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
    disconnect?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
    delete?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
    connect?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
    update?: HomeSlidersUpdateWithWhereUniqueWithoutByAdminInput | HomeSlidersUpdateWithWhereUniqueWithoutByAdminInput[]
    updateMany?: HomeSlidersUpdateManyWithWhereWithoutByAdminInput | HomeSlidersUpdateManyWithWhereWithoutByAdminInput[]
    deleteMany?: HomeSlidersScalarWhereInput | HomeSlidersScalarWhereInput[]
  }

  export type PromotionVidUpdateOneWithoutByAdminNestedInput = {
    create?: XOR<PromotionVidCreateWithoutByAdminInput, PromotionVidUncheckedCreateWithoutByAdminInput>
    connectOrCreate?: PromotionVidCreateOrConnectWithoutByAdminInput
    upsert?: PromotionVidUpsertWithoutByAdminInput
    disconnect?: PromotionVidWhereInput | boolean
    delete?: PromotionVidWhereInput | boolean
    connect?: PromotionVidWhereUniqueInput
    update?: XOR<XOR<PromotionVidUpdateToOneWithWhereWithoutByAdminInput, PromotionVidUpdateWithoutByAdminInput>, PromotionVidUncheckedUpdateWithoutByAdminInput>
  }

  export type NewsUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<NewsCreateWithoutAdminInput, NewsUncheckedCreateWithoutAdminInput> | NewsCreateWithoutAdminInput[] | NewsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutAdminInput | NewsCreateOrConnectWithoutAdminInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutAdminInput | NewsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: NewsCreateManyAdminInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutAdminInput | NewsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutAdminInput | NewsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type ContactUsUncheckedUpdateManyWithoutByAdminNestedInput = {
    create?: XOR<ContactUsCreateWithoutByAdminInput, ContactUsUncheckedCreateWithoutByAdminInput> | ContactUsCreateWithoutByAdminInput[] | ContactUsUncheckedCreateWithoutByAdminInput[]
    connectOrCreate?: ContactUsCreateOrConnectWithoutByAdminInput | ContactUsCreateOrConnectWithoutByAdminInput[]
    upsert?: ContactUsUpsertWithWhereUniqueWithoutByAdminInput | ContactUsUpsertWithWhereUniqueWithoutByAdminInput[]
    createMany?: ContactUsCreateManyByAdminInputEnvelope
    set?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
    disconnect?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
    delete?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
    connect?: ContactUsWhereUniqueInput | ContactUsWhereUniqueInput[]
    update?: ContactUsUpdateWithWhereUniqueWithoutByAdminInput | ContactUsUpdateWithWhereUniqueWithoutByAdminInput[]
    updateMany?: ContactUsUpdateManyWithWhereWithoutByAdminInput | ContactUsUpdateManyWithWhereWithoutByAdminInput[]
    deleteMany?: ContactUsScalarWhereInput | ContactUsScalarWhereInput[]
  }

  export type RestaurantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RestaurantCreateWithoutUserInput, RestaurantUncheckedCreateWithoutUserInput> | RestaurantCreateWithoutUserInput[] | RestaurantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutUserInput | RestaurantCreateOrConnectWithoutUserInput[]
    upsert?: RestaurantUpsertWithWhereUniqueWithoutUserInput | RestaurantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RestaurantCreateManyUserInputEnvelope
    set?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    disconnect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    delete?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    update?: RestaurantUpdateWithWhereUniqueWithoutUserInput | RestaurantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RestaurantUpdateManyWithWhereWithoutUserInput | RestaurantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
  }

  export type AppSettingsUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AppSettingsCreateWithoutAdminInput, AppSettingsUncheckedCreateWithoutAdminInput> | AppSettingsCreateWithoutAdminInput[] | AppSettingsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AppSettingsCreateOrConnectWithoutAdminInput | AppSettingsCreateOrConnectWithoutAdminInput[]
    upsert?: AppSettingsUpsertWithWhereUniqueWithoutAdminInput | AppSettingsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AppSettingsCreateManyAdminInputEnvelope
    set?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
    disconnect?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
    delete?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
    connect?: AppSettingsWhereUniqueInput | AppSettingsWhereUniqueInput[]
    update?: AppSettingsUpdateWithWhereUniqueWithoutAdminInput | AppSettingsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AppSettingsUpdateManyWithWhereWithoutAdminInput | AppSettingsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AppSettingsScalarWhereInput | AppSettingsScalarWhereInput[]
  }

  export type ResetTokenUncheckedUpdateOneWithoutAdminNestedInput = {
    create?: XOR<ResetTokenCreateWithoutAdminInput, ResetTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ResetTokenCreateOrConnectWithoutAdminInput
    upsert?: ResetTokenUpsertWithoutAdminInput
    disconnect?: ResetTokenWhereInput | boolean
    delete?: ResetTokenWhereInput | boolean
    connect?: ResetTokenWhereUniqueInput
    update?: XOR<XOR<ResetTokenUpdateToOneWithWhereWithoutAdminInput, ResetTokenUpdateWithoutAdminInput>, ResetTokenUncheckedUpdateWithoutAdminInput>
  }

  export type ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput = {
    create?: XOR<ConfirmTokenCreateWithoutAdminInput, ConfirmTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ConfirmTokenCreateOrConnectWithoutAdminInput
    upsert?: ConfirmTokenUpsertWithoutAdminInput
    disconnect?: ConfirmTokenWhereInput | boolean
    delete?: ConfirmTokenWhereInput | boolean
    connect?: ConfirmTokenWhereUniqueInput
    update?: XOR<XOR<ConfirmTokenUpdateToOneWithWhereWithoutAdminInput, ConfirmTokenUpdateWithoutAdminInput>, ConfirmTokenUncheckedUpdateWithoutAdminInput>
  }

  export type RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutAdminInput, RefreshTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutAdminInput
    upsert?: RefreshTokenUpsertWithoutAdminInput
    disconnect?: RefreshTokenWhereInput | boolean
    delete?: RefreshTokenWhereInput | boolean
    connect?: RefreshTokenWhereUniqueInput
    update?: XOR<XOR<RefreshTokenUpdateToOneWithWhereWithoutAdminInput, RefreshTokenUpdateWithoutAdminInput>, RefreshTokenUncheckedUpdateWithoutAdminInput>
  }

  export type HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput = {
    create?: XOR<HomeSlidersCreateWithoutByAdminInput, HomeSlidersUncheckedCreateWithoutByAdminInput> | HomeSlidersCreateWithoutByAdminInput[] | HomeSlidersUncheckedCreateWithoutByAdminInput[]
    connectOrCreate?: HomeSlidersCreateOrConnectWithoutByAdminInput | HomeSlidersCreateOrConnectWithoutByAdminInput[]
    upsert?: HomeSlidersUpsertWithWhereUniqueWithoutByAdminInput | HomeSlidersUpsertWithWhereUniqueWithoutByAdminInput[]
    createMany?: HomeSlidersCreateManyByAdminInputEnvelope
    set?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
    disconnect?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
    delete?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
    connect?: HomeSlidersWhereUniqueInput | HomeSlidersWhereUniqueInput[]
    update?: HomeSlidersUpdateWithWhereUniqueWithoutByAdminInput | HomeSlidersUpdateWithWhereUniqueWithoutByAdminInput[]
    updateMany?: HomeSlidersUpdateManyWithWhereWithoutByAdminInput | HomeSlidersUpdateManyWithWhereWithoutByAdminInput[]
    deleteMany?: HomeSlidersScalarWhereInput | HomeSlidersScalarWhereInput[]
  }

  export type PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput = {
    create?: XOR<PromotionVidCreateWithoutByAdminInput, PromotionVidUncheckedCreateWithoutByAdminInput>
    connectOrCreate?: PromotionVidCreateOrConnectWithoutByAdminInput
    upsert?: PromotionVidUpsertWithoutByAdminInput
    disconnect?: PromotionVidWhereInput | boolean
    delete?: PromotionVidWhereInput | boolean
    connect?: PromotionVidWhereUniqueInput
    update?: XOR<XOR<PromotionVidUpdateToOneWithWhereWithoutByAdminInput, PromotionVidUpdateWithoutByAdminInput>, PromotionVidUncheckedUpdateWithoutByAdminInput>
  }

  export type RoomReservationCreateNestedManyWithoutUserInput = {
    create?: XOR<RoomReservationCreateWithoutUserInput, RoomReservationUncheckedCreateWithoutUserInput> | RoomReservationCreateWithoutUserInput[] | RoomReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomReservationCreateOrConnectWithoutUserInput | RoomReservationCreateOrConnectWithoutUserInput[]
    createMany?: RoomReservationCreateManyUserInputEnvelope
    connect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
  }

  export type ReviewCreateNestedOneWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput
    connect?: ReviewWhereUniqueInput
  }

  export type MenuCreateNestedManyWithoutUserInput = {
    create?: XOR<MenuCreateWithoutUserInput, MenuUncheckedCreateWithoutUserInput> | MenuCreateWithoutUserInput[] | MenuUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutUserInput | MenuCreateOrConnectWithoutUserInput[]
    createMany?: MenuCreateManyUserInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type ClubHouseCreateNestedManyWithoutUserInput = {
    create?: XOR<ClubHouseCreateWithoutUserInput, ClubHouseUncheckedCreateWithoutUserInput> | ClubHouseCreateWithoutUserInput[] | ClubHouseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubHouseCreateOrConnectWithoutUserInput | ClubHouseCreateOrConnectWithoutUserInput[]
    createMany?: ClubHouseCreateManyUserInputEnvelope
    connect?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
  }

  export type ResetTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<ResetTokenCreateWithoutUserInput, ResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResetTokenCreateOrConnectWithoutUserInput
    connect?: ResetTokenWhereUniqueInput
  }

  export type ConfirmTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<ConfirmTokenCreateWithoutUserInput, ConfirmTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConfirmTokenCreateOrConnectWithoutUserInput
    connect?: ConfirmTokenWhereUniqueInput
  }

  export type RefreshTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput
    connect?: RefreshTokenWhereUniqueInput
  }

  export type RoomReservationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoomReservationCreateWithoutUserInput, RoomReservationUncheckedCreateWithoutUserInput> | RoomReservationCreateWithoutUserInput[] | RoomReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomReservationCreateOrConnectWithoutUserInput | RoomReservationCreateOrConnectWithoutUserInput[]
    createMany?: RoomReservationCreateManyUserInputEnvelope
    connect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput
    connect?: ReviewWhereUniqueInput
  }

  export type MenuUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MenuCreateWithoutUserInput, MenuUncheckedCreateWithoutUserInput> | MenuCreateWithoutUserInput[] | MenuUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutUserInput | MenuCreateOrConnectWithoutUserInput[]
    createMany?: MenuCreateManyUserInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type ClubHouseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClubHouseCreateWithoutUserInput, ClubHouseUncheckedCreateWithoutUserInput> | ClubHouseCreateWithoutUserInput[] | ClubHouseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubHouseCreateOrConnectWithoutUserInput | ClubHouseCreateOrConnectWithoutUserInput[]
    createMany?: ClubHouseCreateManyUserInputEnvelope
    connect?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
  }

  export type ResetTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ResetTokenCreateWithoutUserInput, ResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResetTokenCreateOrConnectWithoutUserInput
    connect?: ResetTokenWhereUniqueInput
  }

  export type ConfirmTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ConfirmTokenCreateWithoutUserInput, ConfirmTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConfirmTokenCreateOrConnectWithoutUserInput
    connect?: ConfirmTokenWhereUniqueInput
  }

  export type RefreshTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput
    connect?: RefreshTokenWhereUniqueInput
  }

  export type RoomReservationUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoomReservationCreateWithoutUserInput, RoomReservationUncheckedCreateWithoutUserInput> | RoomReservationCreateWithoutUserInput[] | RoomReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomReservationCreateOrConnectWithoutUserInput | RoomReservationCreateOrConnectWithoutUserInput[]
    upsert?: RoomReservationUpsertWithWhereUniqueWithoutUserInput | RoomReservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoomReservationCreateManyUserInputEnvelope
    set?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    disconnect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    delete?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    connect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    update?: RoomReservationUpdateWithWhereUniqueWithoutUserInput | RoomReservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoomReservationUpdateManyWithWhereWithoutUserInput | RoomReservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoomReservationScalarWhereInput | RoomReservationScalarWhereInput[]
  }

  export type ReviewUpdateOneWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput
    upsert?: ReviewUpsertWithoutUserInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutUserInput, ReviewUpdateWithoutUserInput>, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type MenuUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenuCreateWithoutUserInput, MenuUncheckedCreateWithoutUserInput> | MenuCreateWithoutUserInput[] | MenuUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutUserInput | MenuCreateOrConnectWithoutUserInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutUserInput | MenuUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenuCreateManyUserInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutUserInput | MenuUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutUserInput | MenuUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type ClubHouseUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClubHouseCreateWithoutUserInput, ClubHouseUncheckedCreateWithoutUserInput> | ClubHouseCreateWithoutUserInput[] | ClubHouseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubHouseCreateOrConnectWithoutUserInput | ClubHouseCreateOrConnectWithoutUserInput[]
    upsert?: ClubHouseUpsertWithWhereUniqueWithoutUserInput | ClubHouseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClubHouseCreateManyUserInputEnvelope
    set?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
    disconnect?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
    delete?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
    connect?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
    update?: ClubHouseUpdateWithWhereUniqueWithoutUserInput | ClubHouseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClubHouseUpdateManyWithWhereWithoutUserInput | ClubHouseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClubHouseScalarWhereInput | ClubHouseScalarWhereInput[]
  }

  export type ResetTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<ResetTokenCreateWithoutUserInput, ResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResetTokenCreateOrConnectWithoutUserInput
    upsert?: ResetTokenUpsertWithoutUserInput
    disconnect?: ResetTokenWhereInput | boolean
    delete?: ResetTokenWhereInput | boolean
    connect?: ResetTokenWhereUniqueInput
    update?: XOR<XOR<ResetTokenUpdateToOneWithWhereWithoutUserInput, ResetTokenUpdateWithoutUserInput>, ResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type ConfirmTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<ConfirmTokenCreateWithoutUserInput, ConfirmTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConfirmTokenCreateOrConnectWithoutUserInput
    upsert?: ConfirmTokenUpsertWithoutUserInput
    disconnect?: ConfirmTokenWhereInput | boolean
    delete?: ConfirmTokenWhereInput | boolean
    connect?: ConfirmTokenWhereUniqueInput
    update?: XOR<XOR<ConfirmTokenUpdateToOneWithWhereWithoutUserInput, ConfirmTokenUpdateWithoutUserInput>, ConfirmTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput
    upsert?: RefreshTokenUpsertWithoutUserInput
    disconnect?: RefreshTokenWhereInput | boolean
    delete?: RefreshTokenWhereInput | boolean
    connect?: RefreshTokenWhereUniqueInput
    update?: XOR<XOR<RefreshTokenUpdateToOneWithWhereWithoutUserInput, RefreshTokenUpdateWithoutUserInput>, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RoomReservationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoomReservationCreateWithoutUserInput, RoomReservationUncheckedCreateWithoutUserInput> | RoomReservationCreateWithoutUserInput[] | RoomReservationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomReservationCreateOrConnectWithoutUserInput | RoomReservationCreateOrConnectWithoutUserInput[]
    upsert?: RoomReservationUpsertWithWhereUniqueWithoutUserInput | RoomReservationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoomReservationCreateManyUserInputEnvelope
    set?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    disconnect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    delete?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    connect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    update?: RoomReservationUpdateWithWhereUniqueWithoutUserInput | RoomReservationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoomReservationUpdateManyWithWhereWithoutUserInput | RoomReservationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoomReservationScalarWhereInput | RoomReservationScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput
    upsert?: ReviewUpsertWithoutUserInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutUserInput, ReviewUpdateWithoutUserInput>, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type MenuUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenuCreateWithoutUserInput, MenuUncheckedCreateWithoutUserInput> | MenuCreateWithoutUserInput[] | MenuUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutUserInput | MenuCreateOrConnectWithoutUserInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutUserInput | MenuUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenuCreateManyUserInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutUserInput | MenuUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutUserInput | MenuUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type ClubHouseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClubHouseCreateWithoutUserInput, ClubHouseUncheckedCreateWithoutUserInput> | ClubHouseCreateWithoutUserInput[] | ClubHouseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubHouseCreateOrConnectWithoutUserInput | ClubHouseCreateOrConnectWithoutUserInput[]
    upsert?: ClubHouseUpsertWithWhereUniqueWithoutUserInput | ClubHouseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClubHouseCreateManyUserInputEnvelope
    set?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
    disconnect?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
    delete?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
    connect?: ClubHouseWhereUniqueInput | ClubHouseWhereUniqueInput[]
    update?: ClubHouseUpdateWithWhereUniqueWithoutUserInput | ClubHouseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClubHouseUpdateManyWithWhereWithoutUserInput | ClubHouseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClubHouseScalarWhereInput | ClubHouseScalarWhereInput[]
  }

  export type ResetTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ResetTokenCreateWithoutUserInput, ResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResetTokenCreateOrConnectWithoutUserInput
    upsert?: ResetTokenUpsertWithoutUserInput
    disconnect?: ResetTokenWhereInput | boolean
    delete?: ResetTokenWhereInput | boolean
    connect?: ResetTokenWhereUniqueInput
    update?: XOR<XOR<ResetTokenUpdateToOneWithWhereWithoutUserInput, ResetTokenUpdateWithoutUserInput>, ResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type ConfirmTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ConfirmTokenCreateWithoutUserInput, ConfirmTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConfirmTokenCreateOrConnectWithoutUserInput
    upsert?: ConfirmTokenUpsertWithoutUserInput
    disconnect?: ConfirmTokenWhereInput | boolean
    delete?: ConfirmTokenWhereInput | boolean
    connect?: ConfirmTokenWhereUniqueInput
    update?: XOR<XOR<ConfirmTokenUpdateToOneWithWhereWithoutUserInput, ConfirmTokenUpdateWithoutUserInput>, ConfirmTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput
    upsert?: RefreshTokenUpsertWithoutUserInput
    disconnect?: RefreshTokenWhereInput | boolean
    delete?: RefreshTokenWhereInput | boolean
    connect?: RefreshTokenWhereUniqueInput
    update?: XOR<XOR<RefreshTokenUpdateToOneWithWhereWithoutUserInput, RefreshTokenUpdateWithoutUserInput>, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutResetTokenInput = {
    create?: XOR<UserCreateWithoutResetTokenInput, UserUncheckedCreateWithoutResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokenInput
    connect?: UserWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutResetTokenInput = {
    create?: XOR<AdminCreateWithoutResetTokenInput, AdminUncheckedCreateWithoutResetTokenInput>
    connectOrCreate?: AdminCreateOrConnectWithoutResetTokenInput
    connect?: AdminWhereUniqueInput
  }

  export type UserUpdateOneWithoutResetTokenNestedInput = {
    create?: XOR<UserCreateWithoutResetTokenInput, UserUncheckedCreateWithoutResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokenInput
    upsert?: UserUpsertWithoutResetTokenInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResetTokenInput, UserUpdateWithoutResetTokenInput>, UserUncheckedUpdateWithoutResetTokenInput>
  }

  export type AdminUpdateOneWithoutResetTokenNestedInput = {
    create?: XOR<AdminCreateWithoutResetTokenInput, AdminUncheckedCreateWithoutResetTokenInput>
    connectOrCreate?: AdminCreateOrConnectWithoutResetTokenInput
    upsert?: AdminUpsertWithoutResetTokenInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutResetTokenInput, AdminUpdateWithoutResetTokenInput>, AdminUncheckedUpdateWithoutResetTokenInput>
  }

  export type UserCreateNestedOneWithoutConfirmTokenInput = {
    create?: XOR<UserCreateWithoutConfirmTokenInput, UserUncheckedCreateWithoutConfirmTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmTokenInput
    connect?: UserWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutConfirmTokenInput = {
    create?: XOR<AdminCreateWithoutConfirmTokenInput, AdminUncheckedCreateWithoutConfirmTokenInput>
    connectOrCreate?: AdminCreateOrConnectWithoutConfirmTokenInput
    connect?: AdminWhereUniqueInput
  }

  export type UserUpdateOneWithoutConfirmTokenNestedInput = {
    create?: XOR<UserCreateWithoutConfirmTokenInput, UserUncheckedCreateWithoutConfirmTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmTokenInput
    upsert?: UserUpsertWithoutConfirmTokenInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConfirmTokenInput, UserUpdateWithoutConfirmTokenInput>, UserUncheckedUpdateWithoutConfirmTokenInput>
  }

  export type AdminUpdateOneWithoutConfirmTokenNestedInput = {
    create?: XOR<AdminCreateWithoutConfirmTokenInput, AdminUncheckedCreateWithoutConfirmTokenInput>
    connectOrCreate?: AdminCreateOrConnectWithoutConfirmTokenInput
    upsert?: AdminUpsertWithoutConfirmTokenInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutConfirmTokenInput, AdminUpdateWithoutConfirmTokenInput>, AdminUncheckedUpdateWithoutConfirmTokenInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokenInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    connect?: UserWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutRefreshTokenInput = {
    create?: XOR<AdminCreateWithoutRefreshTokenInput, AdminUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRefreshTokenInput
    connect?: AdminWhereUniqueInput
  }

  export type UserUpdateOneWithoutRefreshTokenNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    upsert?: UserUpsertWithoutRefreshTokenInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokenInput, UserUpdateWithoutRefreshTokenInput>, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type AdminUpdateOneWithoutRefreshTokenNestedInput = {
    create?: XOR<AdminCreateWithoutRefreshTokenInput, AdminUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRefreshTokenInput
    upsert?: AdminUpsertWithoutRefreshTokenInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutRefreshTokenInput, AdminUpdateWithoutRefreshTokenInput>, AdminUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type RoomCreateaminitiesInput = {
    set: string[]
  }

  export type RoomCreateimagesInput = {
    set: string[]
  }

  export type ExtraServicesCreateNestedManyWithoutRoomInput = {
    create?: XOR<ExtraServicesCreateWithoutRoomInput, ExtraServicesUncheckedCreateWithoutRoomInput> | ExtraServicesCreateWithoutRoomInput[] | ExtraServicesUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ExtraServicesCreateOrConnectWithoutRoomInput | ExtraServicesCreateOrConnectWithoutRoomInput[]
    createMany?: ExtraServicesCreateManyRoomInputEnvelope
    connect?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
  }

  export type RoomReservationCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomReservationCreateWithoutRoomInput, RoomReservationUncheckedCreateWithoutRoomInput> | RoomReservationCreateWithoutRoomInput[] | RoomReservationUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomReservationCreateOrConnectWithoutRoomInput | RoomReservationCreateOrConnectWithoutRoomInput[]
    createMany?: RoomReservationCreateManyRoomInputEnvelope
    connect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
  }

  export type ExtraServicesUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<ExtraServicesCreateWithoutRoomInput, ExtraServicesUncheckedCreateWithoutRoomInput> | ExtraServicesCreateWithoutRoomInput[] | ExtraServicesUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ExtraServicesCreateOrConnectWithoutRoomInput | ExtraServicesCreateOrConnectWithoutRoomInput[]
    createMany?: ExtraServicesCreateManyRoomInputEnvelope
    connect?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
  }

  export type RoomReservationUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomReservationCreateWithoutRoomInput, RoomReservationUncheckedCreateWithoutRoomInput> | RoomReservationCreateWithoutRoomInput[] | RoomReservationUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomReservationCreateOrConnectWithoutRoomInput | RoomReservationCreateOrConnectWithoutRoomInput[]
    createMany?: RoomReservationCreateManyRoomInputEnvelope
    connect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
  }

  export type EnumRoomTypesFieldUpdateOperationsInput = {
    set?: $Enums.RoomTypes
  }

  export type RoomUpdateaminitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoomUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExtraServicesUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ExtraServicesCreateWithoutRoomInput, ExtraServicesUncheckedCreateWithoutRoomInput> | ExtraServicesCreateWithoutRoomInput[] | ExtraServicesUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ExtraServicesCreateOrConnectWithoutRoomInput | ExtraServicesCreateOrConnectWithoutRoomInput[]
    upsert?: ExtraServicesUpsertWithWhereUniqueWithoutRoomInput | ExtraServicesUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ExtraServicesCreateManyRoomInputEnvelope
    set?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
    disconnect?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
    delete?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
    connect?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
    update?: ExtraServicesUpdateWithWhereUniqueWithoutRoomInput | ExtraServicesUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ExtraServicesUpdateManyWithWhereWithoutRoomInput | ExtraServicesUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ExtraServicesScalarWhereInput | ExtraServicesScalarWhereInput[]
  }

  export type RoomReservationUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomReservationCreateWithoutRoomInput, RoomReservationUncheckedCreateWithoutRoomInput> | RoomReservationCreateWithoutRoomInput[] | RoomReservationUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomReservationCreateOrConnectWithoutRoomInput | RoomReservationCreateOrConnectWithoutRoomInput[]
    upsert?: RoomReservationUpsertWithWhereUniqueWithoutRoomInput | RoomReservationUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomReservationCreateManyRoomInputEnvelope
    set?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    disconnect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    delete?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    connect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    update?: RoomReservationUpdateWithWhereUniqueWithoutRoomInput | RoomReservationUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomReservationUpdateManyWithWhereWithoutRoomInput | RoomReservationUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomReservationScalarWhereInput | RoomReservationScalarWhereInput[]
  }

  export type ExtraServicesUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ExtraServicesCreateWithoutRoomInput, ExtraServicesUncheckedCreateWithoutRoomInput> | ExtraServicesCreateWithoutRoomInput[] | ExtraServicesUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ExtraServicesCreateOrConnectWithoutRoomInput | ExtraServicesCreateOrConnectWithoutRoomInput[]
    upsert?: ExtraServicesUpsertWithWhereUniqueWithoutRoomInput | ExtraServicesUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ExtraServicesCreateManyRoomInputEnvelope
    set?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
    disconnect?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
    delete?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
    connect?: ExtraServicesWhereUniqueInput | ExtraServicesWhereUniqueInput[]
    update?: ExtraServicesUpdateWithWhereUniqueWithoutRoomInput | ExtraServicesUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ExtraServicesUpdateManyWithWhereWithoutRoomInput | ExtraServicesUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ExtraServicesScalarWhereInput | ExtraServicesScalarWhereInput[]
  }

  export type RoomReservationUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomReservationCreateWithoutRoomInput, RoomReservationUncheckedCreateWithoutRoomInput> | RoomReservationCreateWithoutRoomInput[] | RoomReservationUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomReservationCreateOrConnectWithoutRoomInput | RoomReservationCreateOrConnectWithoutRoomInput[]
    upsert?: RoomReservationUpsertWithWhereUniqueWithoutRoomInput | RoomReservationUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomReservationCreateManyRoomInputEnvelope
    set?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    disconnect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    delete?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    connect?: RoomReservationWhereUniqueInput | RoomReservationWhereUniqueInput[]
    update?: RoomReservationUpdateWithWhereUniqueWithoutRoomInput | RoomReservationUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomReservationUpdateManyWithWhereWithoutRoomInput | RoomReservationUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomReservationScalarWhereInput | RoomReservationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRoomInput = {
    create?: XOR<UserCreateWithoutRoomInput, UserUncheckedCreateWithoutRoomInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomInput
    connect?: UserWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutUserInput = {
    create?: XOR<RoomCreateWithoutUserInput, RoomUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoomCreateOrConnectWithoutUserInput
    connect?: RoomWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutRoomNestedInput = {
    create?: XOR<UserCreateWithoutRoomInput, UserUncheckedCreateWithoutRoomInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomInput
    upsert?: UserUpsertWithoutRoomInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoomInput, UserUpdateWithoutRoomInput>, UserUncheckedUpdateWithoutRoomInput>
  }

  export type RoomUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<RoomCreateWithoutUserInput, RoomUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoomCreateOrConnectWithoutUserInput
    upsert?: RoomUpsertWithoutUserInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutUserInput, RoomUpdateWithoutUserInput>, RoomUncheckedUpdateWithoutUserInput>
  }

  export type ExtraServicesCreatefacilitiesInput = {
    set: string[]
  }

  export type RoomCreateNestedOneWithoutExtraServicesInput = {
    create?: XOR<RoomCreateWithoutExtraServicesInput, RoomUncheckedCreateWithoutExtraServicesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutExtraServicesInput
    connect?: RoomWhereUniqueInput
  }

  export type ExtraServicesUpdatefacilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoomUpdateOneRequiredWithoutExtraServicesNestedInput = {
    create?: XOR<RoomCreateWithoutExtraServicesInput, RoomUncheckedCreateWithoutExtraServicesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutExtraServicesInput
    upsert?: RoomUpsertWithoutExtraServicesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutExtraServicesInput, RoomUpdateWithoutExtraServicesInput>, RoomUncheckedUpdateWithoutExtraServicesInput>
  }

  export type UserCreateNestedOneWithoutReviewInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    upsert?: UserUpsertWithoutReviewInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewInput, UserUpdateWithoutReviewInput>, UserUncheckedUpdateWithoutReviewInput>
  }

  export type AdminCreateNestedOneWithoutRestaurantInput = {
    create?: XOR<AdminCreateWithoutRestaurantInput, AdminUncheckedCreateWithoutRestaurantInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRestaurantInput
    connect?: AdminWhereUniqueInput
  }

  export type MenuCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput> | MenuCreateWithoutRestaurantInput[] | MenuUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutRestaurantInput | MenuCreateOrConnectWithoutRestaurantInput[]
    createMany?: MenuCreateManyRestaurantInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type MenuUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput> | MenuCreateWithoutRestaurantInput[] | MenuUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutRestaurantInput | MenuCreateOrConnectWithoutRestaurantInput[]
    createMany?: MenuCreateManyRestaurantInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type AdminUpdateOneRequiredWithoutRestaurantNestedInput = {
    create?: XOR<AdminCreateWithoutRestaurantInput, AdminUncheckedCreateWithoutRestaurantInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRestaurantInput
    upsert?: AdminUpsertWithoutRestaurantInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutRestaurantInput, AdminUpdateWithoutRestaurantInput>, AdminUncheckedUpdateWithoutRestaurantInput>
  }

  export type MenuUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput> | MenuCreateWithoutRestaurantInput[] | MenuUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutRestaurantInput | MenuCreateOrConnectWithoutRestaurantInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutRestaurantInput | MenuUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: MenuCreateManyRestaurantInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutRestaurantInput | MenuUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutRestaurantInput | MenuUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type MenuUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput> | MenuCreateWithoutRestaurantInput[] | MenuUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutRestaurantInput | MenuCreateOrConnectWithoutRestaurantInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutRestaurantInput | MenuUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: MenuCreateManyRestaurantInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutRestaurantInput | MenuUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutRestaurantInput | MenuUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMenuInput = {
    create?: XOR<UserCreateWithoutMenuInput, UserUncheckedCreateWithoutMenuInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenuInput
    connect?: UserWhereUniqueInput
  }

  export type RestaurantCreateNestedOneWithoutMenuInput = {
    create?: XOR<RestaurantCreateWithoutMenuInput, RestaurantUncheckedCreateWithoutMenuInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutMenuInput
    connect?: RestaurantWhereUniqueInput
  }

  export type EnumMenuTypesFieldUpdateOperationsInput = {
    set?: $Enums.MenuTypes
  }

  export type UserUpdateOneRequiredWithoutMenuNestedInput = {
    create?: XOR<UserCreateWithoutMenuInput, UserUncheckedCreateWithoutMenuInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenuInput
    upsert?: UserUpsertWithoutMenuInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMenuInput, UserUpdateWithoutMenuInput>, UserUncheckedUpdateWithoutMenuInput>
  }

  export type RestaurantUpdateOneRequiredWithoutMenuNestedInput = {
    create?: XOR<RestaurantCreateWithoutMenuInput, RestaurantUncheckedCreateWithoutMenuInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutMenuInput
    upsert?: RestaurantUpsertWithoutMenuInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutMenuInput, RestaurantUpdateWithoutMenuInput>, RestaurantUncheckedUpdateWithoutMenuInput>
  }

  export type UserCreateNestedOneWithoutClubHouseInput = {
    create?: XOR<UserCreateWithoutClubHouseInput, UserUncheckedCreateWithoutClubHouseInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubHouseInput
    connect?: UserWhereUniqueInput
  }

  export type EnumclubhouseTypesFieldUpdateOperationsInput = {
    set?: $Enums.clubhouseTypes
  }

  export type UserUpdateOneRequiredWithoutClubHouseNestedInput = {
    create?: XOR<UserCreateWithoutClubHouseInput, UserUncheckedCreateWithoutClubHouseInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubHouseInput
    upsert?: UserUpsertWithoutClubHouseInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClubHouseInput, UserUpdateWithoutClubHouseInput>, UserUncheckedUpdateWithoutClubHouseInput>
  }

  export type NewsCreateimagesInput = {
    set: string[]
  }

  export type AdminCreateNestedOneWithoutNewsInput = {
    create?: XOR<AdminCreateWithoutNewsInput, AdminUncheckedCreateWithoutNewsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutNewsInput
    connect?: AdminWhereUniqueInput
  }

  export type ReplyCreateNestedManyWithoutNewsInput = {
    create?: XOR<ReplyCreateWithoutNewsInput, ReplyUncheckedCreateWithoutNewsInput> | ReplyCreateWithoutNewsInput[] | ReplyUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutNewsInput | ReplyCreateOrConnectWithoutNewsInput[]
    createMany?: ReplyCreateManyNewsInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type ReplyUncheckedCreateNestedManyWithoutNewsInput = {
    create?: XOR<ReplyCreateWithoutNewsInput, ReplyUncheckedCreateWithoutNewsInput> | ReplyCreateWithoutNewsInput[] | ReplyUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutNewsInput | ReplyCreateOrConnectWithoutNewsInput[]
    createMany?: ReplyCreateManyNewsInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type NewsUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminUpdateOneRequiredWithoutNewsNestedInput = {
    create?: XOR<AdminCreateWithoutNewsInput, AdminUncheckedCreateWithoutNewsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutNewsInput
    upsert?: AdminUpsertWithoutNewsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutNewsInput, AdminUpdateWithoutNewsInput>, AdminUncheckedUpdateWithoutNewsInput>
  }

  export type ReplyUpdateManyWithoutNewsNestedInput = {
    create?: XOR<ReplyCreateWithoutNewsInput, ReplyUncheckedCreateWithoutNewsInput> | ReplyCreateWithoutNewsInput[] | ReplyUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutNewsInput | ReplyCreateOrConnectWithoutNewsInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutNewsInput | ReplyUpsertWithWhereUniqueWithoutNewsInput[]
    createMany?: ReplyCreateManyNewsInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutNewsInput | ReplyUpdateWithWhereUniqueWithoutNewsInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutNewsInput | ReplyUpdateManyWithWhereWithoutNewsInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type ReplyUncheckedUpdateManyWithoutNewsNestedInput = {
    create?: XOR<ReplyCreateWithoutNewsInput, ReplyUncheckedCreateWithoutNewsInput> | ReplyCreateWithoutNewsInput[] | ReplyUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutNewsInput | ReplyCreateOrConnectWithoutNewsInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutNewsInput | ReplyUpsertWithWhereUniqueWithoutNewsInput[]
    createMany?: ReplyCreateManyNewsInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutNewsInput | ReplyUpdateWithWhereUniqueWithoutNewsInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutNewsInput | ReplyUpdateManyWithWhereWithoutNewsInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type NewsCreateNestedOneWithoutRepliesInput = {
    create?: XOR<NewsCreateWithoutRepliesInput, NewsUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: NewsCreateOrConnectWithoutRepliesInput
    connect?: NewsWhereUniqueInput
  }

  export type NewsUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<NewsCreateWithoutRepliesInput, NewsUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: NewsCreateOrConnectWithoutRepliesInput
    upsert?: NewsUpsertWithoutRepliesInput
    connect?: NewsWhereUniqueInput
    update?: XOR<XOR<NewsUpdateToOneWithWhereWithoutRepliesInput, NewsUpdateWithoutRepliesInput>, NewsUncheckedUpdateWithoutRepliesInput>
  }

  export type AdminCreateNestedOneWithoutContactInput = {
    create?: XOR<AdminCreateWithoutContactInput, AdminUncheckedCreateWithoutContactInput>
    connectOrCreate?: AdminCreateOrConnectWithoutContactInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneWithoutContactNestedInput = {
    create?: XOR<AdminCreateWithoutContactInput, AdminUncheckedCreateWithoutContactInput>
    connectOrCreate?: AdminCreateOrConnectWithoutContactInput
    upsert?: AdminUpsertWithoutContactInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutContactInput, AdminUpdateWithoutContactInput>, AdminUncheckedUpdateWithoutContactInput>
  }

  export type AdminCreateNestedOneWithoutAppSettingsInput = {
    create?: XOR<AdminCreateWithoutAppSettingsInput, AdminUncheckedCreateWithoutAppSettingsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAppSettingsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutAppSettingsNestedInput = {
    create?: XOR<AdminCreateWithoutAppSettingsInput, AdminUncheckedCreateWithoutAppSettingsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAppSettingsInput
    upsert?: AdminUpsertWithoutAppSettingsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAppSettingsInput, AdminUpdateWithoutAppSettingsInput>, AdminUncheckedUpdateWithoutAppSettingsInput>
  }

  export type AdminCreateNestedOneWithoutHomeSlidersInput = {
    create?: XOR<AdminCreateWithoutHomeSlidersInput, AdminUncheckedCreateWithoutHomeSlidersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutHomeSlidersInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutHomeSlidersNestedInput = {
    create?: XOR<AdminCreateWithoutHomeSlidersInput, AdminUncheckedCreateWithoutHomeSlidersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutHomeSlidersInput
    upsert?: AdminUpsertWithoutHomeSlidersInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutHomeSlidersInput, AdminUpdateWithoutHomeSlidersInput>, AdminUncheckedUpdateWithoutHomeSlidersInput>
  }

  export type AdminCreateNestedOneWithoutPromotionVidInput = {
    create?: XOR<AdminCreateWithoutPromotionVidInput, AdminUncheckedCreateWithoutPromotionVidInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPromotionVidInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutPromotionVidNestedInput = {
    create?: XOR<AdminCreateWithoutPromotionVidInput, AdminUncheckedCreateWithoutPromotionVidInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPromotionVidInput
    upsert?: AdminUpsertWithoutPromotionVidInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutPromotionVidInput, AdminUpdateWithoutPromotionVidInput>, AdminUncheckedUpdateWithoutPromotionVidInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumROLEFilter<$PrismaModel = never> = {
    equals?: $Enums.ROLE | EnumROLEFieldRefInput<$PrismaModel>
    in?: $Enums.ROLE[] | ListEnumROLEFieldRefInput<$PrismaModel>
    notIn?: $Enums.ROLE[] | ListEnumROLEFieldRefInput<$PrismaModel>
    not?: NestedEnumROLEFilter<$PrismaModel> | $Enums.ROLE
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumROLEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ROLE | EnumROLEFieldRefInput<$PrismaModel>
    in?: $Enums.ROLE[] | ListEnumROLEFieldRefInput<$PrismaModel>
    notIn?: $Enums.ROLE[] | ListEnumROLEFieldRefInput<$PrismaModel>
    not?: NestedEnumROLEWithAggregatesFilter<$PrismaModel> | $Enums.ROLE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumROLEFilter<$PrismaModel>
    _max?: NestedEnumROLEFilter<$PrismaModel>
  }

  export type NestedEnumRoomTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomTypes | EnumRoomTypesFieldRefInput<$PrismaModel>
    in?: $Enums.RoomTypes[] | ListEnumRoomTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomTypes[] | ListEnumRoomTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypesFilter<$PrismaModel> | $Enums.RoomTypes
  }

  export type NestedEnumRoomTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomTypes | EnumRoomTypesFieldRefInput<$PrismaModel>
    in?: $Enums.RoomTypes[] | ListEnumRoomTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomTypes[] | ListEnumRoomTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypesWithAggregatesFilter<$PrismaModel> | $Enums.RoomTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypesFilter<$PrismaModel>
    _max?: NestedEnumRoomTypesFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumMenuTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuTypes | EnumMenuTypesFieldRefInput<$PrismaModel>
    in?: $Enums.MenuTypes[] | ListEnumMenuTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuTypes[] | ListEnumMenuTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypesFilter<$PrismaModel> | $Enums.MenuTypes
  }

  export type NestedEnumMenuTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuTypes | EnumMenuTypesFieldRefInput<$PrismaModel>
    in?: $Enums.MenuTypes[] | ListEnumMenuTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuTypes[] | ListEnumMenuTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypesWithAggregatesFilter<$PrismaModel> | $Enums.MenuTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuTypesFilter<$PrismaModel>
    _max?: NestedEnumMenuTypesFilter<$PrismaModel>
  }

  export type NestedEnumclubhouseTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.clubhouseTypes | EnumclubhouseTypesFieldRefInput<$PrismaModel>
    in?: $Enums.clubhouseTypes[] | ListEnumclubhouseTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.clubhouseTypes[] | ListEnumclubhouseTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumclubhouseTypesFilter<$PrismaModel> | $Enums.clubhouseTypes
  }

  export type NestedEnumclubhouseTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.clubhouseTypes | EnumclubhouseTypesFieldRefInput<$PrismaModel>
    in?: $Enums.clubhouseTypes[] | ListEnumclubhouseTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.clubhouseTypes[] | ListEnumclubhouseTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumclubhouseTypesWithAggregatesFilter<$PrismaModel> | $Enums.clubhouseTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumclubhouseTypesFilter<$PrismaModel>
    _max?: NestedEnumclubhouseTypesFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NewsCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    subTitle: string
    description: string
    images?: NewsCreateimagesInput | string[]
    isDeleted?: boolean
    replies?: ReplyCreateNestedManyWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    subTitle: string
    description: string
    images?: NewsCreateimagesInput | string[]
    isDeleted?: boolean
    replies?: ReplyUncheckedCreateNestedManyWithoutNewsInput
  }

  export type NewsCreateOrConnectWithoutAdminInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutAdminInput, NewsUncheckedCreateWithoutAdminInput>
  }

  export type NewsCreateManyAdminInputEnvelope = {
    data: NewsCreateManyAdminInput | NewsCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ContactUsCreateWithoutByAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    phoneNum: string
    subject: string
    description: string
    isDeleted?: boolean
    isRead?: boolean
  }

  export type ContactUsUncheckedCreateWithoutByAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    phoneNum: string
    subject: string
    description: string
    isDeleted?: boolean
    isRead?: boolean
  }

  export type ContactUsCreateOrConnectWithoutByAdminInput = {
    where: ContactUsWhereUniqueInput
    create: XOR<ContactUsCreateWithoutByAdminInput, ContactUsUncheckedCreateWithoutByAdminInput>
  }

  export type ContactUsCreateManyByAdminInputEnvelope = {
    data: ContactUsCreateManyByAdminInput | ContactUsCreateManyByAdminInput[]
    skipDuplicates?: boolean
  }

  export type RestaurantCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    menu?: MenuCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    menu?: MenuUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutUserInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutUserInput, RestaurantUncheckedCreateWithoutUserInput>
  }

  export type RestaurantCreateManyUserInputEnvelope = {
    data: RestaurantCreateManyUserInput | RestaurantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AppSettingsCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelName: string
    logo: string
    address: string
    phoneNum: string
    email: string
    socialMedia: JsonNullValueInput | InputJsonValue
  }

  export type AppSettingsUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelName: string
    logo: string
    address: string
    phoneNum: string
    email: string
    socialMedia: JsonNullValueInput | InputJsonValue
  }

  export type AppSettingsCreateOrConnectWithoutAdminInput = {
    where: AppSettingsWhereUniqueInput
    create: XOR<AppSettingsCreateWithoutAdminInput, AppSettingsUncheckedCreateWithoutAdminInput>
  }

  export type AppSettingsCreateManyAdminInputEnvelope = {
    data: AppSettingsCreateManyAdminInput | AppSettingsCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ResetTokenCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    token: string
    expireAt: Date | string
    user?: UserCreateNestedOneWithoutResetTokenInput
  }

  export type ResetTokenUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    token: string
    userId?: string | null
    expireAt: Date | string
  }

  export type ResetTokenCreateOrConnectWithoutAdminInput = {
    where: ResetTokenWhereUniqueInput
    create: XOR<ResetTokenCreateWithoutAdminInput, ResetTokenUncheckedCreateWithoutAdminInput>
  }

  export type ConfirmTokenCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    token: string
    expireAt: Date | string
    user?: UserCreateNestedOneWithoutConfirmTokenInput
  }

  export type ConfirmTokenUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    token: string
    userId?: string | null
    expireAt: Date | string
  }

  export type ConfirmTokenCreateOrConnectWithoutAdminInput = {
    where: ConfirmTokenWhereUniqueInput
    create: XOR<ConfirmTokenCreateWithoutAdminInput, ConfirmTokenUncheckedCreateWithoutAdminInput>
  }

  export type RefreshTokenCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    token: string
    expireAt: Date | string
    user?: UserCreateNestedOneWithoutRefreshTokenInput
  }

  export type RefreshTokenUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    token: string
    userId?: string | null
    expireAt: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutAdminInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutAdminInput, RefreshTokenUncheckedCreateWithoutAdminInput>
  }

  export type HomeSlidersCreateWithoutByAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: string
    header: string
    paragraph: string
    isDeleted?: boolean
  }

  export type HomeSlidersUncheckedCreateWithoutByAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: string
    header: string
    paragraph: string
    isDeleted?: boolean
  }

  export type HomeSlidersCreateOrConnectWithoutByAdminInput = {
    where: HomeSlidersWhereUniqueInput
    create: XOR<HomeSlidersCreateWithoutByAdminInput, HomeSlidersUncheckedCreateWithoutByAdminInput>
  }

  export type HomeSlidersCreateManyByAdminInputEnvelope = {
    data: HomeSlidersCreateManyByAdminInput | HomeSlidersCreateManyByAdminInput[]
    skipDuplicates?: boolean
  }

  export type PromotionVidCreateWithoutByAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    video: string
    description: string
  }

  export type PromotionVidUncheckedCreateWithoutByAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    video: string
    description: string
  }

  export type PromotionVidCreateOrConnectWithoutByAdminInput = {
    where: PromotionVidWhereUniqueInput
    create: XOR<PromotionVidCreateWithoutByAdminInput, PromotionVidUncheckedCreateWithoutByAdminInput>
  }

  export type NewsUpsertWithWhereUniqueWithoutAdminInput = {
    where: NewsWhereUniqueInput
    update: XOR<NewsUpdateWithoutAdminInput, NewsUncheckedUpdateWithoutAdminInput>
    create: XOR<NewsCreateWithoutAdminInput, NewsUncheckedCreateWithoutAdminInput>
  }

  export type NewsUpdateWithWhereUniqueWithoutAdminInput = {
    where: NewsWhereUniqueInput
    data: XOR<NewsUpdateWithoutAdminInput, NewsUncheckedUpdateWithoutAdminInput>
  }

  export type NewsUpdateManyWithWhereWithoutAdminInput = {
    where: NewsScalarWhereInput
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyWithoutAdminInput>
  }

  export type NewsScalarWhereInput = {
    AND?: NewsScalarWhereInput | NewsScalarWhereInput[]
    OR?: NewsScalarWhereInput[]
    NOT?: NewsScalarWhereInput | NewsScalarWhereInput[]
    id?: StringFilter<"News"> | string
    adminId?: StringFilter<"News"> | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
    title?: StringFilter<"News"> | string
    subTitle?: StringFilter<"News"> | string
    description?: StringFilter<"News"> | string
    images?: StringNullableListFilter<"News">
    isDeleted?: BoolFilter<"News"> | boolean
  }

  export type ContactUsUpsertWithWhereUniqueWithoutByAdminInput = {
    where: ContactUsWhereUniqueInput
    update: XOR<ContactUsUpdateWithoutByAdminInput, ContactUsUncheckedUpdateWithoutByAdminInput>
    create: XOR<ContactUsCreateWithoutByAdminInput, ContactUsUncheckedCreateWithoutByAdminInput>
  }

  export type ContactUsUpdateWithWhereUniqueWithoutByAdminInput = {
    where: ContactUsWhereUniqueInput
    data: XOR<ContactUsUpdateWithoutByAdminInput, ContactUsUncheckedUpdateWithoutByAdminInput>
  }

  export type ContactUsUpdateManyWithWhereWithoutByAdminInput = {
    where: ContactUsScalarWhereInput
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyWithoutByAdminInput>
  }

  export type ContactUsScalarWhereInput = {
    AND?: ContactUsScalarWhereInput | ContactUsScalarWhereInput[]
    OR?: ContactUsScalarWhereInput[]
    NOT?: ContactUsScalarWhereInput | ContactUsScalarWhereInput[]
    id?: StringFilter<"ContactUs"> | string
    adminId?: StringNullableFilter<"ContactUs"> | string | null
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeFilter<"ContactUs"> | Date | string
    fullName?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    phoneNum?: StringFilter<"ContactUs"> | string
    subject?: StringFilter<"ContactUs"> | string
    description?: StringFilter<"ContactUs"> | string
    isDeleted?: BoolFilter<"ContactUs"> | boolean
    isRead?: BoolFilter<"ContactUs"> | boolean
  }

  export type RestaurantUpsertWithWhereUniqueWithoutUserInput = {
    where: RestaurantWhereUniqueInput
    update: XOR<RestaurantUpdateWithoutUserInput, RestaurantUncheckedUpdateWithoutUserInput>
    create: XOR<RestaurantCreateWithoutUserInput, RestaurantUncheckedCreateWithoutUserInput>
  }

  export type RestaurantUpdateWithWhereUniqueWithoutUserInput = {
    where: RestaurantWhereUniqueInput
    data: XOR<RestaurantUpdateWithoutUserInput, RestaurantUncheckedUpdateWithoutUserInput>
  }

  export type RestaurantUpdateManyWithWhereWithoutUserInput = {
    where: RestaurantScalarWhereInput
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyWithoutUserInput>
  }

  export type RestaurantScalarWhereInput = {
    AND?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
    OR?: RestaurantScalarWhereInput[]
    NOT?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
    id?: StringFilter<"Restaurant"> | string
    adminId?: StringFilter<"Restaurant"> | string
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    description?: StringFilter<"Restaurant"> | string
  }

  export type AppSettingsUpsertWithWhereUniqueWithoutAdminInput = {
    where: AppSettingsWhereUniqueInput
    update: XOR<AppSettingsUpdateWithoutAdminInput, AppSettingsUncheckedUpdateWithoutAdminInput>
    create: XOR<AppSettingsCreateWithoutAdminInput, AppSettingsUncheckedCreateWithoutAdminInput>
  }

  export type AppSettingsUpdateWithWhereUniqueWithoutAdminInput = {
    where: AppSettingsWhereUniqueInput
    data: XOR<AppSettingsUpdateWithoutAdminInput, AppSettingsUncheckedUpdateWithoutAdminInput>
  }

  export type AppSettingsUpdateManyWithWhereWithoutAdminInput = {
    where: AppSettingsScalarWhereInput
    data: XOR<AppSettingsUpdateManyMutationInput, AppSettingsUncheckedUpdateManyWithoutAdminInput>
  }

  export type AppSettingsScalarWhereInput = {
    AND?: AppSettingsScalarWhereInput | AppSettingsScalarWhereInput[]
    OR?: AppSettingsScalarWhereInput[]
    NOT?: AppSettingsScalarWhereInput | AppSettingsScalarWhereInput[]
    id?: StringFilter<"AppSettings"> | string
    adminId?: StringFilter<"AppSettings"> | string
    createdAt?: DateTimeFilter<"AppSettings"> | Date | string
    updatedAt?: DateTimeFilter<"AppSettings"> | Date | string
    hotelName?: StringFilter<"AppSettings"> | string
    logo?: StringFilter<"AppSettings"> | string
    address?: StringFilter<"AppSettings"> | string
    phoneNum?: StringFilter<"AppSettings"> | string
    email?: StringFilter<"AppSettings"> | string
    socialMedia?: JsonFilter<"AppSettings">
  }

  export type ResetTokenUpsertWithoutAdminInput = {
    update: XOR<ResetTokenUpdateWithoutAdminInput, ResetTokenUncheckedUpdateWithoutAdminInput>
    create: XOR<ResetTokenCreateWithoutAdminInput, ResetTokenUncheckedCreateWithoutAdminInput>
    where?: ResetTokenWhereInput
  }

  export type ResetTokenUpdateToOneWithWhereWithoutAdminInput = {
    where?: ResetTokenWhereInput
    data: XOR<ResetTokenUpdateWithoutAdminInput, ResetTokenUncheckedUpdateWithoutAdminInput>
  }

  export type ResetTokenUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResetTokenNestedInput
  }

  export type ResetTokenUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfirmTokenUpsertWithoutAdminInput = {
    update: XOR<ConfirmTokenUpdateWithoutAdminInput, ConfirmTokenUncheckedUpdateWithoutAdminInput>
    create: XOR<ConfirmTokenCreateWithoutAdminInput, ConfirmTokenUncheckedCreateWithoutAdminInput>
    where?: ConfirmTokenWhereInput
  }

  export type ConfirmTokenUpdateToOneWithWhereWithoutAdminInput = {
    where?: ConfirmTokenWhereInput
    data: XOR<ConfirmTokenUpdateWithoutAdminInput, ConfirmTokenUncheckedUpdateWithoutAdminInput>
  }

  export type ConfirmTokenUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutConfirmTokenNestedInput
  }

  export type ConfirmTokenUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpsertWithoutAdminInput = {
    update: XOR<RefreshTokenUpdateWithoutAdminInput, RefreshTokenUncheckedUpdateWithoutAdminInput>
    create: XOR<RefreshTokenCreateWithoutAdminInput, RefreshTokenUncheckedCreateWithoutAdminInput>
    where?: RefreshTokenWhereInput
  }

  export type RefreshTokenUpdateToOneWithWhereWithoutAdminInput = {
    where?: RefreshTokenWhereInput
    data: XOR<RefreshTokenUpdateWithoutAdminInput, RefreshTokenUncheckedUpdateWithoutAdminInput>
  }

  export type RefreshTokenUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeSlidersUpsertWithWhereUniqueWithoutByAdminInput = {
    where: HomeSlidersWhereUniqueInput
    update: XOR<HomeSlidersUpdateWithoutByAdminInput, HomeSlidersUncheckedUpdateWithoutByAdminInput>
    create: XOR<HomeSlidersCreateWithoutByAdminInput, HomeSlidersUncheckedCreateWithoutByAdminInput>
  }

  export type HomeSlidersUpdateWithWhereUniqueWithoutByAdminInput = {
    where: HomeSlidersWhereUniqueInput
    data: XOR<HomeSlidersUpdateWithoutByAdminInput, HomeSlidersUncheckedUpdateWithoutByAdminInput>
  }

  export type HomeSlidersUpdateManyWithWhereWithoutByAdminInput = {
    where: HomeSlidersScalarWhereInput
    data: XOR<HomeSlidersUpdateManyMutationInput, HomeSlidersUncheckedUpdateManyWithoutByAdminInput>
  }

  export type HomeSlidersScalarWhereInput = {
    AND?: HomeSlidersScalarWhereInput | HomeSlidersScalarWhereInput[]
    OR?: HomeSlidersScalarWhereInput[]
    NOT?: HomeSlidersScalarWhereInput | HomeSlidersScalarWhereInput[]
    id?: StringFilter<"HomeSliders"> | string
    adminId?: StringFilter<"HomeSliders"> | string
    createdAt?: DateTimeFilter<"HomeSliders"> | Date | string
    updatedAt?: DateTimeFilter<"HomeSliders"> | Date | string
    photo?: StringFilter<"HomeSliders"> | string
    header?: StringFilter<"HomeSliders"> | string
    paragraph?: StringFilter<"HomeSliders"> | string
    isDeleted?: BoolFilter<"HomeSliders"> | boolean
  }

  export type PromotionVidUpsertWithoutByAdminInput = {
    update: XOR<PromotionVidUpdateWithoutByAdminInput, PromotionVidUncheckedUpdateWithoutByAdminInput>
    create: XOR<PromotionVidCreateWithoutByAdminInput, PromotionVidUncheckedCreateWithoutByAdminInput>
    where?: PromotionVidWhereInput
  }

  export type PromotionVidUpdateToOneWithWhereWithoutByAdminInput = {
    where?: PromotionVidWhereInput
    data: XOR<PromotionVidUpdateWithoutByAdminInput, PromotionVidUncheckedUpdateWithoutByAdminInput>
  }

  export type PromotionVidUpdateWithoutByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionVidUncheckedUpdateWithoutByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RoomReservationCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: Date | string
    checkOut: Date | string
    adults: number
    children: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    room: RoomCreateNestedOneWithoutUserInput
  }

  export type RoomReservationUncheckedCreateWithoutUserInput = {
    id?: string
    roomId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: Date | string
    checkOut: Date | string
    adults: number
    children: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type RoomReservationCreateOrConnectWithoutUserInput = {
    where: RoomReservationWhereUniqueInput
    create: XOR<RoomReservationCreateWithoutUserInput, RoomReservationUncheckedCreateWithoutUserInput>
  }

  export type RoomReservationCreateManyUserInputEnvelope = {
    data: RoomReservationCreateManyUserInput | RoomReservationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: number
    comment: string
    isDeleted?: boolean
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: number
    comment: string
    isDeleted?: boolean
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type MenuCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    restaurant: RestaurantCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutUserInput = {
    id?: string
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MenuCreateOrConnectWithoutUserInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutUserInput, MenuUncheckedCreateWithoutUserInput>
  }

  export type MenuCreateManyUserInputEnvelope = {
    data: MenuCreateManyUserInput | MenuCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClubHouseCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clubhouseTypes: $Enums.clubhouseTypes
    description: string
    startTime: Date | string
    endTime: Date | string
    isDeleted?: boolean
  }

  export type ClubHouseUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clubhouseTypes: $Enums.clubhouseTypes
    description: string
    startTime: Date | string
    endTime: Date | string
    isDeleted?: boolean
  }

  export type ClubHouseCreateOrConnectWithoutUserInput = {
    where: ClubHouseWhereUniqueInput
    create: XOR<ClubHouseCreateWithoutUserInput, ClubHouseUncheckedCreateWithoutUserInput>
  }

  export type ClubHouseCreateManyUserInputEnvelope = {
    data: ClubHouseCreateManyUserInput | ClubHouseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResetTokenCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    token: string
    expireAt: Date | string
    admin?: AdminCreateNestedOneWithoutResetTokenInput
  }

  export type ResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    token: string
    adminId?: string | null
    expireAt: Date | string
  }

  export type ResetTokenCreateOrConnectWithoutUserInput = {
    where: ResetTokenWhereUniqueInput
    create: XOR<ResetTokenCreateWithoutUserInput, ResetTokenUncheckedCreateWithoutUserInput>
  }

  export type ConfirmTokenCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    token: string
    expireAt: Date | string
    admin?: AdminCreateNestedOneWithoutConfirmTokenInput
  }

  export type ConfirmTokenUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    token: string
    adminId?: string | null
    expireAt: Date | string
  }

  export type ConfirmTokenCreateOrConnectWithoutUserInput = {
    where: ConfirmTokenWhereUniqueInput
    create: XOR<ConfirmTokenCreateWithoutUserInput, ConfirmTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    token: string
    expireAt: Date | string
    admin?: AdminCreateNestedOneWithoutRefreshTokenInput
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    token: string
    adminId?: string | null
    expireAt: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RoomReservationUpsertWithWhereUniqueWithoutUserInput = {
    where: RoomReservationWhereUniqueInput
    update: XOR<RoomReservationUpdateWithoutUserInput, RoomReservationUncheckedUpdateWithoutUserInput>
    create: XOR<RoomReservationCreateWithoutUserInput, RoomReservationUncheckedCreateWithoutUserInput>
  }

  export type RoomReservationUpdateWithWhereUniqueWithoutUserInput = {
    where: RoomReservationWhereUniqueInput
    data: XOR<RoomReservationUpdateWithoutUserInput, RoomReservationUncheckedUpdateWithoutUserInput>
  }

  export type RoomReservationUpdateManyWithWhereWithoutUserInput = {
    where: RoomReservationScalarWhereInput
    data: XOR<RoomReservationUpdateManyMutationInput, RoomReservationUncheckedUpdateManyWithoutUserInput>
  }

  export type RoomReservationScalarWhereInput = {
    AND?: RoomReservationScalarWhereInput | RoomReservationScalarWhereInput[]
    OR?: RoomReservationScalarWhereInput[]
    NOT?: RoomReservationScalarWhereInput | RoomReservationScalarWhereInput[]
    id?: StringFilter<"RoomReservation"> | string
    userId?: StringFilter<"RoomReservation"> | string
    roomId?: StringFilter<"RoomReservation"> | string
    createdAt?: DateTimeFilter<"RoomReservation"> | Date | string
    updatedAt?: DateTimeFilter<"RoomReservation"> | Date | string
    checkIn?: DateTimeFilter<"RoomReservation"> | Date | string
    checkOut?: DateTimeFilter<"RoomReservation"> | Date | string
    adults?: IntFilter<"RoomReservation"> | number
    children?: IntFilter<"RoomReservation"> | number
    isDeleted?: BoolFilter<"RoomReservation"> | boolean
    deletedAt?: DateTimeNullableFilter<"RoomReservation"> | Date | string | null
  }

  export type ReviewUpsertWithoutUserInput = {
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutUserInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MenuUpsertWithWhereUniqueWithoutUserInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutUserInput, MenuUncheckedUpdateWithoutUserInput>
    create: XOR<MenuCreateWithoutUserInput, MenuUncheckedCreateWithoutUserInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutUserInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutUserInput, MenuUncheckedUpdateWithoutUserInput>
  }

  export type MenuUpdateManyWithWhereWithoutUserInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutUserInput>
  }

  export type MenuScalarWhereInput = {
    AND?: MenuScalarWhereInput | MenuScalarWhereInput[]
    OR?: MenuScalarWhereInput[]
    NOT?: MenuScalarWhereInput | MenuScalarWhereInput[]
    id?: StringFilter<"Menu"> | string
    userId?: StringFilter<"Menu"> | string
    restaurantId?: StringFilter<"Menu"> | string
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    menuTypes?: EnumMenuTypesFilter<"Menu"> | $Enums.MenuTypes
    name?: StringFilter<"Menu"> | string
    ingredients?: StringFilter<"Menu"> | string
    price?: StringFilter<"Menu"> | string
    image?: StringFilter<"Menu"> | string
    isDeleted?: BoolFilter<"Menu"> | boolean
    deletedAt?: DateTimeNullableFilter<"Menu"> | Date | string | null
  }

  export type ClubHouseUpsertWithWhereUniqueWithoutUserInput = {
    where: ClubHouseWhereUniqueInput
    update: XOR<ClubHouseUpdateWithoutUserInput, ClubHouseUncheckedUpdateWithoutUserInput>
    create: XOR<ClubHouseCreateWithoutUserInput, ClubHouseUncheckedCreateWithoutUserInput>
  }

  export type ClubHouseUpdateWithWhereUniqueWithoutUserInput = {
    where: ClubHouseWhereUniqueInput
    data: XOR<ClubHouseUpdateWithoutUserInput, ClubHouseUncheckedUpdateWithoutUserInput>
  }

  export type ClubHouseUpdateManyWithWhereWithoutUserInput = {
    where: ClubHouseScalarWhereInput
    data: XOR<ClubHouseUpdateManyMutationInput, ClubHouseUncheckedUpdateManyWithoutUserInput>
  }

  export type ClubHouseScalarWhereInput = {
    AND?: ClubHouseScalarWhereInput | ClubHouseScalarWhereInput[]
    OR?: ClubHouseScalarWhereInput[]
    NOT?: ClubHouseScalarWhereInput | ClubHouseScalarWhereInput[]
    id?: StringFilter<"ClubHouse"> | string
    userId?: StringFilter<"ClubHouse"> | string
    createdAt?: DateTimeFilter<"ClubHouse"> | Date | string
    updatedAt?: DateTimeFilter<"ClubHouse"> | Date | string
    clubhouseTypes?: EnumclubhouseTypesFilter<"ClubHouse"> | $Enums.clubhouseTypes
    description?: StringFilter<"ClubHouse"> | string
    startTime?: DateTimeFilter<"ClubHouse"> | Date | string
    endTime?: DateTimeFilter<"ClubHouse"> | Date | string
    isDeleted?: BoolFilter<"ClubHouse"> | boolean
  }

  export type ResetTokenUpsertWithoutUserInput = {
    update: XOR<ResetTokenUpdateWithoutUserInput, ResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<ResetTokenCreateWithoutUserInput, ResetTokenUncheckedCreateWithoutUserInput>
    where?: ResetTokenWhereInput
  }

  export type ResetTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: ResetTokenWhereInput
    data: XOR<ResetTokenUpdateWithoutUserInput, ResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type ResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutResetTokenNestedInput
  }

  export type ResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfirmTokenUpsertWithoutUserInput = {
    update: XOR<ConfirmTokenUpdateWithoutUserInput, ConfirmTokenUncheckedUpdateWithoutUserInput>
    create: XOR<ConfirmTokenCreateWithoutUserInput, ConfirmTokenUncheckedCreateWithoutUserInput>
    where?: ConfirmTokenWhereInput
  }

  export type ConfirmTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: ConfirmTokenWhereInput
    data: XOR<ConfirmTokenUpdateWithoutUserInput, ConfirmTokenUncheckedUpdateWithoutUserInput>
  }

  export type ConfirmTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutConfirmTokenNestedInput
  }

  export type ConfirmTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpsertWithoutUserInput = {
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
    where?: RefreshTokenWhereInput
  }

  export type RefreshTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: RefreshTokenWhereInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutResetTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedOneWithoutUserInput
    menu?: MenuCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseCreateNestedManyWithoutUserInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResetTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedOneWithoutUserInput
    menu?: MenuUncheckedCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseUncheckedCreateNestedManyWithoutUserInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResetTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResetTokenInput, UserUncheckedCreateWithoutResetTokenInput>
  }

  export type AdminCreateWithoutResetTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsCreateNestedManyWithoutAdminInput
    contact?: ContactUsCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsCreateNestedManyWithoutAdminInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidCreateNestedOneWithoutByAdminInput
  }

  export type AdminUncheckedCreateWithoutResetTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsUncheckedCreateNestedManyWithoutAdminInput
    contact?: ContactUsUncheckedCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsUncheckedCreateNestedManyWithoutAdminInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidUncheckedCreateNestedOneWithoutByAdminInput
  }

  export type AdminCreateOrConnectWithoutResetTokenInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutResetTokenInput, AdminUncheckedCreateWithoutResetTokenInput>
  }

  export type UserUpsertWithoutResetTokenInput = {
    update: XOR<UserUpdateWithoutResetTokenInput, UserUncheckedUpdateWithoutResetTokenInput>
    create: XOR<UserCreateWithoutResetTokenInput, UserUncheckedCreateWithoutResetTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResetTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResetTokenInput, UserUncheckedUpdateWithoutResetTokenInput>
  }

  export type UserUpdateWithoutResetTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateOneWithoutUserNestedInput
    menu?: MenuUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUpdateManyWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResetTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateOneWithoutUserNestedInput
    menu?: MenuUncheckedUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUncheckedUpdateManyWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdminUpsertWithoutResetTokenInput = {
    update: XOR<AdminUpdateWithoutResetTokenInput, AdminUncheckedUpdateWithoutResetTokenInput>
    create: XOR<AdminCreateWithoutResetTokenInput, AdminUncheckedCreateWithoutResetTokenInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutResetTokenInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutResetTokenInput, AdminUncheckedUpdateWithoutResetTokenInput>
  }

  export type AdminUpdateWithoutResetTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUpdateManyWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUpdateOneWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutResetTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUncheckedUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUncheckedUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUncheckedUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUncheckedUpdateManyWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput
  }

  export type UserCreateWithoutConfirmTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedOneWithoutUserInput
    menu?: MenuCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConfirmTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedOneWithoutUserInput
    menu?: MenuUncheckedCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseUncheckedCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConfirmTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConfirmTokenInput, UserUncheckedCreateWithoutConfirmTokenInput>
  }

  export type AdminCreateWithoutConfirmTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsCreateNestedManyWithoutAdminInput
    contact?: ContactUsCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidCreateNestedOneWithoutByAdminInput
  }

  export type AdminUncheckedCreateWithoutConfirmTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsUncheckedCreateNestedManyWithoutAdminInput
    contact?: ContactUsUncheckedCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsUncheckedCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidUncheckedCreateNestedOneWithoutByAdminInput
  }

  export type AdminCreateOrConnectWithoutConfirmTokenInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutConfirmTokenInput, AdminUncheckedCreateWithoutConfirmTokenInput>
  }

  export type UserUpsertWithoutConfirmTokenInput = {
    update: XOR<UserUpdateWithoutConfirmTokenInput, UserUncheckedUpdateWithoutConfirmTokenInput>
    create: XOR<UserCreateWithoutConfirmTokenInput, UserUncheckedCreateWithoutConfirmTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConfirmTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConfirmTokenInput, UserUncheckedUpdateWithoutConfirmTokenInput>
  }

  export type UserUpdateWithoutConfirmTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateOneWithoutUserNestedInput
    menu?: MenuUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConfirmTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateOneWithoutUserNestedInput
    menu?: MenuUncheckedUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUncheckedUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdminUpsertWithoutConfirmTokenInput = {
    update: XOR<AdminUpdateWithoutConfirmTokenInput, AdminUncheckedUpdateWithoutConfirmTokenInput>
    create: XOR<AdminCreateWithoutConfirmTokenInput, AdminUncheckedCreateWithoutConfirmTokenInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutConfirmTokenInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutConfirmTokenInput, AdminUncheckedUpdateWithoutConfirmTokenInput>
  }

  export type AdminUpdateWithoutConfirmTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUpdateOneWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutConfirmTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUncheckedUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUncheckedUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUncheckedUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUncheckedUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput
  }

  export type UserCreateWithoutRefreshTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedOneWithoutUserInput
    menu?: MenuCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedOneWithoutUserInput
    menu?: MenuUncheckedCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseUncheckedCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
  }

  export type AdminCreateWithoutRefreshTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsCreateNestedManyWithoutAdminInput
    contact?: ContactUsCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidCreateNestedOneWithoutByAdminInput
  }

  export type AdminUncheckedCreateWithoutRefreshTokenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsUncheckedCreateNestedManyWithoutAdminInput
    contact?: ContactUsUncheckedCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsUncheckedCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidUncheckedCreateNestedOneWithoutByAdminInput
  }

  export type AdminCreateOrConnectWithoutRefreshTokenInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutRefreshTokenInput, AdminUncheckedCreateWithoutRefreshTokenInput>
  }

  export type UserUpsertWithoutRefreshTokenInput = {
    update: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type UserUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateOneWithoutUserNestedInput
    menu?: MenuUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateOneWithoutUserNestedInput
    menu?: MenuUncheckedUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUncheckedUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdminUpsertWithoutRefreshTokenInput = {
    update: XOR<AdminUpdateWithoutRefreshTokenInput, AdminUncheckedUpdateWithoutRefreshTokenInput>
    create: XOR<AdminCreateWithoutRefreshTokenInput, AdminUncheckedCreateWithoutRefreshTokenInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutRefreshTokenInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutRefreshTokenInput, AdminUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type AdminUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUpdateOneWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUncheckedUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUncheckedUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUncheckedUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUncheckedUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput
  }

  export type ExtraServicesCreateWithoutRoomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    price: string
    facilities?: ExtraServicesCreatefacilitiesInput | string[]
    isDeleted?: boolean
  }

  export type ExtraServicesUncheckedCreateWithoutRoomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    price: string
    facilities?: ExtraServicesCreatefacilitiesInput | string[]
    isDeleted?: boolean
  }

  export type ExtraServicesCreateOrConnectWithoutRoomInput = {
    where: ExtraServicesWhereUniqueInput
    create: XOR<ExtraServicesCreateWithoutRoomInput, ExtraServicesUncheckedCreateWithoutRoomInput>
  }

  export type ExtraServicesCreateManyRoomInputEnvelope = {
    data: ExtraServicesCreateManyRoomInput | ExtraServicesCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoomReservationCreateWithoutRoomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: Date | string
    checkOut: Date | string
    adults: number
    children: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRoomInput
  }

  export type RoomReservationUncheckedCreateWithoutRoomInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: Date | string
    checkOut: Date | string
    adults: number
    children: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type RoomReservationCreateOrConnectWithoutRoomInput = {
    where: RoomReservationWhereUniqueInput
    create: XOR<RoomReservationCreateWithoutRoomInput, RoomReservationUncheckedCreateWithoutRoomInput>
  }

  export type RoomReservationCreateManyRoomInputEnvelope = {
    data: RoomReservationCreateManyRoomInput | RoomReservationCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type ExtraServicesUpsertWithWhereUniqueWithoutRoomInput = {
    where: ExtraServicesWhereUniqueInput
    update: XOR<ExtraServicesUpdateWithoutRoomInput, ExtraServicesUncheckedUpdateWithoutRoomInput>
    create: XOR<ExtraServicesCreateWithoutRoomInput, ExtraServicesUncheckedCreateWithoutRoomInput>
  }

  export type ExtraServicesUpdateWithWhereUniqueWithoutRoomInput = {
    where: ExtraServicesWhereUniqueInput
    data: XOR<ExtraServicesUpdateWithoutRoomInput, ExtraServicesUncheckedUpdateWithoutRoomInput>
  }

  export type ExtraServicesUpdateManyWithWhereWithoutRoomInput = {
    where: ExtraServicesScalarWhereInput
    data: XOR<ExtraServicesUpdateManyMutationInput, ExtraServicesUncheckedUpdateManyWithoutRoomInput>
  }

  export type ExtraServicesScalarWhereInput = {
    AND?: ExtraServicesScalarWhereInput | ExtraServicesScalarWhereInput[]
    OR?: ExtraServicesScalarWhereInput[]
    NOT?: ExtraServicesScalarWhereInput | ExtraServicesScalarWhereInput[]
    id?: StringFilter<"ExtraServices"> | string
    roomId?: StringFilter<"ExtraServices"> | string
    createdAt?: DateTimeFilter<"ExtraServices"> | Date | string
    updatedAt?: DateTimeFilter<"ExtraServices"> | Date | string
    name?: StringFilter<"ExtraServices"> | string
    price?: StringFilter<"ExtraServices"> | string
    facilities?: StringNullableListFilter<"ExtraServices">
    isDeleted?: BoolFilter<"ExtraServices"> | boolean
  }

  export type RoomReservationUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomReservationWhereUniqueInput
    update: XOR<RoomReservationUpdateWithoutRoomInput, RoomReservationUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomReservationCreateWithoutRoomInput, RoomReservationUncheckedCreateWithoutRoomInput>
  }

  export type RoomReservationUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomReservationWhereUniqueInput
    data: XOR<RoomReservationUpdateWithoutRoomInput, RoomReservationUncheckedUpdateWithoutRoomInput>
  }

  export type RoomReservationUpdateManyWithWhereWithoutRoomInput = {
    where: RoomReservationScalarWhereInput
    data: XOR<RoomReservationUpdateManyMutationInput, RoomReservationUncheckedUpdateManyWithoutRoomInput>
  }

  export type UserCreateWithoutRoomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    review?: ReviewCreateNestedOneWithoutUserInput
    menu?: MenuCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    review?: ReviewUncheckedCreateNestedOneWithoutUserInput
    menu?: MenuUncheckedCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseUncheckedCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoomInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomInput, UserUncheckedCreateWithoutRoomInput>
  }

  export type RoomCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomNum: string
    types?: $Enums.RoomTypes
    price: string
    description: string
    aminities?: RoomCreateaminitiesInput | string[]
    images?: RoomCreateimagesInput | string[]
    view: string
    isDeleted?: boolean
    extraServices?: ExtraServicesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomNum: string
    types?: $Enums.RoomTypes
    price: string
    description: string
    aminities?: RoomCreateaminitiesInput | string[]
    images?: RoomCreateimagesInput | string[]
    view: string
    isDeleted?: boolean
    extraServices?: ExtraServicesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutUserInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutUserInput, RoomUncheckedCreateWithoutUserInput>
  }

  export type UserUpsertWithoutRoomInput = {
    update: XOR<UserUpdateWithoutRoomInput, UserUncheckedUpdateWithoutRoomInput>
    create: XOR<UserCreateWithoutRoomInput, UserUncheckedCreateWithoutRoomInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoomInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoomInput, UserUncheckedUpdateWithoutRoomInput>
  }

  export type UserUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    review?: ReviewUpdateOneWithoutUserNestedInput
    menu?: MenuUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    review?: ReviewUncheckedUpdateOneWithoutUserNestedInput
    menu?: MenuUncheckedUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUncheckedUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RoomUpsertWithoutUserInput = {
    update: XOR<RoomUpdateWithoutUserInput, RoomUncheckedUpdateWithoutUserInput>
    create: XOR<RoomCreateWithoutUserInput, RoomUncheckedCreateWithoutUserInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutUserInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutUserInput, RoomUncheckedUpdateWithoutUserInput>
  }

  export type RoomUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNum?: StringFieldUpdateOperationsInput | string
    types?: EnumRoomTypesFieldUpdateOperationsInput | $Enums.RoomTypes
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    aminities?: RoomUpdateaminitiesInput | string[]
    images?: RoomUpdateimagesInput | string[]
    view?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    extraServices?: ExtraServicesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNum?: StringFieldUpdateOperationsInput | string
    types?: EnumRoomTypesFieldUpdateOperationsInput | $Enums.RoomTypes
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    aminities?: RoomUpdateaminitiesInput | string[]
    images?: RoomUpdateimagesInput | string[]
    view?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    extraServices?: ExtraServicesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateWithoutExtraServicesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomNum: string
    types?: $Enums.RoomTypes
    price: string
    description: string
    aminities?: RoomCreateaminitiesInput | string[]
    images?: RoomCreateimagesInput | string[]
    view: string
    isDeleted?: boolean
    user?: RoomReservationCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutExtraServicesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomNum: string
    types?: $Enums.RoomTypes
    price: string
    description: string
    aminities?: RoomCreateaminitiesInput | string[]
    images?: RoomCreateimagesInput | string[]
    view: string
    isDeleted?: boolean
    user?: RoomReservationUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutExtraServicesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutExtraServicesInput, RoomUncheckedCreateWithoutExtraServicesInput>
  }

  export type RoomUpsertWithoutExtraServicesInput = {
    update: XOR<RoomUpdateWithoutExtraServicesInput, RoomUncheckedUpdateWithoutExtraServicesInput>
    create: XOR<RoomCreateWithoutExtraServicesInput, RoomUncheckedCreateWithoutExtraServicesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutExtraServicesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutExtraServicesInput, RoomUncheckedUpdateWithoutExtraServicesInput>
  }

  export type RoomUpdateWithoutExtraServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNum?: StringFieldUpdateOperationsInput | string
    types?: EnumRoomTypesFieldUpdateOperationsInput | $Enums.RoomTypes
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    aminities?: RoomUpdateaminitiesInput | string[]
    images?: RoomUpdateimagesInput | string[]
    view?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: RoomReservationUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutExtraServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNum?: StringFieldUpdateOperationsInput | string
    types?: EnumRoomTypesFieldUpdateOperationsInput | $Enums.RoomTypes
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    aminities?: RoomUpdateaminitiesInput | string[]
    images?: RoomUpdateimagesInput | string[]
    view?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: RoomReservationUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type UserCreateWithoutReviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationCreateNestedManyWithoutUserInput
    menu?: MenuCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationUncheckedCreateNestedManyWithoutUserInput
    menu?: MenuUncheckedCreateNestedManyWithoutUserInput
    clubHouse?: ClubHouseUncheckedCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
  }

  export type UserUpsertWithoutReviewInput = {
    update: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
  }

  export type UserUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUpdateManyWithoutUserNestedInput
    menu?: MenuUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUncheckedUpdateManyWithoutUserNestedInput
    menu?: MenuUncheckedUpdateManyWithoutUserNestedInput
    clubHouse?: ClubHouseUncheckedUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdminCreateWithoutRestaurantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsCreateNestedManyWithoutAdminInput
    contact?: ContactUsCreateNestedManyWithoutByAdminInput
    AppSettings?: AppSettingsCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidCreateNestedOneWithoutByAdminInput
  }

  export type AdminUncheckedCreateWithoutRestaurantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsUncheckedCreateNestedManyWithoutAdminInput
    contact?: ContactUsUncheckedCreateNestedManyWithoutByAdminInput
    AppSettings?: AppSettingsUncheckedCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidUncheckedCreateNestedOneWithoutByAdminInput
  }

  export type AdminCreateOrConnectWithoutRestaurantInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutRestaurantInput, AdminUncheckedCreateWithoutRestaurantInput>
  }

  export type MenuCreateWithoutRestaurantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutRestaurantInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MenuCreateOrConnectWithoutRestaurantInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput>
  }

  export type MenuCreateManyRestaurantInputEnvelope = {
    data: MenuCreateManyRestaurantInput | MenuCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutRestaurantInput = {
    update: XOR<AdminUpdateWithoutRestaurantInput, AdminUncheckedUpdateWithoutRestaurantInput>
    create: XOR<AdminCreateWithoutRestaurantInput, AdminUncheckedCreateWithoutRestaurantInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutRestaurantInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutRestaurantInput, AdminUncheckedUpdateWithoutRestaurantInput>
  }

  export type AdminUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUpdateManyWithoutByAdminNestedInput
    AppSettings?: AppSettingsUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUpdateOneWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUncheckedUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUncheckedUpdateManyWithoutByAdminNestedInput
    AppSettings?: AppSettingsUncheckedUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput
  }

  export type MenuUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutRestaurantInput, MenuUncheckedUpdateWithoutRestaurantInput>
    create: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutRestaurantInput, MenuUncheckedUpdateWithoutRestaurantInput>
  }

  export type MenuUpdateManyWithWhereWithoutRestaurantInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type UserCreateWithoutMenuInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedOneWithoutUserInput
    clubHouse?: ClubHouseCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMenuInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedOneWithoutUserInput
    clubHouse?: ClubHouseUncheckedCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMenuInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMenuInput, UserUncheckedCreateWithoutMenuInput>
  }

  export type RestaurantCreateWithoutMenuInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    user: AdminCreateNestedOneWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutMenuInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type RestaurantCreateOrConnectWithoutMenuInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutMenuInput, RestaurantUncheckedCreateWithoutMenuInput>
  }

  export type UserUpsertWithoutMenuInput = {
    update: XOR<UserUpdateWithoutMenuInput, UserUncheckedUpdateWithoutMenuInput>
    create: XOR<UserCreateWithoutMenuInput, UserUncheckedCreateWithoutMenuInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMenuInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMenuInput, UserUncheckedUpdateWithoutMenuInput>
  }

  export type UserUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateOneWithoutUserNestedInput
    clubHouse?: ClubHouseUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateOneWithoutUserNestedInput
    clubHouse?: ClubHouseUncheckedUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RestaurantUpsertWithoutMenuInput = {
    update: XOR<RestaurantUpdateWithoutMenuInput, RestaurantUncheckedUpdateWithoutMenuInput>
    create: XOR<RestaurantCreateWithoutMenuInput, RestaurantUncheckedCreateWithoutMenuInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutMenuInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutMenuInput, RestaurantUncheckedUpdateWithoutMenuInput>
  }

  export type RestaurantUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    user?: AdminUpdateOneRequiredWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutClubHouseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedOneWithoutUserInput
    menu?: MenuCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClubHouseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fName: string
    lName: string
    username: string
    email: string
    password: string
    profilePic?: string | null
    birthDate: Date | string
    country: string
    nationalID: string
    isBlocked?: boolean
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    room?: RoomReservationUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedOneWithoutUserInput
    menu?: MenuUncheckedCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutUserInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClubHouseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClubHouseInput, UserUncheckedCreateWithoutClubHouseInput>
  }

  export type UserUpsertWithoutClubHouseInput = {
    update: XOR<UserUpdateWithoutClubHouseInput, UserUncheckedUpdateWithoutClubHouseInput>
    create: XOR<UserCreateWithoutClubHouseInput, UserUncheckedCreateWithoutClubHouseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClubHouseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClubHouseInput, UserUncheckedUpdateWithoutClubHouseInput>
  }

  export type UserUpdateWithoutClubHouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateOneWithoutUserNestedInput
    menu?: MenuUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClubHouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fName?: StringFieldUpdateOperationsInput | string
    lName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    nationalID?: StringFieldUpdateOperationsInput | string
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    room?: RoomReservationUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateOneWithoutUserNestedInput
    menu?: MenuUncheckedUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutUserNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdminCreateWithoutNewsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    contact?: ContactUsCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidCreateNestedOneWithoutByAdminInput
  }

  export type AdminUncheckedCreateWithoutNewsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    contact?: ContactUsUncheckedCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsUncheckedCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidUncheckedCreateNestedOneWithoutByAdminInput
  }

  export type AdminCreateOrConnectWithoutNewsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutNewsInput, AdminUncheckedCreateWithoutNewsInput>
  }

  export type ReplyCreateWithoutNewsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    comment: string
    isDeleted?: boolean
  }

  export type ReplyUncheckedCreateWithoutNewsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    comment: string
    isDeleted?: boolean
  }

  export type ReplyCreateOrConnectWithoutNewsInput = {
    where: ReplyWhereUniqueInput
    create: XOR<ReplyCreateWithoutNewsInput, ReplyUncheckedCreateWithoutNewsInput>
  }

  export type ReplyCreateManyNewsInputEnvelope = {
    data: ReplyCreateManyNewsInput | ReplyCreateManyNewsInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutNewsInput = {
    update: XOR<AdminUpdateWithoutNewsInput, AdminUncheckedUpdateWithoutNewsInput>
    create: XOR<AdminCreateWithoutNewsInput, AdminUncheckedCreateWithoutNewsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutNewsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutNewsInput, AdminUncheckedUpdateWithoutNewsInput>
  }

  export type AdminUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    contact?: ContactUsUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUpdateOneWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    contact?: ContactUsUncheckedUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUncheckedUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUncheckedUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput
  }

  export type ReplyUpsertWithWhereUniqueWithoutNewsInput = {
    where: ReplyWhereUniqueInput
    update: XOR<ReplyUpdateWithoutNewsInput, ReplyUncheckedUpdateWithoutNewsInput>
    create: XOR<ReplyCreateWithoutNewsInput, ReplyUncheckedCreateWithoutNewsInput>
  }

  export type ReplyUpdateWithWhereUniqueWithoutNewsInput = {
    where: ReplyWhereUniqueInput
    data: XOR<ReplyUpdateWithoutNewsInput, ReplyUncheckedUpdateWithoutNewsInput>
  }

  export type ReplyUpdateManyWithWhereWithoutNewsInput = {
    where: ReplyScalarWhereInput
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyWithoutNewsInput>
  }

  export type ReplyScalarWhereInput = {
    AND?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
    OR?: ReplyScalarWhereInput[]
    NOT?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
    id?: StringFilter<"Reply"> | string
    newsId?: StringFilter<"Reply"> | string
    createdAt?: DateTimeFilter<"Reply"> | Date | string
    updatedAt?: DateTimeFilter<"Reply"> | Date | string
    fullName?: StringFilter<"Reply"> | string
    email?: StringFilter<"Reply"> | string
    comment?: StringFilter<"Reply"> | string
    isDeleted?: BoolFilter<"Reply"> | boolean
  }

  export type NewsCreateWithoutRepliesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    subTitle: string
    description: string
    images?: NewsCreateimagesInput | string[]
    isDeleted?: boolean
    admin: AdminCreateNestedOneWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutRepliesInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    subTitle: string
    description: string
    images?: NewsCreateimagesInput | string[]
    isDeleted?: boolean
  }

  export type NewsCreateOrConnectWithoutRepliesInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutRepliesInput, NewsUncheckedCreateWithoutRepliesInput>
  }

  export type NewsUpsertWithoutRepliesInput = {
    update: XOR<NewsUpdateWithoutRepliesInput, NewsUncheckedUpdateWithoutRepliesInput>
    create: XOR<NewsCreateWithoutRepliesInput, NewsUncheckedCreateWithoutRepliesInput>
    where?: NewsWhereInput
  }

  export type NewsUpdateToOneWithWhereWithoutRepliesInput = {
    where?: NewsWhereInput
    data: XOR<NewsUpdateWithoutRepliesInput, NewsUncheckedUpdateWithoutRepliesInput>
  }

  export type NewsUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    images?: NewsUpdateimagesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    images?: NewsUpdateimagesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminCreateWithoutContactInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsCreateNestedManyWithoutAdminInput
    restaurant?: RestaurantCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidCreateNestedOneWithoutByAdminInput
  }

  export type AdminUncheckedCreateWithoutContactInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsUncheckedCreateNestedManyWithoutAdminInput
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsUncheckedCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidUncheckedCreateNestedOneWithoutByAdminInput
  }

  export type AdminCreateOrConnectWithoutContactInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutContactInput, AdminUncheckedCreateWithoutContactInput>
  }

  export type AdminUpsertWithoutContactInput = {
    update: XOR<AdminUpdateWithoutContactInput, AdminUncheckedUpdateWithoutContactInput>
    create: XOR<AdminCreateWithoutContactInput, AdminUncheckedCreateWithoutContactInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutContactInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutContactInput, AdminUncheckedUpdateWithoutContactInput>
  }

  export type AdminUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUpdateManyWithoutAdminNestedInput
    restaurant?: RestaurantUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUpdateOneWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUncheckedUpdateManyWithoutAdminNestedInput
    restaurant?: RestaurantUncheckedUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUncheckedUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput
  }

  export type AdminCreateWithoutAppSettingsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsCreateNestedManyWithoutAdminInput
    contact?: ContactUsCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidCreateNestedOneWithoutByAdminInput
  }

  export type AdminUncheckedCreateWithoutAppSettingsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsUncheckedCreateNestedManyWithoutAdminInput
    contact?: ContactUsUncheckedCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutUserInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput
    PromotionVid?: PromotionVidUncheckedCreateNestedOneWithoutByAdminInput
  }

  export type AdminCreateOrConnectWithoutAppSettingsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAppSettingsInput, AdminUncheckedCreateWithoutAppSettingsInput>
  }

  export type AdminUpsertWithoutAppSettingsInput = {
    update: XOR<AdminUpdateWithoutAppSettingsInput, AdminUncheckedUpdateWithoutAppSettingsInput>
    create: XOR<AdminCreateWithoutAppSettingsInput, AdminUncheckedCreateWithoutAppSettingsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAppSettingsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAppSettingsInput, AdminUncheckedUpdateWithoutAppSettingsInput>
  }

  export type AdminUpdateWithoutAppSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUpdateOneWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAppSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUncheckedUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUncheckedUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUncheckedUpdateManyWithoutUserNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput
    PromotionVid?: PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput
  }

  export type AdminCreateWithoutHomeSlidersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsCreateNestedManyWithoutAdminInput
    contact?: ContactUsCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutAdminInput
    PromotionVid?: PromotionVidCreateNestedOneWithoutByAdminInput
  }

  export type AdminUncheckedCreateWithoutHomeSlidersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsUncheckedCreateNestedManyWithoutAdminInput
    contact?: ContactUsUncheckedCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsUncheckedCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutAdminInput
    PromotionVid?: PromotionVidUncheckedCreateNestedOneWithoutByAdminInput
  }

  export type AdminCreateOrConnectWithoutHomeSlidersInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutHomeSlidersInput, AdminUncheckedCreateWithoutHomeSlidersInput>
  }

  export type AdminUpsertWithoutHomeSlidersInput = {
    update: XOR<AdminUpdateWithoutHomeSlidersInput, AdminUncheckedUpdateWithoutHomeSlidersInput>
    create: XOR<AdminCreateWithoutHomeSlidersInput, AdminUncheckedCreateWithoutHomeSlidersInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutHomeSlidersInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutHomeSlidersInput, AdminUncheckedUpdateWithoutHomeSlidersInput>
  }

  export type AdminUpdateWithoutHomeSlidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutAdminNestedInput
    PromotionVid?: PromotionVidUpdateOneWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutHomeSlidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUncheckedUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUncheckedUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUncheckedUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUncheckedUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput
    PromotionVid?: PromotionVidUncheckedUpdateOneWithoutByAdminNestedInput
  }

  export type AdminCreateWithoutPromotionVidInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsCreateNestedManyWithoutAdminInput
    contact?: ContactUsCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersCreateNestedManyWithoutByAdminInput
  }

  export type AdminUncheckedCreateWithoutPromotionVidInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    password: string
    username: string
    profilePic?: string | null
    birthDate: Date | string
    phoneNum: string
    isDeleted?: boolean
    emailConfirmed?: boolean
    role?: $Enums.ROLE
    news?: NewsUncheckedCreateNestedManyWithoutAdminInput
    contact?: ContactUsUncheckedCreateNestedManyWithoutByAdminInput
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutUserInput
    AppSettings?: AppSettingsUncheckedCreateNestedManyWithoutAdminInput
    ResetToken?: ResetTokenUncheckedCreateNestedOneWithoutAdminInput
    ConfirmToken?: ConfirmTokenUncheckedCreateNestedOneWithoutAdminInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedOneWithoutAdminInput
    HomeSliders?: HomeSlidersUncheckedCreateNestedManyWithoutByAdminInput
  }

  export type AdminCreateOrConnectWithoutPromotionVidInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutPromotionVidInput, AdminUncheckedCreateWithoutPromotionVidInput>
  }

  export type AdminUpsertWithoutPromotionVidInput = {
    update: XOR<AdminUpdateWithoutPromotionVidInput, AdminUncheckedUpdateWithoutPromotionVidInput>
    create: XOR<AdminCreateWithoutPromotionVidInput, AdminUncheckedCreateWithoutPromotionVidInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutPromotionVidInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutPromotionVidInput, AdminUncheckedUpdateWithoutPromotionVidInput>
  }

  export type AdminUpdateWithoutPromotionVidInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUpdateManyWithoutByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutPromotionVidInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    emailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumROLEFieldUpdateOperationsInput | $Enums.ROLE
    news?: NewsUncheckedUpdateManyWithoutAdminNestedInput
    contact?: ContactUsUncheckedUpdateManyWithoutByAdminNestedInput
    restaurant?: RestaurantUncheckedUpdateManyWithoutUserNestedInput
    AppSettings?: AppSettingsUncheckedUpdateManyWithoutAdminNestedInput
    ResetToken?: ResetTokenUncheckedUpdateOneWithoutAdminNestedInput
    ConfirmToken?: ConfirmTokenUncheckedUpdateOneWithoutAdminNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateOneWithoutAdminNestedInput
    HomeSliders?: HomeSlidersUncheckedUpdateManyWithoutByAdminNestedInput
  }

  export type NewsCreateManyAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    subTitle: string
    description: string
    images?: NewsCreateimagesInput | string[]
    isDeleted?: boolean
  }

  export type ContactUsCreateManyByAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    phoneNum: string
    subject: string
    description: string
    isDeleted?: boolean
    isRead?: boolean
  }

  export type RestaurantCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type AppSettingsCreateManyAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelName: string
    logo: string
    address: string
    phoneNum: string
    email: string
    socialMedia: JsonNullValueInput | InputJsonValue
  }

  export type HomeSlidersCreateManyByAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: string
    header: string
    paragraph: string
    isDeleted?: boolean
  }

  export type NewsUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    images?: NewsUpdateimagesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    replies?: ReplyUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    images?: NewsUpdateimagesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    replies?: ReplyUncheckedUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    images?: NewsUpdateimagesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactUsUpdateWithoutByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactUsUncheckedUpdateWithoutByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactUsUncheckedUpdateManyWithoutByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    menu?: MenuUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    menu?: MenuUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AppSettingsUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelName?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    socialMedia?: JsonNullValueInput | InputJsonValue
  }

  export type AppSettingsUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelName?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    socialMedia?: JsonNullValueInput | InputJsonValue
  }

  export type AppSettingsUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelName?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNum?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    socialMedia?: JsonNullValueInput | InputJsonValue
  }

  export type HomeSlidersUpdateWithoutByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    header?: StringFieldUpdateOperationsInput | string
    paragraph?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HomeSlidersUncheckedUpdateWithoutByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    header?: StringFieldUpdateOperationsInput | string
    paragraph?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HomeSlidersUncheckedUpdateManyWithoutByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    header?: StringFieldUpdateOperationsInput | string
    paragraph?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomReservationCreateManyUserInput = {
    id?: string
    roomId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: Date | string
    checkOut: Date | string
    adults: number
    children: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MenuCreateManyUserInput = {
    id?: string
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type ClubHouseCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clubhouseTypes: $Enums.clubhouseTypes
    description: string
    startTime: Date | string
    endTime: Date | string
    isDeleted?: boolean
  }

  export type RoomReservationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: RoomUpdateOneRequiredWithoutUserNestedInput
  }

  export type RoomReservationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoomReservationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restaurant?: RestaurantUpdateOneRequiredWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubHouseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubhouseTypes?: EnumclubhouseTypesFieldUpdateOperationsInput | $Enums.clubhouseTypes
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClubHouseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubhouseTypes?: EnumclubhouseTypesFieldUpdateOperationsInput | $Enums.clubhouseTypes
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClubHouseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubhouseTypes?: EnumclubhouseTypesFieldUpdateOperationsInput | $Enums.clubhouseTypes
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExtraServicesCreateManyRoomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    price: string
    facilities?: ExtraServicesCreatefacilitiesInput | string[]
    isDeleted?: boolean
  }

  export type RoomReservationCreateManyRoomInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: Date | string
    checkOut: Date | string
    adults: number
    children: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type ExtraServicesUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    facilities?: ExtraServicesUpdatefacilitiesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExtraServicesUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    facilities?: ExtraServicesUpdatefacilitiesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExtraServicesUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    facilities?: ExtraServicesUpdatefacilitiesInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomReservationUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRoomNestedInput
  }

  export type RoomReservationUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoomReservationUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuCreateManyRestaurantInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menuTypes: $Enums.MenuTypes
    name: string
    ingredients: string
    price: string
    image: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MenuUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MenuUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuTypes?: EnumMenuTypesFieldUpdateOperationsInput | $Enums.MenuTypes
    name?: StringFieldUpdateOperationsInput | string
    ingredients?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReplyCreateManyNewsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullName: string
    email: string
    comment: string
    isDeleted?: boolean
  }

  export type ReplyUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReplyUncheckedUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReplyUncheckedUpdateManyWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AdminCountOutputTypeDefaultArgs instead
     */
    export type AdminCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestaurantCountOutputTypeDefaultArgs instead
     */
    export type RestaurantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestaurantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsCountOutputTypeDefaultArgs instead
     */
    export type NewsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResetTokenDefaultArgs instead
     */
    export type ResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfirmTokenDefaultArgs instead
     */
    export type ConfirmTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfirmTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomReservationDefaultArgs instead
     */
    export type RoomReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomReservationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExtraServicesDefaultArgs instead
     */
    export type ExtraServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExtraServicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestaurantDefaultArgs instead
     */
    export type RestaurantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestaurantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuDefaultArgs instead
     */
    export type MenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClubHouseDefaultArgs instead
     */
    export type ClubHouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClubHouseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FAQSDefaultArgs instead
     */
    export type FAQSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FAQSDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsDefaultArgs instead
     */
    export type NewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReplyDefaultArgs instead
     */
    export type ReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactUsDefaultArgs instead
     */
    export type ContactUsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactUsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppSettingsDefaultArgs instead
     */
    export type AppSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HomeSlidersDefaultArgs instead
     */
    export type HomeSlidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HomeSlidersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionVidDefaultArgs instead
     */
    export type PromotionVidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionVidDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}